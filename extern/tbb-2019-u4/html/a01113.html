<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Intel(R) Threading Building Blocks Doxygen Documentation: tbb Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Intel(R) Threading Building Blocks Doxygen Documentation
   &#160;<span id="projectnumber">version 4.2.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a01113.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tbb Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The graph class.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a01114"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01114.html">flow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01123"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01123.html">interface5</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01125"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01125.html">interface6</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01127"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01127.html">interface7</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01130"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01130.html">interface8</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01131"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01131.html">interface9</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01133"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01133.html">internal</a></td></tr>
<tr class="memdesc:a01133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifiers declared inside namespace internal should never be used directly by client code. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01139"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01139.html">serial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01141"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01141.html">strict_ppl</a></td></tr>
<tr class="memdesc:a01141"><td class="mdescLeft">&#160;</td><td class="mdescRight">For internal use only. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01143"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01143.html">this_task_arena</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01144"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01144.html">this_tbb_thread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html">affinity_partitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An affinity partitioner.  <a href="a00030.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00042.html">aligned_space</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block of space aligned sufficiently to construct an array T with N elements.  <a href="a00042.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html">atomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template for atomic.  <a href="a00079.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html">atomic&lt; T * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <a class="el" href="a00080.html" title="Specialization for atomic&lt;T*&gt; with arithmetic and operator-&gt;. ">atomic&lt;T*&gt;</a> with arithmetic and operator-&gt;.  <a href="a00080.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html">atomic&lt; void * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <a class="el" href="a00081.html" title="Specialization for atomic&lt;void*&gt;, for sake of not allowing arithmetic or operator-&gt;. ">atomic&lt;void*&gt;</a>, for sake of not allowing arithmetic or operator-&gt;.  <a href="a00081.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">auto_partitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An auto partitioner.  <a href="a00100.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html">bad_last_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for concurrent containers.  <a href="a00101.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00107.html">blocked_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range over which to iterate.  <a href="a00107.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html">blocked_range2d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2-dimensional range that models the Range concept.  <a href="a00108.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html">blocked_range3d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3-dimensional range that models the Range concept.  <a href="a00109.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00121.html">cache_aligned_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00121.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html">cache_aligned_allocator&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00122.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html">captured_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used by TBB to propagate information about unhandled exceptions into the root thread.  <a href="a00127.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html">combinable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-local storage with optional reduction.  <a href="a00133.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00142.html">concurrent_bounded_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A high-performance thread-safe blocking concurrent bounded queue.  <a href="a00142.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html">concurrent_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concurrent vector container.  <a href="a00168.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00241.html">empty_task</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">task that does nothing. Useful for synchronization.  <a href="a00241.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00255.html">filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stage in a pipeline.  <a href="a00255.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00260.html">final_scan_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to indicate that the final scan is being performed.  <a href="a00260.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00333.html">improper_lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for PPL locks.  <a href="a00333.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00393.html">invalid_multiple_scheduling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for repeated scheduling of the same <a class="el" href="a00785.html">task_handle</a>.  <a href="a00393.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00500.html">missing_wait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for missing wait on <a class="el" href="a00765.html">structured_task_group</a>.  <a href="a00500.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00501.html">movable_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template that can be used to implement exception that transfers arbitrary ExceptionData to the root thread.  <a href="a00501.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00511.html">mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around the platform's native lock.  <a href="a00511.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00522.html">null_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutex which does nothing.  <a href="a00522.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00523.html">null_rw_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A rw mutex which does nothing.  <a href="a00523.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00573.html">parallel_while</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration over a stream, with optional addition of more work.  <a href="a00573.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00589.html">pipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A processing pipeline that applies filters to items.  <a href="a00589.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00598.html">pre_scan_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to indicate that the initial scan is being performed.  <a href="a00598.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00608.html">proportional_split</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type enables transmission of splitting proportion from partitioners to range objects.  <a href="a00608.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00620.html">queuing_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queuing mutex with local-only spinning.  <a href="a00620.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00621.html">queuing_rw_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queuing reader-writer mutex with local-only spinning.  <a href="a00621.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00647.html">recursive_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex that allows recursive mutex acquisition.  <a href="a00647.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00708.html">simple_partitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple partitioner.  <a href="a00708.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00721.html">spin_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lock that occupies a single byte.  <a href="a00721.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00722.html">spin_rw_mutex_v3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast, unfair, spinning reader-writer lock with backoff and writer-preference.  <a href="a00722.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00723.html">split</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy type that distinguishes splitting constructor from copy constructor.  <a href="a00723.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00736.html">static_partitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A static partitioner.  <a href="a00736.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00765.html">structured_task_group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00778.html">task</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for user-defined tasks.  <a href="a00778.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00782.html">task_group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00784.html">task_group_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to form groups of tasks.  <a href="a00784.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00785.html">task_handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00788.html">task_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of children.  <a href="a00788.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00791.html">task_scheduler_init</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class delimiting the scope of task scheduler activity.  <a href="a00791.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00797.html">tbb_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00797.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00798.html">tbb_allocator&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00798.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00799.html">tbb_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to be implemented by all exceptions TBB recognizes and propagates across the threads.  <a href="a00799.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00801.html">tbb_hash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00802.html">tbb_hash_compare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash_compare that is default argument for concurrent_hash_map  <a href="a00802.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00821.html">thread_bound_filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stage in a pipeline served by a user thread.  <a href="a00821.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00827.html">tick_count</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute timestamp.  <a href="a00827.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00834.html">tricky_atomic_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A view of a T* with additional functionality for twiddling low-order bits.  <a href="a00834.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00878.html">user_abort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for user-initiated abort.  <a href="a00878.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00934.html">zero_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00934.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00935.html">zero_allocator&lt; void, Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00935.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a889d8f126388fdc24c597d195a4d7028"><td class="memItemLeft" align="right" valign="top">typedef internal::critical_section_v4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#a889d8f126388fdc24c597d195a4d7028">critical_section</a></td></tr>
<tr class="separator:a889d8f126388fdc24c597d195a4d7028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa37cbd66059817a12393e6ff53ae3be"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00554.html">interface7::internal::padded_mutex</a>&lt; <a class="el" href="a00721.html">spin_mutex</a>, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01148.html#gaaa37cbd66059817a12393e6ff53ae3be">speculative_spin_mutex</a></td></tr>
<tr class="memdesc:gaaa37cbd66059817a12393e6ff53ae3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cross-platform spin mutex with speculative lock acquisition.  <a href="a01148.html#gaaa37cbd66059817a12393e6ff53ae3be">More...</a><br /></td></tr>
<tr class="separator:gaaa37cbd66059817a12393e6ff53ae3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc3d02744cab8ac389919806d47e417"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00722.html">spin_rw_mutex_v3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#a6cc3d02744cab8ac389919806d47e417">spin_rw_mutex</a></td></tr>
<tr class="separator:a6cc3d02744cab8ac389919806d47e417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a268320974a3357e9609a2f98be5090"><td class="memItemLeft" align="right" valign="top">typedef std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#a1a268320974a3357e9609a2f98be5090">stack_size_type</a></td></tr>
<tr class="separator:a1a268320974a3357e9609a2f98be5090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58de4ab3200dd2bd621f052c6f677e4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00792.html">tbb::internal::task_scheduler_observer_v3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#af58de4ab3200dd2bd621f052c6f677e4">task_scheduler_observer</a></td></tr>
<tr class="separator:af58de4ab3200dd2bd621f052c6f677e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7805ca254302ff88b566f7dcde7e56b0"><td class="memItemLeft" align="right" valign="top">typedef internal::tbb_thread_v3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#a7805ca254302ff88b566f7dcde7e56b0">tbb_thread</a></td></tr>
<tr class="memdesc:a7805ca254302ff88b566f7dcde7e56b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Users reference thread class by name tbb_thread.  <a href="#a7805ca254302ff88b566f7dcde7e56b0">More...</a><br /></td></tr>
<tr class="separator:a7805ca254302ff88b566f7dcde7e56b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0195ccca203ba1b9f262ac1ee8d813"><td class="memItemLeft" align="right" valign="top">typedef char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#abb0195ccca203ba1b9f262ac1ee8d813">tchar</a></td></tr>
<tr class="memdesc:abb0195ccca203ba1b9f262ac1ee8d813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unicode support.  <a href="#abb0195ccca203ba1b9f262ac1ee8d813">More...</a><br /></td></tr>
<tr class="separator:abb0195ccca203ba1b9f262ac1ee8d813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab1a8559dba9ec44a3deddacadb7d49"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00834.html">tricky_atomic_pointer</a>&lt; <a class="el" href="a00684.html">queuing_rw_mutex::scoped_lock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#abab1a8559dba9ec44a3deddacadb7d49">tricky_pointer</a></td></tr>
<tr class="separator:abab1a8559dba9ec44a3deddacadb7d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce76b9d59c776788ddbd1588a18af42"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#acce76b9d59c776788ddbd1588a18af42">assertion_handler_type</a>) (const char *filename, <a class="el" href="a01016.html#ac89988b817e773286215b17e80359ff3">int</a> line, const char *expression, const char *comment)</td></tr>
<tr class="memdesc:acce76b9d59c776788ddbd1588a18af42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for an assertion handler.  <a href="#acce76b9d59c776788ddbd1588a18af42">More...</a><br /></td></tr>
<tr class="separator:acce76b9d59c776788ddbd1588a18af42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:adb86d08473679d6fe0eabcdc766ffe3a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3a">memory_semantics</a> { <a class="el" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa6a315190cf4509ec388ecb423432f36a">full_fence</a>, 
<a class="el" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aaa92646b4dc7618530d3a9f51dd10a418">acquire</a>, 
<a class="el" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa412563418e657114a102db610f726632">release</a>, 
<a class="el" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>
 }<tr class="memdesc:adb86d08473679d6fe0eabcdc766ffe3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies memory semantics.  <a href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:adb86d08473679d6fe0eabcdc766ffe3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bcb6154c8307fa9f97806afddf2288"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#ac5bcb6154c8307fa9f97806afddf2288">ets_key_usage_type</a> { <a class="el" href="a01113.html#ac5bcb6154c8307fa9f97806afddf2288a012d63023e77883481c1299aa19e93ca">ets_key_per_instance</a>, 
<a class="el" href="a01113.html#ac5bcb6154c8307fa9f97806afddf2288aa4c70b844e9456997103856e75f725c8">ets_no_key</a>
 }<tr class="memdesc:ac5bcb6154c8307fa9f97806afddf2288"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum for selecting between single key and key-per-instance versions  <a href="a01113.html#ac5bcb6154c8307fa9f97806afddf2288">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac5bcb6154c8307fa9f97806afddf2288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0404d60533bc35fdf76d52ed166317f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#ab0404d60533bc35fdf76d52ed166317f">priority_t</a> { <a class="el" href="a01113.html#ab0404d60533bc35fdf76d52ed166317fa65b5d270dd5bc13800951b452acf90bc">priority_normal</a> = internal::priority_stride_v4 * 2, 
<a class="el" href="a01113.html#ab0404d60533bc35fdf76d52ed166317fae0bf5301fd3abb024d73231ff1c097c4">priority_low</a> = priority_normal - internal::priority_stride_v4, 
<a class="el" href="a01113.html#ab0404d60533bc35fdf76d52ed166317fabedb90c118e48a5f09757d4ecff6caf4">priority_high</a> = priority_normal + internal::priority_stride_v4
 }</td></tr>
<tr class="separator:ab0404d60533bc35fdf76d52ed166317f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4454db821441ca68bad263d82c40fb7a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#a4454db821441ca68bad263d82c40fb7a">task_group_status</a> { <a class="el" href="a01113.html#a4454db821441ca68bad263d82c40fb7aaab1411f4c406df521cf3a57b4540a109">not_complete</a>, 
<a class="el" href="a01113.html#a4454db821441ca68bad263d82c40fb7aa16ee546d9c961d3311ab99f3528d0bb5">complete</a>, 
<a class="el" href="a01113.html#a4454db821441ca68bad263d82c40fb7aa2aee070418c1a4ee59b714d978e39b5e">canceled</a>
 }</td></tr>
<tr class="separator:a4454db821441ca68bad263d82c40fb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad819a3df876043ef1be649b4f80934ca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#ad819a3df876043ef1be649b4f80934ca">state_t_flags</a> { <br />
&#160;&#160;<a class="el" href="a01113.html#ad819a3df876043ef1be649b4f80934caaa68a37750c7f09b142c617120cb3b01d">STATE_NONE</a> = 0, 
<a class="el" href="a01113.html#ad819a3df876043ef1be649b4f80934caa5e91e526baccdb744e32a3b4cc2934b0">STATE_WRITER</a> = 1&lt;&lt;0, 
<a class="el" href="a01113.html#ad819a3df876043ef1be649b4f80934caa575000da0a781cbf88c95e903cca9c04">STATE_READER</a> = 1&lt;&lt;1, 
<a class="el" href="a01113.html#ad819a3df876043ef1be649b4f80934caad7c9f3aaac3d1b2f2ba873eddfe88fe2">STATE_READER_UNBLOCKNEXT</a> = 1&lt;&lt;2, 
<br />
&#160;&#160;<a class="el" href="a01113.html#ad819a3df876043ef1be649b4f80934caa8be35adde6bb8652d1fd459605d0f1d2">STATE_ACTIVEREADER</a> = 1&lt;&lt;3, 
<a class="el" href="a01113.html#ad819a3df876043ef1be649b4f80934caa7a48f88dbc45c856dce803381b9b828c">STATE_UPGRADE_REQUESTED</a> = 1&lt;&lt;4, 
<a class="el" href="a01113.html#ad819a3df876043ef1be649b4f80934caa48020cf78ec3370ac70113fd7db86a90">STATE_UPGRADE_WAITING</a> = 1&lt;&lt;5, 
<a class="el" href="a01113.html#ad819a3df876043ef1be649b4f80934caaf963008418de13d883738eb998b1bcd2">STATE_UPGRADE_LOSER</a> = 1&lt;&lt;6, 
<br />
&#160;&#160;<a class="el" href="a01113.html#ad819a3df876043ef1be649b4f80934caa7cfb6b8c1da59837add085ce89ea5d77">STATE_COMBINED_WAITINGREADER</a> = STATE_READER | STATE_READER_UNBLOCKNEXT, 
<a class="el" href="a01113.html#ad819a3df876043ef1be649b4f80934caa1a466cd7f11f2bfde068abc90f85d7d7">STATE_COMBINED_READER</a> = STATE_COMBINED_WAITINGREADER | STATE_ACTIVEREADER, 
<a class="el" href="a01113.html#ad819a3df876043ef1be649b4f80934caa98ebdac7720db62d8ce0ba4277f3c39c">STATE_COMBINED_UPGRADING</a> = STATE_UPGRADE_WAITING | STATE_UPGRADE_LOSER
<br />
 }<tr class="memdesc:ad819a3df876043ef1be649b4f80934ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag bits in a state_t that specify information about a locking request.  <a href="a01113.html#ad819a3df876043ef1be649b4f80934ca">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad819a3df876043ef1be649b4f80934ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aed82c77b389b208a1c27012a2fc0b5fd"><td class="memTemplParams" colspan="2">template&lt;memory_semantics M, typename T &gt; </td></tr>
<tr class="memitem:aed82c77b389b208a1c27012a2fc0b5fd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#aed82c77b389b208a1c27012a2fc0b5fd">load</a> (const <a class="el" href="a00079.html">atomic</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:aed82c77b389b208a1c27012a2fc0b5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219b97248f55c909aa3d84e43934b105"><td class="memTemplParams" colspan="2">template&lt;memory_semantics M, typename T &gt; </td></tr>
<tr class="memitem:a219b97248f55c909aa3d84e43934b105"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#a219b97248f55c909aa3d84e43934b105">store</a> (<a class="el" href="a00079.html">atomic</a>&lt; T &gt; &amp;a, T <a class="el" href="a01016.html#a2507091f87afae57e117a984a7c4dd61">value</a>)</td></tr>
<tr class="separator:a219b97248f55c909aa3d84e43934b105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a6826cf4fb8845d26d8d1f1ad0b5fa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a49a6826cf4fb8845d26d8d1f1ad0b5fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#a49a6826cf4fb8845d26d8d1f1ad0b5fa">operator==</a> (const <a class="el" href="a00121.html">cache_aligned_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00121.html">cache_aligned_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:a49a6826cf4fb8845d26d8d1f1ad0b5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaaf3f3248efc804c6f6fe35855704d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:afdaaf3f3248efc804c6f6fe35855704d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#afdaaf3f3248efc804c6f6fe35855704d">operator!=</a> (const <a class="el" href="a00121.html">cache_aligned_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00121.html">cache_aligned_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:afdaaf3f3248efc804c6f6fe35855704d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db9470dd2871cb7394ab262dca2051a"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename HashCompare , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:a1db9470dd2871cb7394ab262dca2051a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#a1db9470dd2871cb7394ab262dca2051a">operator==</a> (const concurrent_hash_map&lt; Key, T, HashCompare, A1 &gt; &amp;a, const concurrent_hash_map&lt; Key, T, HashCompare, A2 &gt; &amp;b)</td></tr>
<tr class="separator:a1db9470dd2871cb7394ab262dca2051a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05667bcb12f763124fcda402d3720c6a"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename HashCompare , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:a05667bcb12f763124fcda402d3720c6a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#a05667bcb12f763124fcda402d3720c6a">operator!=</a> (const concurrent_hash_map&lt; Key, T, HashCompare, A1 &gt; &amp;a, const concurrent_hash_map&lt; Key, T, HashCompare, A2 &gt; &amp;b)</td></tr>
<tr class="separator:a05667bcb12f763124fcda402d3720c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dc40ac2badc8b36b8cc70f92801b76"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T , typename HashCompare , typename A &gt; </td></tr>
<tr class="memitem:a16dc40ac2badc8b36b8cc70f92801b76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#a16dc40ac2badc8b36b8cc70f92801b76">swap</a> (concurrent_hash_map&lt; Key, T, HashCompare, A &gt; &amp;a, concurrent_hash_map&lt; Key, T, HashCompare, A &gt; &amp;b)</td></tr>
<tr class="separator:a16dc40ac2badc8b36b8cc70f92801b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ecee2d23f2486c03e720ab9e3ac36c"><td class="memTemplParams" colspan="2">template&lt;typename T , class A1 , class A2 &gt; </td></tr>
<tr class="memitem:a79ecee2d23f2486c03e720ab9e3ac36c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#a79ecee2d23f2486c03e720ab9e3ac36c">operator==</a> (const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>
<tr class="separator:a79ecee2d23f2486c03e720ab9e3ac36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7258c4acabadf94d03dc62e29396ea0"><td class="memTemplParams" colspan="2">template&lt;typename T , class A1 , class A2 &gt; </td></tr>
<tr class="memitem:ab7258c4acabadf94d03dc62e29396ea0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#ab7258c4acabadf94d03dc62e29396ea0">operator!=</a> (const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>
<tr class="separator:ab7258c4acabadf94d03dc62e29396ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1523d0389a8cbda80c17ae4f45caa3a6"><td class="memTemplParams" colspan="2">template&lt;typename T , class A1 , class A2 &gt; </td></tr>
<tr class="memitem:a1523d0389a8cbda80c17ae4f45caa3a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#a1523d0389a8cbda80c17ae4f45caa3a6">operator&lt;</a> (const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>
<tr class="separator:a1523d0389a8cbda80c17ae4f45caa3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cfed58bfde865b68859beb54805019"><td class="memTemplParams" colspan="2">template&lt;typename T , class A1 , class A2 &gt; </td></tr>
<tr class="memitem:a78cfed58bfde865b68859beb54805019"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#a78cfed58bfde865b68859beb54805019">operator&gt;</a> (const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>
<tr class="separator:a78cfed58bfde865b68859beb54805019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6009f009cd331952d8944bcc9733375"><td class="memTemplParams" colspan="2">template&lt;typename T , class A1 , class A2 &gt; </td></tr>
<tr class="memitem:ac6009f009cd331952d8944bcc9733375"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#ac6009f009cd331952d8944bcc9733375">operator&lt;=</a> (const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>
<tr class="separator:ac6009f009cd331952d8944bcc9733375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d82e59919a1f2c7caa06d061b2480f"><td class="memTemplParams" colspan="2">template&lt;typename T , class A1 , class A2 &gt; </td></tr>
<tr class="memitem:aa0d82e59919a1f2c7caa06d061b2480f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#aa0d82e59919a1f2c7caa06d061b2480f">operator&gt;=</a> (const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>
<tr class="separator:aa0d82e59919a1f2c7caa06d061b2480f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd91084f08db8c2d23c6a0362e0c441"><td class="memTemplParams" colspan="2">template&lt;typename T , class A &gt; </td></tr>
<tr class="memitem:a4cd91084f08db8c2d23c6a0362e0c441"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#a4cd91084f08db8c2d23c6a0362e0c441">swap</a> (<a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A &gt; &amp;a, <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A &gt; &amp;b)</td></tr>
<tr class="separator:a4cd91084f08db8c2d23c6a0362e0c441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef1698b222ba9312ab24dcdcd98bbd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#aaef1698b222ba9312ab24dcdcd98bbd8">is_current_task_group_canceling</a> ()</td></tr>
<tr class="separator:aaef1698b222ba9312ab24dcdcd98bbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8de49be152674baa036585a6fdb3cd"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:aef8de49be152674baa036585a6fdb3cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00785.html">task_handle</a>&lt; typename internal::strip&lt; F &gt;::<a class="el" href="a01016.html#a1fcad32d6fbfbc9f0564e010c1aaddff">type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#aef8de49be152674baa036585a6fdb3cd">make_task</a> (F &amp;&amp;f)</td></tr>
<tr class="separator:aef8de49be152674baa036585a6fdb3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1595d1bfc4f7be923c17b4ee5c556ae"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:af1595d1bfc4f7be923c17b4ee5c556ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#af1595d1bfc4f7be923c17b4ee5c556ae">operator==</a> (const <a class="el" href="a00797.html">tbb_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00797.html">tbb_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:af1595d1bfc4f7be923c17b4ee5c556ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ff968904aaa1bb0e2152f590c47be6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a82ff968904aaa1bb0e2152f590c47be6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#a82ff968904aaa1bb0e2152f590c47be6">operator!=</a> (const <a class="el" href="a00797.html">tbb_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00797.html">tbb_allocator</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:a82ff968904aaa1bb0e2152f590c47be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf465e2f6730e2cea0c9531bec9fb2f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , template&lt; typename X1 &gt; class B1, typename T2 , template&lt; typename X2 &gt; class B2&gt; </td></tr>
<tr class="memitem:a7bf465e2f6730e2cea0c9531bec9fb2f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#a7bf465e2f6730e2cea0c9531bec9fb2f">operator==</a> (const <a class="el" href="a00934.html">zero_allocator</a>&lt; T1, B1 &gt; &amp;a, const <a class="el" href="a00934.html">zero_allocator</a>&lt; T2, B2 &gt; &amp;b)</td></tr>
<tr class="separator:a7bf465e2f6730e2cea0c9531bec9fb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606762cf7c614cb5a1631955938737cd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , template&lt; typename X1 &gt; class B1, typename T2 , template&lt; typename X2 &gt; class B2&gt; </td></tr>
<tr class="memitem:a606762cf7c614cb5a1631955938737cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#a606762cf7c614cb5a1631955938737cd">operator!=</a> (const <a class="el" href="a00934.html">zero_allocator</a>&lt; T1, B1 &gt; &amp;a, const <a class="el" href="a00934.html">zero_allocator</a>&lt; T2, B2 &gt; &amp;b)</td></tr>
<tr class="separator:a606762cf7c614cb5a1631955938737cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e73b97b02726c692bd8d9da8e3fb1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#a33e73b97b02726c692bd8d9da8e3fb1b">atomic_fence</a> ()</td></tr>
<tr class="memdesc:a33e73b97b02726c692bd8d9da8e3fb1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequentially consistent full memory fence.  <a href="#a33e73b97b02726c692bd8d9da8e3fb1b">More...</a><br /></td></tr>
<tr class="separator:a33e73b97b02726c692bd8d9da8e3fb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c95ae5d0eb374299c1be4fdb8fb88e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01113.html#acce76b9d59c776788ddbd1588a18af42">assertion_handler_type</a> <a class="el" href="a01084.html#ab6dd3eee12dcbf8bc4c41513c4c4c9fb">__TBB_EXPORTED_FUNC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#a4c95ae5d0eb374299c1be4fdb8fb88e3">set_assertion_handler</a> (<a class="el" href="a01113.html#acce76b9d59c776788ddbd1588a18af42">assertion_handler_type</a> new_handler)</td></tr>
<tr class="memdesc:a4c95ae5d0eb374299c1be4fdb8fb88e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set assertion handler and return previous value of it.  <a href="#a4c95ae5d0eb374299c1be4fdb8fb88e3">More...</a><br /></td></tr>
<tr class="separator:a4c95ae5d0eb374299c1be4fdb8fb88e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dde30d14920b656e12809567da8f19b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01084.html#ab6dd3eee12dcbf8bc4c41513c4c4c9fb">__TBB_EXPORTED_FUNC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#a9dde30d14920b656e12809567da8f19b">assertion_failure</a> (const char *filename, <a class="el" href="a01016.html#ac89988b817e773286215b17e80359ff3">int</a> line, const char *expression, const char *comment)</td></tr>
<tr class="memdesc:a9dde30d14920b656e12809567da8f19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process an assertion failure.  <a href="#a9dde30d14920b656e12809567da8f19b">More...</a><br /></td></tr>
<tr class="separator:a9dde30d14920b656e12809567da8f19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f474a376c6d74ac55c943da765d609b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#ac89988b817e773286215b17e80359ff3">int</a> <a class="el" href="a01084.html#ab6dd3eee12dcbf8bc4c41513c4c4c9fb">__TBB_EXPORTED_FUNC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#a5f474a376c6d74ac55c943da765d609b">TBB_runtime_interface_version</a> ()</td></tr>
<tr class="memdesc:a5f474a376c6d74ac55c943da765d609b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the interface version of the TBB shared library being used.  <a href="#a5f474a376c6d74ac55c943da765d609b">More...</a><br /></td></tr>
<tr class="separator:a5f474a376c6d74ac55c943da765d609b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467930903ce9b7c240c4ad8f0fb8ae3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#a467930903ce9b7c240c4ad8f0fb8ae3d">swap</a> (internal::tbb_thread_v3 &amp;t1, internal::tbb_thread_v3 &amp;t2) <a class="el" href="a01098.html#a44fc319ff56fa8ec000270ae97d91c51">__TBB_NOEXCEPT</a>(true)</td></tr>
<tr class="separator:a467930903ce9b7c240c4ad8f0fb8ae3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41903d6b80e61bd6c605412e7820e08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#ac41903d6b80e61bd6c605412e7820e08">move</a> (<a class="el" href="a01113.html#a7805ca254302ff88b566f7dcde7e56b0">tbb_thread</a> &amp;t1, <a class="el" href="a01113.html#a7805ca254302ff88b566f7dcde7e56b0">tbb_thread</a> &amp;t2)</td></tr>
<tr class="separator:ac41903d6b80e61bd6c605412e7820e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa037c1f149250d61cd2fad4541a5e6cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00389.html">tick_count::interval_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#aa037c1f149250d61cd2fad4541a5e6cb">operator-</a> (const <a class="el" href="a00827.html">tick_count</a> &amp;t1, const <a class="el" href="a00827.html">tick_count</a> &amp;t0)</td></tr>
<tr class="separator:aa037c1f149250d61cd2fad4541a5e6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cfd6795ecbcc8ad30310c862f2b001"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#aa2cfd6795ecbcc8ad30310c862f2b001">get_flag</a> (<a class="el" href="a00684.html">queuing_rw_mutex::scoped_lock</a> *ptr)</td></tr>
<tr class="separator:aa2cfd6795ecbcc8ad30310c862f2b001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f048ce5bfca13f3bada9bfb09c1687e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f048ce5bfca13f3bada9bfb09c1687e"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01113.html#a5f048ce5bfca13f3bada9bfb09c1687e">CAS</a> (volatile T &amp;<a class="el" href="a01016.html#ae68d53ff4b00841ff67b2cfc6c316b29">addr</a>, T newv, T oldv)</td></tr>
<tr class="separator:a5f048ce5bfca13f3bada9bfb09c1687e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">parallel_do</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>See also requirements on <a class="el" href="a00003.html">parallel_do Body</a>. </p>
</div></td></tr>
<tr class="memitem:ga533f6732498ade8634a9470cbf89192d"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Body &gt; </td></tr>
<tr class="memitem:ga533f6732498ade8634a9470cbf89192d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga533f6732498ade8634a9470cbf89192d">parallel_do</a> (Iterator first, Iterator last, const Body &amp;body)</td></tr>
<tr class="memdesc:ga533f6732498ade8634a9470cbf89192d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration over a range, with optional addition of more work.  <a href="a01145.html#ga533f6732498ade8634a9470cbf89192d">More...</a><br /></td></tr>
<tr class="separator:ga533f6732498ade8634a9470cbf89192d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga135f72b966cd78a14f6aa1ddf0480701"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga135f72b966cd78a14f6aa1ddf0480701"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga135f72b966cd78a14f6aa1ddf0480701">parallel_do</a> (Range &amp;rng, const Body &amp;body)</td></tr>
<tr class="separator:ga135f72b966cd78a14f6aa1ddf0480701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf7a7c53d20fef24acaa2fe5cc36b45"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:gaaaf7a7c53d20fef24acaa2fe5cc36b45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gaaaf7a7c53d20fef24acaa2fe5cc36b45">parallel_do</a> (const Range &amp;rng, const Body &amp;body)</td></tr>
<tr class="separator:gaaaf7a7c53d20fef24acaa2fe5cc36b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7db29bc10d81eddc85854256ffc723c0"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Body &gt; </td></tr>
<tr class="memitem:ga7db29bc10d81eddc85854256ffc723c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga7db29bc10d81eddc85854256ffc723c0">parallel_do</a> (Iterator first, Iterator last, const Body &amp;body, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga7db29bc10d81eddc85854256ffc723c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration over a range, with optional addition of more work and user-supplied context.  <a href="a01145.html#ga7db29bc10d81eddc85854256ffc723c0">More...</a><br /></td></tr>
<tr class="separator:ga7db29bc10d81eddc85854256ffc723c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga137e8ff95a0c69e747f4f4f1383a2677"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga137e8ff95a0c69e747f4f4f1383a2677"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga137e8ff95a0c69e747f4f4f1383a2677">parallel_do</a> (Range &amp;rng, const Body &amp;body, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="separator:ga137e8ff95a0c69e747f4f4f1383a2677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40258ae16882a49d5d579407c88b3281"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga40258ae16882a49d5d579407c88b3281"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga40258ae16882a49d5d579407c88b3281">parallel_do</a> (const Range &amp;rng, const Body &amp;body, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="separator:ga40258ae16882a49d5d579407c88b3281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">parallel_for</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>See also requirements on <a class="el" href="a00002.html">Range</a> and <a class="el" href="a00004.html">parallel_for Body</a>. </p>
</div></td></tr>
<tr class="memitem:gaa8444c29dc4d2e527a1036717d109aef"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:gaa8444c29dc4d2e527a1036717d109aef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gaa8444c29dc4d2e527a1036717d109aef">parallel_for</a> (const Range &amp;range, const Body &amp;body)</td></tr>
<tr class="memdesc:gaa8444c29dc4d2e527a1036717d109aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration over range with default partitioner.  <a href="a01145.html#gaa8444c29dc4d2e527a1036717d109aef">More...</a><br /></td></tr>
<tr class="separator:gaa8444c29dc4d2e527a1036717d109aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9722d2bc7e5edb4fae9f3b55268a1ecc"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga9722d2bc7e5edb4fae9f3b55268a1ecc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga9722d2bc7e5edb4fae9f3b55268a1ecc">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00708.html">simple_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:ga9722d2bc7e5edb4fae9f3b55268a1ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration over range with simple partitioner.  <a href="a01145.html#ga9722d2bc7e5edb4fae9f3b55268a1ecc">More...</a><br /></td></tr>
<tr class="separator:ga9722d2bc7e5edb4fae9f3b55268a1ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c4b06f96ae33cefe78235841791902"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:gad6c4b06f96ae33cefe78235841791902"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gad6c4b06f96ae33cefe78235841791902">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00100.html">auto_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:gad6c4b06f96ae33cefe78235841791902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00100.html" title="An auto partitioner. ">auto_partitioner</a>.  <a href="a01145.html#gad6c4b06f96ae33cefe78235841791902">More...</a><br /></td></tr>
<tr class="separator:gad6c4b06f96ae33cefe78235841791902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14ae8670bd55620f906aa06e073bd225"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga14ae8670bd55620f906aa06e073bd225"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga14ae8670bd55620f906aa06e073bd225">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00736.html">static_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:ga14ae8670bd55620f906aa06e073bd225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00736.html" title="A static partitioner. ">static_partitioner</a>.  <a href="a01145.html#ga14ae8670bd55620f906aa06e073bd225">More...</a><br /></td></tr>
<tr class="separator:ga14ae8670bd55620f906aa06e073bd225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3d39e372d825bf54283b5ceafa90057"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:gaf3d39e372d825bf54283b5ceafa90057"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gaf3d39e372d825bf54283b5ceafa90057">parallel_for</a> (const Range &amp;range, const Body &amp;body, <a class="el" href="a00030.html">affinity_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:gaf3d39e372d825bf54283b5ceafa90057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00030.html" title="An affinity partitioner. ">affinity_partitioner</a>.  <a href="a01145.html#gaf3d39e372d825bf54283b5ceafa90057">More...</a><br /></td></tr>
<tr class="separator:gaf3d39e372d825bf54283b5ceafa90057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93a621202db94665144de38c0b09bdad"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga93a621202db94665144de38c0b09bdad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga93a621202db94665144de38c0b09bdad">parallel_for</a> (const Range &amp;range, const Body &amp;body, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga93a621202db94665144de38c0b09bdad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration over range with default partitioner and user-supplied context.  <a href="a01145.html#ga93a621202db94665144de38c0b09bdad">More...</a><br /></td></tr>
<tr class="separator:ga93a621202db94665144de38c0b09bdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b7fab9d6ffe7a9345e9349a5a007bd4"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga5b7fab9d6ffe7a9345e9349a5a007bd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga5b7fab9d6ffe7a9345e9349a5a007bd4">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00708.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga5b7fab9d6ffe7a9345e9349a5a007bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration over range with simple partitioner and user-supplied context.  <a href="a01145.html#ga5b7fab9d6ffe7a9345e9349a5a007bd4">More...</a><br /></td></tr>
<tr class="separator:ga5b7fab9d6ffe7a9345e9349a5a007bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c9935d8710a5cf786a92f3522ab2976"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga4c9935d8710a5cf786a92f3522ab2976"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga4c9935d8710a5cf786a92f3522ab2976">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00100.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga4c9935d8710a5cf786a92f3522ab2976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00100.html" title="An auto partitioner. ">auto_partitioner</a> and user-supplied context.  <a href="a01145.html#ga4c9935d8710a5cf786a92f3522ab2976">More...</a><br /></td></tr>
<tr class="separator:ga4c9935d8710a5cf786a92f3522ab2976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bb3d8cf616632476ca923eb056ee07d"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga4bb3d8cf616632476ca923eb056ee07d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga4bb3d8cf616632476ca923eb056ee07d">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00736.html">static_partitioner</a> &amp;partitioner, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga4bb3d8cf616632476ca923eb056ee07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00736.html" title="A static partitioner. ">static_partitioner</a> and user-supplied context.  <a href="a01145.html#ga4bb3d8cf616632476ca923eb056ee07d">More...</a><br /></td></tr>
<tr class="separator:ga4bb3d8cf616632476ca923eb056ee07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b1a9ac304ba1eb4f87ab8cc18dd281"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga62b1a9ac304ba1eb4f87ab8cc18dd281"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga62b1a9ac304ba1eb4f87ab8cc18dd281">parallel_for</a> (const Range &amp;range, const Body &amp;body, <a class="el" href="a00030.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga62b1a9ac304ba1eb4f87ab8cc18dd281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00030.html" title="An affinity partitioner. ">affinity_partitioner</a> and user-supplied context.  <a href="a01145.html#ga62b1a9ac304ba1eb4f87ab8cc18dd281">More...</a><br /></td></tr>
<tr class="separator:ga62b1a9ac304ba1eb4f87ab8cc18dd281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">parallel_for_each</div></td></tr>
<tr class="memitem:gac9225af45fd0468843b3fc32608c71de"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Function &gt; </td></tr>
<tr class="memitem:gac9225af45fd0468843b3fc32608c71de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gac9225af45fd0468843b3fc32608c71de">parallel_for_each</a> (Iterator first, Iterator last, const Function &amp;f, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:gac9225af45fd0468843b3fc32608c71de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls function f for all items from [first, last) interval using user-supplied context.  <a href="a01145.html#gac9225af45fd0468843b3fc32608c71de">More...</a><br /></td></tr>
<tr class="separator:gac9225af45fd0468843b3fc32608c71de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72131543fd218b67dbb048b768d534e4"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Function &gt; </td></tr>
<tr class="memitem:ga72131543fd218b67dbb048b768d534e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga72131543fd218b67dbb048b768d534e4">parallel_for_each</a> (Range &amp;rng, const Function &amp;f, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga72131543fd218b67dbb048b768d534e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls function f for all items from rng using user-supplied context.  <a href="a01145.html#ga72131543fd218b67dbb048b768d534e4">More...</a><br /></td></tr>
<tr class="separator:ga72131543fd218b67dbb048b768d534e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7d0702d16fbd7554584ab735eed39ba"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Function &gt; </td></tr>
<tr class="memitem:gad7d0702d16fbd7554584ab735eed39ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gad7d0702d16fbd7554584ab735eed39ba">parallel_for_each</a> (const Range &amp;rng, const Function &amp;f, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:gad7d0702d16fbd7554584ab735eed39ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls function f for all items from const rng user-supplied context.  <a href="a01145.html#gad7d0702d16fbd7554584ab735eed39ba">More...</a><br /></td></tr>
<tr class="separator:gad7d0702d16fbd7554584ab735eed39ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c63dee10188196a2f0514afa81ff1f"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename Function &gt; </td></tr>
<tr class="memitem:ga21c63dee10188196a2f0514afa81ff1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga21c63dee10188196a2f0514afa81ff1f">parallel_for_each</a> (Iterator first, Iterator last, const Function &amp;f)</td></tr>
<tr class="memdesc:ga21c63dee10188196a2f0514afa81ff1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses default context.  <a href="a01145.html#ga21c63dee10188196a2f0514afa81ff1f">More...</a><br /></td></tr>
<tr class="separator:ga21c63dee10188196a2f0514afa81ff1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5868cd01f2126b139ab5809f64632db1"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Function &gt; </td></tr>
<tr class="memitem:ga5868cd01f2126b139ab5809f64632db1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga5868cd01f2126b139ab5809f64632db1">parallel_for_each</a> (Range &amp;rng, const Function &amp;f)</td></tr>
<tr class="memdesc:ga5868cd01f2126b139ab5809f64632db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses default context.  <a href="a01145.html#ga5868cd01f2126b139ab5809f64632db1">More...</a><br /></td></tr>
<tr class="separator:ga5868cd01f2126b139ab5809f64632db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33463c8b0d0104cf9d9e0f9cb3c0b26b"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Function &gt; </td></tr>
<tr class="memitem:ga33463c8b0d0104cf9d9e0f9cb3c0b26b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga33463c8b0d0104cf9d9e0f9cb3c0b26b">parallel_for_each</a> (const Range &amp;rng, const Function &amp;f)</td></tr>
<tr class="memdesc:ga33463c8b0d0104cf9d9e0f9cb3c0b26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses default context.  <a href="a01145.html#ga33463c8b0d0104cf9d9e0f9cb3c0b26b">More...</a><br /></td></tr>
<tr class="separator:ga33463c8b0d0104cf9d9e0f9cb3c0b26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">parallel_invoke</div></td></tr>
<tr class="memitem:ga14459dcbcd631194df803b155a7f610b"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 &gt; </td></tr>
<tr class="memitem:ga14459dcbcd631194df803b155a7f610b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga14459dcbcd631194df803b155a7f610b">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, <a class="el" href="a00784.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga14459dcbcd631194df803b155a7f610b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a list of tasks in parallel and waits for all tasks to complete.  <a href="a01145.html#ga14459dcbcd631194df803b155a7f610b">More...</a><br /></td></tr>
<tr class="separator:ga14459dcbcd631194df803b155a7f610b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea3f3a8883128afb596a963e856277f"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 , typename F2 &gt; </td></tr>
<tr class="memitem:gaaea3f3a8883128afb596a963e856277f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gaaea3f3a8883128afb596a963e856277f">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, <a class="el" href="a00784.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr class="separator:gaaea3f3a8883128afb596a963e856277f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74932e64ede5047387108fa45f1af96f"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr class="memitem:ga74932e64ede5047387108fa45f1af96f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga74932e64ede5047387108fa45f1af96f">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, <a class="el" href="a00784.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr class="separator:ga74932e64ede5047387108fa45f1af96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefc1ba8f73cbdd094575f6db454fc6b5"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 &gt; </td></tr>
<tr class="memitem:gaefc1ba8f73cbdd094575f6db454fc6b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gaefc1ba8f73cbdd094575f6db454fc6b5">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, <a class="el" href="a00784.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr class="separator:gaefc1ba8f73cbdd094575f6db454fc6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f02dfbb94238b2cf2ef8f20844b03af"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 &gt; </td></tr>
<tr class="memitem:ga3f02dfbb94238b2cf2ef8f20844b03af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga3f02dfbb94238b2cf2ef8f20844b03af">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, <a class="el" href="a00784.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr class="separator:ga3f02dfbb94238b2cf2ef8f20844b03af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8c1220bbd59e3b8e7bbcdcfdda8047e"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 , typename F6 &gt; </td></tr>
<tr class="memitem:gad8c1220bbd59e3b8e7bbcdcfdda8047e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gad8c1220bbd59e3b8e7bbcdcfdda8047e">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, <a class="el" href="a00784.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr class="separator:gad8c1220bbd59e3b8e7bbcdcfdda8047e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ee83a66397ee0b15c77756cb5e5168e"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 , typename F6 , typename F7 &gt; </td></tr>
<tr class="memitem:ga5ee83a66397ee0b15c77756cb5e5168e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga5ee83a66397ee0b15c77756cb5e5168e">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, <a class="el" href="a00784.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr class="separator:ga5ee83a66397ee0b15c77756cb5e5168e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1af92ebd06f6cdf5ee668b1fe62657bd"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 , typename F6 , typename F7 , typename F8 &gt; </td></tr>
<tr class="memitem:ga1af92ebd06f6cdf5ee668b1fe62657bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga1af92ebd06f6cdf5ee668b1fe62657bd">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, <a class="el" href="a00784.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr class="separator:ga1af92ebd06f6cdf5ee668b1fe62657bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65846bc3b2f63ed1448b6cdfea9e1c80"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 , typename F6 , typename F7 , typename F8 , typename F9 &gt; </td></tr>
<tr class="memitem:ga65846bc3b2f63ed1448b6cdfea9e1c80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga65846bc3b2f63ed1448b6cdfea9e1c80">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, const F9 &amp;f9, <a class="el" href="a00784.html">tbb::task_group_context</a> &amp;context)</td></tr>
<tr class="separator:ga65846bc3b2f63ed1448b6cdfea9e1c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b1c36ece1d3950677dd01ef0863648c"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 &gt; </td></tr>
<tr class="memitem:ga6b1c36ece1d3950677dd01ef0863648c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga6b1c36ece1d3950677dd01ef0863648c">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1)</td></tr>
<tr class="separator:ga6b1c36ece1d3950677dd01ef0863648c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa979656a4c207782b74800c6c42982f5"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 , typename F2 &gt; </td></tr>
<tr class="memitem:gaa979656a4c207782b74800c6c42982f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gaa979656a4c207782b74800c6c42982f5">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2)</td></tr>
<tr class="separator:gaa979656a4c207782b74800c6c42982f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga219cb8061b7cf5454c0bc4d67cff1e34"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 , typename F2 , typename F3 &gt; </td></tr>
<tr class="memitem:ga219cb8061b7cf5454c0bc4d67cff1e34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga219cb8061b7cf5454c0bc4d67cff1e34">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3)</td></tr>
<tr class="separator:ga219cb8061b7cf5454c0bc4d67cff1e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8319ee980cd7cfb03f12ffc2a5ea4895"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 &gt; </td></tr>
<tr class="memitem:ga8319ee980cd7cfb03f12ffc2a5ea4895"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga8319ee980cd7cfb03f12ffc2a5ea4895">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4)</td></tr>
<tr class="separator:ga8319ee980cd7cfb03f12ffc2a5ea4895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga295daf6f7394fba29a979b914be09fc6"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 &gt; </td></tr>
<tr class="memitem:ga295daf6f7394fba29a979b914be09fc6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga295daf6f7394fba29a979b914be09fc6">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5)</td></tr>
<tr class="separator:ga295daf6f7394fba29a979b914be09fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7652a01622a2f28df1e0edf40b691190"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 , typename F6 &gt; </td></tr>
<tr class="memitem:ga7652a01622a2f28df1e0edf40b691190"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga7652a01622a2f28df1e0edf40b691190">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6)</td></tr>
<tr class="separator:ga7652a01622a2f28df1e0edf40b691190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd8826371866c58e41dee3546c35d2c8"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 , typename F6 , typename F7 &gt; </td></tr>
<tr class="memitem:gadd8826371866c58e41dee3546c35d2c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gadd8826371866c58e41dee3546c35d2c8">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7)</td></tr>
<tr class="separator:gadd8826371866c58e41dee3546c35d2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeca8b72507d67dd023dae728bdc89896"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 , typename F6 , typename F7 , typename F8 &gt; </td></tr>
<tr class="memitem:gaeca8b72507d67dd023dae728bdc89896"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gaeca8b72507d67dd023dae728bdc89896">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8)</td></tr>
<tr class="separator:gaeca8b72507d67dd023dae728bdc89896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17c9f95fac24b2b7b62f325f511ee7be"><td class="memTemplParams" colspan="2">template&lt;typename F0 , typename F1 , typename F2 , typename F3 , typename F4 , typename F5 , typename F6 , typename F7 , typename F8 , typename F9 &gt; </td></tr>
<tr class="memitem:ga17c9f95fac24b2b7b62f325f511ee7be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga17c9f95fac24b2b7b62f325f511ee7be">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, const F9 &amp;f9)</td></tr>
<tr class="separator:ga17c9f95fac24b2b7b62f325f511ee7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">parallel_reduce</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>See also requirements on <a class="el" href="a00002.html">Range</a> and <a class="el" href="a00005.html">parallel_reduce Body</a>. </p>
</div></td></tr>
<tr class="memitem:ga7b1ce9568e0a0efe1bd2d55677bc6687"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga7b1ce9568e0a0efe1bd2d55677bc6687"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga7b1ce9568e0a0efe1bd2d55677bc6687">parallel_reduce</a> (const Range &amp;range, Body &amp;body)</td></tr>
<tr class="memdesc:ga7b1ce9568e0a0efe1bd2d55677bc6687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction and default partitioner.  <a href="a01145.html#ga7b1ce9568e0a0efe1bd2d55677bc6687">More...</a><br /></td></tr>
<tr class="separator:ga7b1ce9568e0a0efe1bd2d55677bc6687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb92b593827f9c3f5e1f8ee2f7d5f82"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:gaebb92b593827f9c3f5e1f8ee2f7d5f82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gaebb92b593827f9c3f5e1f8ee2f7d5f82">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00708.html">simple_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:gaebb92b593827f9c3f5e1f8ee2f7d5f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00708.html" title="A simple partitioner. ">simple_partitioner</a>.  <a href="a01145.html#gaebb92b593827f9c3f5e1f8ee2f7d5f82">More...</a><br /></td></tr>
<tr class="separator:gaebb92b593827f9c3f5e1f8ee2f7d5f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3011e7266fb1e43d307060fe75be2c6e"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga3011e7266fb1e43d307060fe75be2c6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga3011e7266fb1e43d307060fe75be2c6e">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00100.html">auto_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:ga3011e7266fb1e43d307060fe75be2c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00100.html" title="An auto partitioner. ">auto_partitioner</a>.  <a href="a01145.html#ga3011e7266fb1e43d307060fe75be2c6e">More...</a><br /></td></tr>
<tr class="separator:ga3011e7266fb1e43d307060fe75be2c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf15a4b0e2174dce3a12b70a89bbcdc63"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:gaf15a4b0e2174dce3a12b70a89bbcdc63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gaf15a4b0e2174dce3a12b70a89bbcdc63">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00736.html">static_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:gaf15a4b0e2174dce3a12b70a89bbcdc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00736.html" title="A static partitioner. ">static_partitioner</a>.  <a href="a01145.html#gaf15a4b0e2174dce3a12b70a89bbcdc63">More...</a><br /></td></tr>
<tr class="separator:gaf15a4b0e2174dce3a12b70a89bbcdc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e83e121490df24fa5893b14e68f5e2a"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga6e83e121490df24fa5893b14e68f5e2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga6e83e121490df24fa5893b14e68f5e2a">parallel_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00030.html">affinity_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:ga6e83e121490df24fa5893b14e68f5e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00030.html" title="An affinity partitioner. ">affinity_partitioner</a>.  <a href="a01145.html#ga6e83e121490df24fa5893b14e68f5e2a">More...</a><br /></td></tr>
<tr class="separator:ga6e83e121490df24fa5893b14e68f5e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf01a863a473dc1659bbad906dfa9f5ef"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:gaf01a863a473dc1659bbad906dfa9f5ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gaf01a863a473dc1659bbad906dfa9f5ef">parallel_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:gaf01a863a473dc1659bbad906dfa9f5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction, default partitioner and user-supplied context.  <a href="a01145.html#gaf01a863a473dc1659bbad906dfa9f5ef">More...</a><br /></td></tr>
<tr class="separator:gaf01a863a473dc1659bbad906dfa9f5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac57281bea03450ccb2d098ee8c7ab697"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:gac57281bea03450ccb2d098ee8c7ab697"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gac57281bea03450ccb2d098ee8c7ab697">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00708.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:gac57281bea03450ccb2d098ee8c7ab697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction, simple partitioner and user-supplied context.  <a href="a01145.html#gac57281bea03450ccb2d098ee8c7ab697">More...</a><br /></td></tr>
<tr class="separator:gac57281bea03450ccb2d098ee8c7ab697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f3ebf50ab7f5e53fd936817c866f7be"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga5f3ebf50ab7f5e53fd936817c866f7be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga5f3ebf50ab7f5e53fd936817c866f7be">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00100.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga5f3ebf50ab7f5e53fd936817c866f7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00100.html" title="An auto partitioner. ">auto_partitioner</a> and user-supplied context.  <a href="a01145.html#ga5f3ebf50ab7f5e53fd936817c866f7be">More...</a><br /></td></tr>
<tr class="separator:ga5f3ebf50ab7f5e53fd936817c866f7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf049e6d185c38c2d9e153b0edd3a9015"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:gaf049e6d185c38c2d9e153b0edd3a9015"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gaf049e6d185c38c2d9e153b0edd3a9015">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00736.html">static_partitioner</a> &amp;partitioner, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:gaf049e6d185c38c2d9e153b0edd3a9015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00736.html" title="A static partitioner. ">static_partitioner</a> and user-supplied context.  <a href="a01145.html#gaf049e6d185c38c2d9e153b0edd3a9015">More...</a><br /></td></tr>
<tr class="separator:gaf049e6d185c38c2d9e153b0edd3a9015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5df3f3a9618fd35931107819cb43fce6"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga5df3f3a9618fd35931107819cb43fce6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga5df3f3a9618fd35931107819cb43fce6">parallel_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00030.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga5df3f3a9618fd35931107819cb43fce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00030.html" title="An affinity partitioner. ">affinity_partitioner</a> and user-supplied context.  <a href="a01145.html#ga5df3f3a9618fd35931107819cb43fce6">More...</a><br /></td></tr>
<tr class="separator:ga5df3f3a9618fd35931107819cb43fce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c9b66fa25cadee9ca3bff75a6609b05"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr class="memitem:ga1c9b66fa25cadee9ca3bff75a6609b05"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga1c9b66fa25cadee9ca3bff75a6609b05">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction)</td></tr>
<tr class="memdesc:ga1c9b66fa25cadee9ca3bff75a6609b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction and default partitioner.  <a href="a01145.html#ga1c9b66fa25cadee9ca3bff75a6609b05">More...</a><br /></td></tr>
<tr class="separator:ga1c9b66fa25cadee9ca3bff75a6609b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b22fd1de0e8bbaf46587d3c63a1ed93"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr class="memitem:ga0b22fd1de0e8bbaf46587d3c63a1ed93"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga0b22fd1de0e8bbaf46587d3c63a1ed93">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00708.html">simple_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:ga0b22fd1de0e8bbaf46587d3c63a1ed93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00708.html" title="A simple partitioner. ">simple_partitioner</a>.  <a href="a01145.html#ga0b22fd1de0e8bbaf46587d3c63a1ed93">More...</a><br /></td></tr>
<tr class="separator:ga0b22fd1de0e8bbaf46587d3c63a1ed93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56e6b6e2eee521f532c00d855280be69"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr class="memitem:ga56e6b6e2eee521f532c00d855280be69"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga56e6b6e2eee521f532c00d855280be69">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00100.html">auto_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:ga56e6b6e2eee521f532c00d855280be69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00100.html" title="An auto partitioner. ">auto_partitioner</a>.  <a href="a01145.html#ga56e6b6e2eee521f532c00d855280be69">More...</a><br /></td></tr>
<tr class="separator:ga56e6b6e2eee521f532c00d855280be69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d4eb5ab127b185a92720eff1136fa8"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr class="memitem:gac0d4eb5ab127b185a92720eff1136fa8"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gac0d4eb5ab127b185a92720eff1136fa8">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00736.html">static_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:gac0d4eb5ab127b185a92720eff1136fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00736.html" title="A static partitioner. ">static_partitioner</a>.  <a href="a01145.html#gac0d4eb5ab127b185a92720eff1136fa8">More...</a><br /></td></tr>
<tr class="separator:gac0d4eb5ab127b185a92720eff1136fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac26c35d1983e7ac2ab003cc8e49dd7e6"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr class="memitem:gac26c35d1983e7ac2ab003cc8e49dd7e6"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gac26c35d1983e7ac2ab003cc8e49dd7e6">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, <a class="el" href="a00030.html">affinity_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:gac26c35d1983e7ac2ab003cc8e49dd7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00030.html" title="An affinity partitioner. ">affinity_partitioner</a>.  <a href="a01145.html#gac26c35d1983e7ac2ab003cc8e49dd7e6">More...</a><br /></td></tr>
<tr class="separator:gac26c35d1983e7ac2ab003cc8e49dd7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafffb48072a6dcf69bd278a57061570c4"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr class="memitem:gafffb48072a6dcf69bd278a57061570c4"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gafffb48072a6dcf69bd278a57061570c4">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:gafffb48072a6dcf69bd278a57061570c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction, default partitioner and user-supplied context.  <a href="a01145.html#gafffb48072a6dcf69bd278a57061570c4">More...</a><br /></td></tr>
<tr class="separator:gafffb48072a6dcf69bd278a57061570c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga518ef2653004d60319bdfc1c6bce86b6"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr class="memitem:ga518ef2653004d60319bdfc1c6bce86b6"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga518ef2653004d60319bdfc1c6bce86b6">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00708.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga518ef2653004d60319bdfc1c6bce86b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction, simple partitioner and user-supplied context.  <a href="a01145.html#ga518ef2653004d60319bdfc1c6bce86b6">More...</a><br /></td></tr>
<tr class="separator:ga518ef2653004d60319bdfc1c6bce86b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24ba50caf5a7c32cbd38912508cb69a4"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr class="memitem:ga24ba50caf5a7c32cbd38912508cb69a4"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga24ba50caf5a7c32cbd38912508cb69a4">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00100.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga24ba50caf5a7c32cbd38912508cb69a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00100.html" title="An auto partitioner. ">auto_partitioner</a> and user-supplied context.  <a href="a01145.html#ga24ba50caf5a7c32cbd38912508cb69a4">More...</a><br /></td></tr>
<tr class="separator:ga24ba50caf5a7c32cbd38912508cb69a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1507205a91a8fd26bd7d9bbcb74ad98b"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr class="memitem:ga1507205a91a8fd26bd7d9bbcb74ad98b"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga1507205a91a8fd26bd7d9bbcb74ad98b">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00736.html">static_partitioner</a> &amp;partitioner, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga1507205a91a8fd26bd7d9bbcb74ad98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00736.html" title="A static partitioner. ">static_partitioner</a> and user-supplied context.  <a href="a01145.html#ga1507205a91a8fd26bd7d9bbcb74ad98b">More...</a><br /></td></tr>
<tr class="separator:ga1507205a91a8fd26bd7d9bbcb74ad98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga367a8e77c4dac3f8764785afdc6c9299"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr class="memitem:ga367a8e77c4dac3f8764785afdc6c9299"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga367a8e77c4dac3f8764785afdc6c9299">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, <a class="el" href="a00030.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga367a8e77c4dac3f8764785afdc6c9299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00030.html" title="An affinity partitioner. ">affinity_partitioner</a> and user-supplied context.  <a href="a01145.html#ga367a8e77c4dac3f8764785afdc6c9299">More...</a><br /></td></tr>
<tr class="separator:ga367a8e77c4dac3f8764785afdc6c9299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fd7e3c43592dfe1ae3e3572bd80d4f6"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga1fd7e3c43592dfe1ae3e3572bd80d4f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga1fd7e3c43592dfe1ae3e3572bd80d4f6">parallel_deterministic_reduce</a> (const Range &amp;range, Body &amp;body)</td></tr>
<tr class="memdesc:ga1fd7e3c43592dfe1ae3e3572bd80d4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with deterministic reduction and default simple partitioner.  <a href="a01145.html#ga1fd7e3c43592dfe1ae3e3572bd80d4f6">More...</a><br /></td></tr>
<tr class="separator:ga1fd7e3c43592dfe1ae3e3572bd80d4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa872944de4b5f753f74b874707bce379"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:gaa872944de4b5f753f74b874707bce379"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gaa872944de4b5f753f74b874707bce379">parallel_deterministic_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00708.html">simple_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:gaa872944de4b5f753f74b874707bce379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with deterministic reduction and simple partitioner.  <a href="a01145.html#gaa872944de4b5f753f74b874707bce379">More...</a><br /></td></tr>
<tr class="separator:gaa872944de4b5f753f74b874707bce379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1907e38efdefdce193ff289e18e86a"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga1b1907e38efdefdce193ff289e18e86a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga1b1907e38efdefdce193ff289e18e86a">parallel_deterministic_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00736.html">static_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:ga1b1907e38efdefdce193ff289e18e86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with deterministic reduction and static partitioner.  <a href="a01145.html#ga1b1907e38efdefdce193ff289e18e86a">More...</a><br /></td></tr>
<tr class="separator:ga1b1907e38efdefdce193ff289e18e86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga361201f81b4ec7b86f81b579d2db647a"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga361201f81b4ec7b86f81b579d2db647a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga361201f81b4ec7b86f81b579d2db647a">parallel_deterministic_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga361201f81b4ec7b86f81b579d2db647a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with deterministic reduction, default simple partitioner and user-supplied context.  <a href="a01145.html#ga361201f81b4ec7b86f81b579d2db647a">More...</a><br /></td></tr>
<tr class="separator:ga361201f81b4ec7b86f81b579d2db647a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc5031d9c9fbab8160639f6ca1505cff"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:gadc5031d9c9fbab8160639f6ca1505cff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gadc5031d9c9fbab8160639f6ca1505cff">parallel_deterministic_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00708.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:gadc5031d9c9fbab8160639f6ca1505cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with deterministic reduction, simple partitioner and user-supplied context.  <a href="a01145.html#gadc5031d9c9fbab8160639f6ca1505cff">More...</a><br /></td></tr>
<tr class="separator:gadc5031d9c9fbab8160639f6ca1505cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8710b9baa5067e2391fca1026a5a2c03"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga8710b9baa5067e2391fca1026a5a2c03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga8710b9baa5067e2391fca1026a5a2c03">parallel_deterministic_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00736.html">static_partitioner</a> &amp;partitioner, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga8710b9baa5067e2391fca1026a5a2c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with deterministic reduction, static partitioner and user-supplied context.  <a href="a01145.html#ga8710b9baa5067e2391fca1026a5a2c03">More...</a><br /></td></tr>
<tr class="separator:ga8710b9baa5067e2391fca1026a5a2c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f69e6a632acb51ed26a43ebd331f349"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr class="memitem:ga7f69e6a632acb51ed26a43ebd331f349"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga7f69e6a632acb51ed26a43ebd331f349">parallel_deterministic_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction)</td></tr>
<tr class="memdesc:ga7f69e6a632acb51ed26a43ebd331f349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with deterministic reduction and default simple partitioner.  <a href="a01145.html#ga7f69e6a632acb51ed26a43ebd331f349">More...</a><br /></td></tr>
<tr class="separator:ga7f69e6a632acb51ed26a43ebd331f349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9f444ac5712fe11053e9ce6b147640a"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr class="memitem:gad9f444ac5712fe11053e9ce6b147640a"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gad9f444ac5712fe11053e9ce6b147640a">parallel_deterministic_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00708.html">simple_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:gad9f444ac5712fe11053e9ce6b147640a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with deterministic reduction and simple partitioner.  <a href="a01145.html#gad9f444ac5712fe11053e9ce6b147640a">More...</a><br /></td></tr>
<tr class="separator:gad9f444ac5712fe11053e9ce6b147640a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1c05004d0970bd199518f568779429a"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr class="memitem:gaf1c05004d0970bd199518f568779429a"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gaf1c05004d0970bd199518f568779429a">parallel_deterministic_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00736.html">static_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:gaf1c05004d0970bd199518f568779429a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with deterministic reduction and static partitioner.  <a href="a01145.html#gaf1c05004d0970bd199518f568779429a">More...</a><br /></td></tr>
<tr class="separator:gaf1c05004d0970bd199518f568779429a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b4eea059a62cbbf409cbad02b70bfa"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr class="memitem:ga69b4eea059a62cbbf409cbad02b70bfa"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga69b4eea059a62cbbf409cbad02b70bfa">parallel_deterministic_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga69b4eea059a62cbbf409cbad02b70bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with deterministic reduction, default simple partitioner and user-supplied context.  <a href="a01145.html#ga69b4eea059a62cbbf409cbad02b70bfa">More...</a><br /></td></tr>
<tr class="separator:ga69b4eea059a62cbbf409cbad02b70bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24758356e0e29013807ab12127d06f7d"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr class="memitem:ga24758356e0e29013807ab12127d06f7d"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga24758356e0e29013807ab12127d06f7d">parallel_deterministic_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00708.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:ga24758356e0e29013807ab12127d06f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with deterministic reduction, simple partitioner and user-supplied context.  <a href="a01145.html#ga24758356e0e29013807ab12127d06f7d">More...</a><br /></td></tr>
<tr class="separator:ga24758356e0e29013807ab12127d06f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3c66b6e36066e270e4d27ad41e33697"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename RealBody , typename Reduction &gt; </td></tr>
<tr class="memitem:gac3c66b6e36066e270e4d27ad41e33697"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gac3c66b6e36066e270e4d27ad41e33697">parallel_deterministic_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00736.html">static_partitioner</a> &amp;partitioner, <a class="el" href="a00784.html">task_group_context</a> &amp;context)</td></tr>
<tr class="memdesc:gac3c66b6e36066e270e4d27ad41e33697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel iteration with deterministic reduction, static partitioner and user-supplied context.  <a href="a01145.html#gac3c66b6e36066e270e4d27ad41e33697">More...</a><br /></td></tr>
<tr class="separator:gac3c66b6e36066e270e4d27ad41e33697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">parallel_scan</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>See also requirements on <a class="el" href="a00002.html">Range</a> and <a class="el" href="a00007.html">parallel_scan Body</a>. </p>
</div></td></tr>
<tr class="memitem:gae7eaaf124471a6c603b28fc925e8fbbb"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:gae7eaaf124471a6c603b28fc925e8fbbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gae7eaaf124471a6c603b28fc925e8fbbb">parallel_scan</a> (const Range &amp;range, Body &amp;body)</td></tr>
<tr class="memdesc:gae7eaaf124471a6c603b28fc925e8fbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel prefix with default partitioner.  <a href="a01145.html#gae7eaaf124471a6c603b28fc925e8fbbb">More...</a><br /></td></tr>
<tr class="separator:gae7eaaf124471a6c603b28fc925e8fbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ddacf5e49f1bea9b67803f2d0f57531"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga7ddacf5e49f1bea9b67803f2d0f57531"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga7ddacf5e49f1bea9b67803f2d0f57531">parallel_scan</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00708.html">simple_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:ga7ddacf5e49f1bea9b67803f2d0f57531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00708.html" title="A simple partitioner. ">simple_partitioner</a>.  <a href="a01145.html#ga7ddacf5e49f1bea9b67803f2d0f57531">More...</a><br /></td></tr>
<tr class="separator:ga7ddacf5e49f1bea9b67803f2d0f57531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3548041731b7fa14f30f155541ceebb9"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Body &gt; </td></tr>
<tr class="memitem:ga3548041731b7fa14f30f155541ceebb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga3548041731b7fa14f30f155541ceebb9">parallel_scan</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00100.html">auto_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:ga3548041731b7fa14f30f155541ceebb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00100.html" title="An auto partitioner. ">auto_partitioner</a>.  <a href="a01145.html#ga3548041731b7fa14f30f155541ceebb9">More...</a><br /></td></tr>
<tr class="separator:ga3548041731b7fa14f30f155541ceebb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dd68a232bb3102788792fcf081a2ab6"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename Scan , typename ReverseJoin &gt; </td></tr>
<tr class="memitem:ga7dd68a232bb3102788792fcf081a2ab6"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga7dd68a232bb3102788792fcf081a2ab6">parallel_scan</a> (const Range &amp;range, const Value &amp;identity, const Scan &amp;scan, const ReverseJoin &amp;reverse_join)</td></tr>
<tr class="memdesc:ga7dd68a232bb3102788792fcf081a2ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel prefix with default partitioner.  <a href="a01145.html#ga7dd68a232bb3102788792fcf081a2ab6">More...</a><br /></td></tr>
<tr class="separator:ga7dd68a232bb3102788792fcf081a2ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbc46558909fe3720e95a18241dda603"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename Scan , typename ReverseJoin &gt; </td></tr>
<tr class="memitem:gadbc46558909fe3720e95a18241dda603"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gadbc46558909fe3720e95a18241dda603">parallel_scan</a> (const Range &amp;range, const Value &amp;identity, const Scan &amp;scan, const ReverseJoin &amp;reverse_join, const <a class="el" href="a00708.html">simple_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:gadbc46558909fe3720e95a18241dda603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00708.html" title="A simple partitioner. ">simple_partitioner</a>.  <a href="a01145.html#gadbc46558909fe3720e95a18241dda603">More...</a><br /></td></tr>
<tr class="separator:gadbc46558909fe3720e95a18241dda603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dda983975483bbc5dc95558c1ad3d88"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Value , typename Scan , typename ReverseJoin &gt; </td></tr>
<tr class="memitem:ga6dda983975483bbc5dc95558c1ad3d88"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga6dda983975483bbc5dc95558c1ad3d88">parallel_scan</a> (const Range &amp;range, const Value &amp;identity, const Scan &amp;scan, const ReverseJoin &amp;reverse_join, const <a class="el" href="a00100.html">auto_partitioner</a> &amp;partitioner)</td></tr>
<tr class="memdesc:ga6dda983975483bbc5dc95558c1ad3d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00100.html" title="An auto partitioner. ">auto_partitioner</a>.  <a href="a01145.html#ga6dda983975483bbc5dc95558c1ad3d88">More...</a><br /></td></tr>
<tr class="separator:ga6dda983975483bbc5dc95558c1ad3d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">parallel_sort</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>See also requirements on <a class="el" href="a00008.html">iterators for parallel_sort</a>. </p>
</div></td></tr>
<tr class="memitem:gabdc90813499f91d3e32298cd6dc2fe45"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename Compare &gt; </td></tr>
<tr class="memitem:gabdc90813499f91d3e32298cd6dc2fe45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gabdc90813499f91d3e32298cd6dc2fe45">parallel_sort</a> (RandomAccessIterator <a class="el" href="a01016.html#a50deeaccd8b2b4be185e1befc7860258">begin</a>, RandomAccessIterator <a class="el" href="a01016.html#a30bf4ccd4623b7a8276bbc7f99e491c7">end</a>, const Compare &amp;comp)</td></tr>
<tr class="memdesc:gabdc90813499f91d3e32298cd6dc2fe45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the data in [begin,end) using the given comparator.  <a href="a01145.html#gabdc90813499f91d3e32298cd6dc2fe45">More...</a><br /></td></tr>
<tr class="separator:gabdc90813499f91d3e32298cd6dc2fe45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73b58ac9249f49587d0b081c152af551"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:ga73b58ac9249f49587d0b081c152af551"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga73b58ac9249f49587d0b081c152af551">parallel_sort</a> (RandomAccessIterator <a class="el" href="a01016.html#a50deeaccd8b2b4be185e1befc7860258">begin</a>, RandomAccessIterator <a class="el" href="a01016.html#a30bf4ccd4623b7a8276bbc7f99e491c7">end</a>)</td></tr>
<tr class="memdesc:ga73b58ac9249f49587d0b081c152af551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the data in [begin,end) with a default comparator <code>std::less&lt;RandomAccessIterator&gt;</code>  <a href="a01145.html#ga73b58ac9249f49587d0b081c152af551">More...</a><br /></td></tr>
<tr class="separator:ga73b58ac9249f49587d0b081c152af551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ce8ba64868c5c15f9d98840193b9bf"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Compare &gt; </td></tr>
<tr class="memitem:ga61ce8ba64868c5c15f9d98840193b9bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga61ce8ba64868c5c15f9d98840193b9bf">parallel_sort</a> (Range &amp;rng, const Compare &amp;comp)</td></tr>
<tr class="memdesc:ga61ce8ba64868c5c15f9d98840193b9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the data in rng using the given comparator.  <a href="a01145.html#ga61ce8ba64868c5c15f9d98840193b9bf">More...</a><br /></td></tr>
<tr class="separator:ga61ce8ba64868c5c15f9d98840193b9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1fb3ae3aab1213cb9bcf56e30c164bb"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gaf1fb3ae3aab1213cb9bcf56e30c164bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#gaf1fb3ae3aab1213cb9bcf56e30c164bb">parallel_sort</a> (Range &amp;rng)</td></tr>
<tr class="memdesc:gaf1fb3ae3aab1213cb9bcf56e30c164bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the data in rng with a default comparator <code>std::less&lt;RandomAccessIterator&gt;</code>  <a href="a01145.html#gaf1fb3ae3aab1213cb9bcf56e30c164bb">More...</a><br /></td></tr>
<tr class="separator:gaf1fb3ae3aab1213cb9bcf56e30c164bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f176cdc232a6e5907456656a24983a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8f176cdc232a6e5907456656a24983a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01145.html#ga8f176cdc232a6e5907456656a24983a8">parallel_sort</a> (T *<a class="el" href="a01016.html#a50deeaccd8b2b4be185e1befc7860258">begin</a>, T *<a class="el" href="a01016.html#a30bf4ccd4623b7a8276bbc7f99e491c7">end</a>)</td></tr>
<tr class="memdesc:ga8f176cdc232a6e5907456656a24983a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the data in the range <code></code>[begin,end) with a default comparator <code>std::less&lt;T&gt;</code>  <a href="a01145.html#ga8f176cdc232a6e5907456656a24983a8">More...</a><br /></td></tr>
<tr class="separator:ga8f176cdc232a6e5907456656a24983a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afa4b635d11688d1a0c6c74272b30c382"><td class="memItemLeft" align="right" valign="top">const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#afa4b635d11688d1a0c6c74272b30c382">RELEASED</a> = 0</td></tr>
<tr class="separator:afa4b635d11688d1a0c6c74272b30c382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d7a75a045cac9054ae7614eeb0545b"><td class="memItemLeft" align="right" valign="top">const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#a23d7a75a045cac9054ae7614eeb0545b">ACQUIRED</a> = 1</td></tr>
<tr class="separator:a23d7a75a045cac9054ae7614eeb0545b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c32c9988b9e2a358c5eae7dd0e1f67"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="a00834.html#a895d00be1f535b43102d037b4e0197d6">tricky_pointer::word</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#a61c32c9988b9e2a358c5eae7dd0e1f67">FLAG</a> = 0x1</td></tr>
<tr class="memdesc:a61c32c9988b9e2a358c5eae7dd0e1f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for low order bit of a pointer.  <a href="#a61c32c9988b9e2a358c5eae7dd0e1f67">More...</a><br /></td></tr>
<tr class="separator:a61c32c9988b9e2a358c5eae7dd0e1f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ee10785517963c93564636c8854272"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a01113.html#acce76b9d59c776788ddbd1588a18af42">assertion_handler_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01113.html#ae4ee10785517963c93564636c8854272">assertion_handler</a></td></tr>
<tr class="separator:ae4ee10785517963c93564636c8854272"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The graph class. </p>
<p>The namespace tbb contains all components of the library.</p>
<p>This header provides basic platform abstraction layer by hooking up appropriate architecture/OS/compiler specific headers from the /include/tbb/machine directory. If a plug-in header does not implement all the required APIs, it must specify the missing ones by setting one or more of the following macros:</p>
<p>__TBB_USE_GENERIC_PART_WORD_CAS __TBB_USE_GENERIC_PART_WORD_FETCH_ADD __TBB_USE_GENERIC_PART_WORD_FETCH_STORE __TBB_USE_GENERIC_FETCH_ADD __TBB_USE_GENERIC_FETCH_STORE __TBB_USE_GENERIC_DWORD_FETCH_ADD __TBB_USE_GENERIC_DWORD_FETCH_STORE __TBB_USE_GENERIC_HALF_FENCED_LOAD_STORE __TBB_USE_GENERIC_SEQUENTIAL_CONSISTENCY_LOAD_STORE __TBB_USE_GENERIC_RELAXED_LOAD_STORE __TBB_USE_FETCHSTORE_AS_FULL_FENCED_STORE</p>
<p>In this case tbb_machine.h will add missing functionality based on a minimal set of APIs that are required to be implemented by all plug-n headers as described further. Note that these generic implementations may be sub-optimal for a particular architecture, and thus should be relied upon only after careful evaluation or as the last resort.</p>
<p>Additionally __TBB_64BIT_ATOMICS can be set to 0 on a 32-bit architecture to indicate that the port is not going to support double word atomics. It may also be set to 1 explicitly, though normally this is not necessary as tbb_machine.h will set it automatically.</p>
<p>__TBB_ENDIANNESS macro can be defined by the implementation as well. It is used only if __TBB_USE_GENERIC_PART_WORD_CAS is set (or for testing), and must specify the layout of aligned 16-bit and 32-bit data anywhere within a process (while the details of unaligned 16-bit or 32-bit data or of 64-bit data are irrelevant). The layout must be the same at all relevant memory locations within the current process; in case of page-specific endianness, one endianness must be kept "out of sight". Possible settings, reflecting hardware and possibly O.S. convention, are:</p><ul>
<li>__TBB_ENDIAN_BIG for big-endian data,</li>
<li>__TBB_ENDIAN_LITTLE for little-endian data,</li>
<li>__TBB_ENDIAN_DETECT for run-time detection iff exactly one of the above,</li>
<li>__TBB_ENDIAN_UNSUPPORTED to prevent undefined behavior if none of the above.</li>
</ul>
<h2>Prerequisites for each architecture port </h2>
<p>The following functions and macros have no generic implementation. Therefore they must be implemented in each machine architecture specific header either as a conventional function or as a functional macro.</p>
<p>__TBB_WORDSIZE This is the size of machine word in bytes, i.e. for 32 bit systems it should be defined to 4.</p>
<p><a class="el" href="a01006.html#a2b17e6e4504bddf60a920f609fc46ea6">__TBB_Yield()</a> Signals OS that the current thread is willing to relinquish the remainder of its time quantum.</p>
<p><a class="el" href="a00999.html#af48655836e23a2cfcb961674e4d8a6d0">__TBB_full_memory_fence()</a> Must prevent all memory operations from being reordered across it (both by hardware and compiler). All such fences must be totally ordered (or sequentially consistent).</p>
<p><a class="el" href="a01071.html#a10bb66f64b7c049549265fdc5886afcd">__TBB_machine_cmpswp4( volatile void *ptr, int32_t value, int32_t comparand )</a> Must be provided if __TBB_USE_FENCED_ATOMICS is not set.</p>
<p><a class="el" href="a01023.html#ad76e4f500dfe7b08b47b2263bb04213f">__TBB_machine_cmpswp8( volatile void *ptr, int32_t value, int64_t comparand )</a> Must be provided for 64-bit architectures if __TBB_USE_FENCED_ATOMICS is not set, and for 32-bit architectures if __TBB_64BIT_ATOMICS is set</p>
<p>__TBB_machine_&lt;op&gt;&lt;S&gt;&lt;fence&gt;(...), where &lt;op&gt; = {cmpswp, fetchadd, fetchstore} &lt;S&gt; = {1, 2, 4, 8} &lt;fence&gt; = {full_fence, acquire, release, relaxed} Must be provided if __TBB_USE_FENCED_ATOMICS is set.</p>
<p><a class="el" href="a00999.html#a739e3f9cf251b0c785e86fba7c8f8c7c">__TBB_control_consistency_helper()</a> Bridges the memory-semantics gap between architectures providing only implicit C++0x "consume" semantics (like Power Architecture) and those also implicitly obeying control dependencies (like IA-64 architecture). It must be used only in conditional code where the condition is itself data-dependent, and will then make subsequent code behave as if the original data dependency were acquired. It needs only a compiler fence where implied by the architecture either specifically (like IA-64 architecture) or because generally stronger "acquire" semantics are enforced (like x86). It is always valid, though potentially suboptimal, to replace control with acquire on the load and then remove the helper.</p>
<p><a class="el" href="a00999.html#ad488f572360bcd3d83ad5905ccaacbb9">__TBB_acquire_consistency_helper()</a>, <a class="el" href="a00999.html#adf614e8347444c5a20946e81cf7faf9e">__TBB_release_consistency_helper()</a> Must be provided if __TBB_USE_GENERIC_HALF_FENCED_LOAD_STORE is set. Enforce acquire and release semantics in generic implementations of fenced store and load operations. Depending on the particular architecture/compiler combination they may be a hardware fence, a compiler fence, both or nothing.</p>
<p>Before making any changes in the implementation, please emulate algorithmic changes with SPIN tool using &lt;TBB directory&gt;=""&gt;/tools/spin_models/ReaderWriterMutex.pml. There could be some code looking as "can be restructured" but its structure does matter!</p>
<p>This file is a possible future replacement for the task_stream class implemented in task_stream.h. It refactors the code and extends task_stream capabilities by moving lane management during operations on caller side. Despite the fact that new implementation should not affect performance of the original task stream, analysis on this subject was not made at the time it was developed. In addition, it is not clearly seen at the moment that this container would be suitable for critical tasks due to linear time complexity on its operations. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="acce76b9d59c776788ddbd1588a18af42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>(* tbb::assertion_handler_type) (const char *filename, <a class="el" href="a01016.html#ac89988b817e773286215b17e80359ff3">int</a> line, const char *expression, const char *comment)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for an assertion handler. </p>

<p>Definition at line <a class="el" href="a01084_source.html#l00050">50</a> of file <a class="el" href="a01084_source.html">tbb_assert_impl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a889d8f126388fdc24c597d195a4d7028"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::critical_section_v4 <a class="el" href="a01113.html#a889d8f126388fdc24c597d195a4d7028">tbb::critical_section</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00989_source.html#l00129">129</a> of file <a class="el" href="a00989_source.html">critical_section.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6cc3d02744cab8ac389919806d47e417"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00722.html">spin_rw_mutex_v3</a> <a class="el" href="a01113.html#a6cc3d02744cab8ac389919806d47e417">tbb::spin_rw_mutex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01070_source.html#l00037">37</a> of file <a class="el" href="a01070_source.html">spin_rw_mutex.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1a268320974a3357e9609a2f98be5090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="a01113.html#a1a268320974a3357e9609a2f98be5090">tbb::stack_size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01077_source.html#l00032">32</a> of file <a class="el" href="a01077_source.html">task_scheduler_init.h</a>.</p>

</div>
</div>
<a class="anchor" id="af58de4ab3200dd2bd621f052c6f677e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00792.html">tbb::internal::task_scheduler_observer_v3</a> <a class="el" href="a01113.html#af58de4ab3200dd2bd621f052c6f677e4">tbb::task_scheduler_observer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01078_source.html#l00167">167</a> of file <a class="el" href="a01078_source.html">task_scheduler_observer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7805ca254302ff88b566f7dcde7e56b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::tbb_thread_v3 <a class="el" href="a01113.html#a7805ca254302ff88b566f7dcde7e56b0">tbb::tbb_thread</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Users reference thread class by name tbb_thread. </p>

<p>Definition at line <a class="el" href="a01100_source.html#l00300">300</a> of file <a class="el" href="a01100_source.html">tbb_thread.h</a>.</p>

</div>
</div>
<a class="anchor" id="abb0195ccca203ba1b9f262ac1ee8d813"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="a01113.html#abb0195ccca203ba1b9f262ac1ee8d813">tbb::tchar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unicode support. </p>

<p>Definition at line <a class="el" href="a01011_source.html#l00064">64</a> of file <a class="el" href="a01011_source.html">itt_notify.h</a>.</p>

</div>
</div>
<a class="anchor" id="abab1a8559dba9ec44a3deddacadb7d49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00834.html">tricky_atomic_pointer</a>&lt;<a class="el" href="a00684.html">queuing_rw_mutex::scoped_lock</a>&gt; <a class="el" href="a01113.html#abab1a8559dba9ec44a3deddacadb7d49">tbb::tricky_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01053_source.html#l00124">124</a> of file <a class="el" href="a01053_source.html">queuing_rw_mutex.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ac5bcb6154c8307fa9f97806afddf2288"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a01113.html#ac5bcb6154c8307fa9f97806afddf2288">tbb::ets_key_usage_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enum for selecting between single key and key-per-instance versions </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ac5bcb6154c8307fa9f97806afddf2288a012d63023e77883481c1299aa19e93ca"></a>ets_key_per_instance&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac5bcb6154c8307fa9f97806afddf2288aa4c70b844e9456997103856e75f725c8"></a>ets_no_key&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="a00994_source.html#l00048">48</a> of file <a class="el" href="a00994_source.html">enumerable_thread_specific.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;{ <a class="code" href="a01113.html#ac5bcb6154c8307fa9f97806afddf2288a012d63023e77883481c1299aa19e93ca">ets_key_per_instance</a>, <a class="code" href="a01113.html#ac5bcb6154c8307fa9f97806afddf2288aa4c70b844e9456997103856e75f725c8">ets_no_key</a> };</div><div class="ttc" id="a01113_html_ac5bcb6154c8307fa9f97806afddf2288aa4c70b844e9456997103856e75f725c8"><div class="ttname"><a href="a01113.html#ac5bcb6154c8307fa9f97806afddf2288aa4c70b844e9456997103856e75f725c8">tbb::ets_no_key</a></div><div class="ttdef"><b>Definition:</b> <a href="a00994_source.html#l00048">enumerable_thread_specific.h:48</a></div></div>
<div class="ttc" id="a01113_html_ac5bcb6154c8307fa9f97806afddf2288a012d63023e77883481c1299aa19e93ca"><div class="ttname"><a href="a01113.html#ac5bcb6154c8307fa9f97806afddf2288a012d63023e77883481c1299aa19e93ca">tbb::ets_key_per_instance</a></div><div class="ttdef"><b>Definition:</b> <a href="a00994_source.html#l00048">enumerable_thread_specific.h:48</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adb86d08473679d6fe0eabcdc766ffe3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3a">tbb::memory_semantics</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies memory semantics. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="adb86d08473679d6fe0eabcdc766ffe3aa6a315190cf4509ec388ecb423432f36a"></a>full_fence&#160;</td><td class="fielddoc">
<p>Sequential consistency. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adb86d08473679d6fe0eabcdc766ffe3aaa92646b4dc7618530d3a9f51dd10a418"></a>acquire&#160;</td><td class="fielddoc">
<p>Acquire. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adb86d08473679d6fe0eabcdc766ffe3aa412563418e657114a102db610f726632"></a>release&#160;</td><td class="fielddoc">
<p>Release. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5"></a>relaxed&#160;</td><td class="fielddoc">
<p>No ordering. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="a00965_source.html#l00043">43</a> of file <a class="el" href="a00965_source.html">atomic.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                      {</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa6a315190cf4509ec388ecb423432f36a">full_fence</a>,</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aaa92646b4dc7618530d3a9f51dd10a418">acquire</a>,</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa412563418e657114a102db610f726632">release</a>,</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;};</div><div class="ttc" id="a01113_html_adb86d08473679d6fe0eabcdc766ffe3aaa92646b4dc7618530d3a9f51dd10a418"><div class="ttname"><a href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aaa92646b4dc7618530d3a9f51dd10a418">tbb::acquire</a></div><div class="ttdoc">Acquire. </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00047">atomic.h:47</a></div></div>
<div class="ttc" id="a01113_html_adb86d08473679d6fe0eabcdc766ffe3aa412563418e657114a102db610f726632"><div class="ttname"><a href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa412563418e657114a102db610f726632">tbb::release</a></div><div class="ttdoc">Release. </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00049">atomic.h:49</a></div></div>
<div class="ttc" id="a01113_html_adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5"><div class="ttname"><a href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">tbb::relaxed</a></div><div class="ttdoc">No ordering. </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00051">atomic.h:51</a></div></div>
<div class="ttc" id="a01113_html_adb86d08473679d6fe0eabcdc766ffe3aa6a315190cf4509ec388ecb423432f36a"><div class="ttname"><a href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa6a315190cf4509ec388ecb423432f36a">tbb::full_fence</a></div><div class="ttdoc">Sequential consistency. </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00045">atomic.h:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab0404d60533bc35fdf76d52ed166317f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a01113.html#ab0404d60533bc35fdf76d52ed166317f">tbb::priority_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab0404d60533bc35fdf76d52ed166317fa65b5d270dd5bc13800951b452acf90bc"></a>priority_normal&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab0404d60533bc35fdf76d52ed166317fae0bf5301fd3abb024d73231ff1c097c4"></a>priority_low&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab0404d60533bc35fdf76d52ed166317fabedb90c118e48a5f09757d4ecff6caf4"></a>priority_high&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="a01073_source.html#l00295">295</a> of file <a class="el" href="a01073_source.html">task.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                {</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    <a class="code" href="a01113.html#ab0404d60533bc35fdf76d52ed166317fa65b5d270dd5bc13800951b452acf90bc">priority_normal</a> = <a class="code" href="a01133.html#a4fa3a51a97ef0fda20a15e70e85407c8">internal::priority_stride_v4</a> * 2,</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    <a class="code" href="a01113.html#ab0404d60533bc35fdf76d52ed166317fae0bf5301fd3abb024d73231ff1c097c4">priority_low</a> = <a class="code" href="a01113.html#ab0404d60533bc35fdf76d52ed166317fa65b5d270dd5bc13800951b452acf90bc">priority_normal</a> - <a class="code" href="a01133.html#a4fa3a51a97ef0fda20a15e70e85407c8">internal::priority_stride_v4</a>,</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    <a class="code" href="a01113.html#ab0404d60533bc35fdf76d52ed166317fabedb90c118e48a5f09757d4ecff6caf4">priority_high</a> = <a class="code" href="a01113.html#ab0404d60533bc35fdf76d52ed166317fa65b5d270dd5bc13800951b452acf90bc">priority_normal</a> + internal::priority_stride_v4</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;};</div><div class="ttc" id="a01133_html_a4fa3a51a97ef0fda20a15e70e85407c8"><div class="ttname"><a href="a01133.html#a4fa3a51a97ef0fda20a15e70e85407c8">tbb::internal::priority_stride_v4</a></div><div class="ttdeci">static const int priority_stride_v4</div><div class="ttdef"><b>Definition:</b> <a href="a01073_source.html#l00288">task.h:288</a></div></div>
<div class="ttc" id="a01113_html_ab0404d60533bc35fdf76d52ed166317fabedb90c118e48a5f09757d4ecff6caf4"><div class="ttname"><a href="a01113.html#ab0404d60533bc35fdf76d52ed166317fabedb90c118e48a5f09757d4ecff6caf4">tbb::priority_high</a></div><div class="ttdef"><b>Definition:</b> <a href="a01073_source.html#l00298">task.h:298</a></div></div>
<div class="ttc" id="a01113_html_ab0404d60533bc35fdf76d52ed166317fa65b5d270dd5bc13800951b452acf90bc"><div class="ttname"><a href="a01113.html#ab0404d60533bc35fdf76d52ed166317fa65b5d270dd5bc13800951b452acf90bc">tbb::priority_normal</a></div><div class="ttdef"><b>Definition:</b> <a href="a01073_source.html#l00296">task.h:296</a></div></div>
<div class="ttc" id="a01113_html_ab0404d60533bc35fdf76d52ed166317fae0bf5301fd3abb024d73231ff1c097c4"><div class="ttname"><a href="a01113.html#ab0404d60533bc35fdf76d52ed166317fae0bf5301fd3abb024d73231ff1c097c4">tbb::priority_low</a></div><div class="ttdef"><b>Definition:</b> <a href="a01073_source.html#l00297">task.h:297</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad819a3df876043ef1be649b4f80934ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a01113.html#ad819a3df876043ef1be649b4f80934ca">tbb::state_t_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag bits in a state_t that specify information about a locking request. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ad819a3df876043ef1be649b4f80934caaa68a37750c7f09b142c617120cb3b01d"></a>STATE_NONE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad819a3df876043ef1be649b4f80934caa5e91e526baccdb744e32a3b4cc2934b0"></a>STATE_WRITER&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad819a3df876043ef1be649b4f80934caa575000da0a781cbf88c95e903cca9c04"></a>STATE_READER&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad819a3df876043ef1be649b4f80934caad7c9f3aaac3d1b2f2ba873eddfe88fe2"></a>STATE_READER_UNBLOCKNEXT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad819a3df876043ef1be649b4f80934caa8be35adde6bb8652d1fd459605d0f1d2"></a>STATE_ACTIVEREADER&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad819a3df876043ef1be649b4f80934caa7a48f88dbc45c856dce803381b9b828c"></a>STATE_UPGRADE_REQUESTED&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad819a3df876043ef1be649b4f80934caa48020cf78ec3370ac70113fd7db86a90"></a>STATE_UPGRADE_WAITING&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad819a3df876043ef1be649b4f80934caaf963008418de13d883738eb998b1bcd2"></a>STATE_UPGRADE_LOSER&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad819a3df876043ef1be649b4f80934caa7cfb6b8c1da59837add085ce89ea5d77"></a>STATE_COMBINED_WAITINGREADER&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad819a3df876043ef1be649b4f80934caa1a466cd7f11f2bfde068abc90f85d7d7"></a>STATE_COMBINED_READER&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad819a3df876043ef1be649b4f80934caa98ebdac7720db62d8ce0ba4277f3c39c"></a>STATE_COMBINED_UPGRADING&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="a01053_source.html#l00037">37</a> of file <a class="el" href="a01053_source.html">queuing_rw_mutex.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;                   {</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caaa68a37750c7f09b142c617120cb3b01d">STATE_NONE</a>                   = 0,</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caa5e91e526baccdb744e32a3b4cc2934b0">STATE_WRITER</a>                 = 1&lt;&lt;0,</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caa575000da0a781cbf88c95e903cca9c04">STATE_READER</a>                 = 1&lt;&lt;1,</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caad7c9f3aaac3d1b2f2ba873eddfe88fe2">STATE_READER_UNBLOCKNEXT</a>     = 1&lt;&lt;2,</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caa8be35adde6bb8652d1fd459605d0f1d2">STATE_ACTIVEREADER</a>           = 1&lt;&lt;3,</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caa7a48f88dbc45c856dce803381b9b828c">STATE_UPGRADE_REQUESTED</a>      = 1&lt;&lt;4,</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caa48020cf78ec3370ac70113fd7db86a90">STATE_UPGRADE_WAITING</a>        = 1&lt;&lt;5,</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caaf963008418de13d883738eb998b1bcd2">STATE_UPGRADE_LOSER</a>          = 1&lt;&lt;6,</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caa7cfb6b8c1da59837add085ce89ea5d77">STATE_COMBINED_WAITINGREADER</a> = <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caa575000da0a781cbf88c95e903cca9c04">STATE_READER</a> | <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caad7c9f3aaac3d1b2f2ba873eddfe88fe2">STATE_READER_UNBLOCKNEXT</a>,</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caa1a466cd7f11f2bfde068abc90f85d7d7">STATE_COMBINED_READER</a>        = <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caa7cfb6b8c1da59837add085ce89ea5d77">STATE_COMBINED_WAITINGREADER</a> | <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caa8be35adde6bb8652d1fd459605d0f1d2">STATE_ACTIVEREADER</a>,</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caa98ebdac7720db62d8ce0ba4277f3c39c">STATE_COMBINED_UPGRADING</a>     = <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caa48020cf78ec3370ac70113fd7db86a90">STATE_UPGRADE_WAITING</a> | <a class="code" href="a01113.html#ad819a3df876043ef1be649b4f80934caaf963008418de13d883738eb998b1bcd2">STATE_UPGRADE_LOSER</a></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;};</div><div class="ttc" id="a01113_html_ad819a3df876043ef1be649b4f80934caa48020cf78ec3370ac70113fd7db86a90"><div class="ttname"><a href="a01113.html#ad819a3df876043ef1be649b4f80934caa48020cf78ec3370ac70113fd7db86a90">tbb::STATE_UPGRADE_WAITING</a></div><div class="ttdef"><b>Definition:</b> <a href="a01053_source.html#l00044">queuing_rw_mutex.cpp:44</a></div></div>
<div class="ttc" id="a01113_html_ad819a3df876043ef1be649b4f80934caa98ebdac7720db62d8ce0ba4277f3c39c"><div class="ttname"><a href="a01113.html#ad819a3df876043ef1be649b4f80934caa98ebdac7720db62d8ce0ba4277f3c39c">tbb::STATE_COMBINED_UPGRADING</a></div><div class="ttdef"><b>Definition:</b> <a href="a01053_source.html#l00048">queuing_rw_mutex.cpp:48</a></div></div>
<div class="ttc" id="a01113_html_ad819a3df876043ef1be649b4f80934caaf963008418de13d883738eb998b1bcd2"><div class="ttname"><a href="a01113.html#ad819a3df876043ef1be649b4f80934caaf963008418de13d883738eb998b1bcd2">tbb::STATE_UPGRADE_LOSER</a></div><div class="ttdef"><b>Definition:</b> <a href="a01053_source.html#l00045">queuing_rw_mutex.cpp:45</a></div></div>
<div class="ttc" id="a01113_html_ad819a3df876043ef1be649b4f80934caa575000da0a781cbf88c95e903cca9c04"><div class="ttname"><a href="a01113.html#ad819a3df876043ef1be649b4f80934caa575000da0a781cbf88c95e903cca9c04">tbb::STATE_READER</a></div><div class="ttdef"><b>Definition:</b> <a href="a01053_source.html#l00040">queuing_rw_mutex.cpp:40</a></div></div>
<div class="ttc" id="a01113_html_ad819a3df876043ef1be649b4f80934caaa68a37750c7f09b142c617120cb3b01d"><div class="ttname"><a href="a01113.html#ad819a3df876043ef1be649b4f80934caaa68a37750c7f09b142c617120cb3b01d">tbb::STATE_NONE</a></div><div class="ttdef"><b>Definition:</b> <a href="a01053_source.html#l00038">queuing_rw_mutex.cpp:38</a></div></div>
<div class="ttc" id="a01113_html_ad819a3df876043ef1be649b4f80934caa5e91e526baccdb744e32a3b4cc2934b0"><div class="ttname"><a href="a01113.html#ad819a3df876043ef1be649b4f80934caa5e91e526baccdb744e32a3b4cc2934b0">tbb::STATE_WRITER</a></div><div class="ttdef"><b>Definition:</b> <a href="a01053_source.html#l00039">queuing_rw_mutex.cpp:39</a></div></div>
<div class="ttc" id="a01113_html_ad819a3df876043ef1be649b4f80934caa7a48f88dbc45c856dce803381b9b828c"><div class="ttname"><a href="a01113.html#ad819a3df876043ef1be649b4f80934caa7a48f88dbc45c856dce803381b9b828c">tbb::STATE_UPGRADE_REQUESTED</a></div><div class="ttdef"><b>Definition:</b> <a href="a01053_source.html#l00043">queuing_rw_mutex.cpp:43</a></div></div>
<div class="ttc" id="a01113_html_ad819a3df876043ef1be649b4f80934caa1a466cd7f11f2bfde068abc90f85d7d7"><div class="ttname"><a href="a01113.html#ad819a3df876043ef1be649b4f80934caa1a466cd7f11f2bfde068abc90f85d7d7">tbb::STATE_COMBINED_READER</a></div><div class="ttdef"><b>Definition:</b> <a href="a01053_source.html#l00047">queuing_rw_mutex.cpp:47</a></div></div>
<div class="ttc" id="a01113_html_ad819a3df876043ef1be649b4f80934caad7c9f3aaac3d1b2f2ba873eddfe88fe2"><div class="ttname"><a href="a01113.html#ad819a3df876043ef1be649b4f80934caad7c9f3aaac3d1b2f2ba873eddfe88fe2">tbb::STATE_READER_UNBLOCKNEXT</a></div><div class="ttdef"><b>Definition:</b> <a href="a01053_source.html#l00041">queuing_rw_mutex.cpp:41</a></div></div>
<div class="ttc" id="a01113_html_ad819a3df876043ef1be649b4f80934caa7cfb6b8c1da59837add085ce89ea5d77"><div class="ttname"><a href="a01113.html#ad819a3df876043ef1be649b4f80934caa7cfb6b8c1da59837add085ce89ea5d77">tbb::STATE_COMBINED_WAITINGREADER</a></div><div class="ttdef"><b>Definition:</b> <a href="a01053_source.html#l00046">queuing_rw_mutex.cpp:46</a></div></div>
<div class="ttc" id="a01113_html_ad819a3df876043ef1be649b4f80934caa8be35adde6bb8652d1fd459605d0f1d2"><div class="ttname"><a href="a01113.html#ad819a3df876043ef1be649b4f80934caa8be35adde6bb8652d1fd459605d0f1d2">tbb::STATE_ACTIVEREADER</a></div><div class="ttdef"><b>Definition:</b> <a href="a01053_source.html#l00042">queuing_rw_mutex.cpp:42</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4454db821441ca68bad263d82c40fb7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a01113.html#a4454db821441ca68bad263d82c40fb7a">tbb::task_group_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a4454db821441ca68bad263d82c40fb7aaab1411f4c406df521cf3a57b4540a109"></a>not_complete&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4454db821441ca68bad263d82c40fb7aa16ee546d9c961d3311ab99f3528d0bb5"></a>complete&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4454db821441ca68bad263d82c40fb7aa2aee070418c1a4ee59b714d978e39b5e"></a>canceled&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="a01075_source.html#l00065">65</a> of file <a class="el" href="a01075_source.html">task_group.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                       {</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <a class="code" href="a01113.html#a4454db821441ca68bad263d82c40fb7aaab1411f4c406df521cf3a57b4540a109">not_complete</a>,</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <a class="code" href="a01113.html#a4454db821441ca68bad263d82c40fb7aa16ee546d9c961d3311ab99f3528d0bb5">complete</a>,</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <a class="code" href="a01113.html#a4454db821441ca68bad263d82c40fb7aa2aee070418c1a4ee59b714d978e39b5e">canceled</a></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;};</div><div class="ttc" id="a01113_html_a4454db821441ca68bad263d82c40fb7aa16ee546d9c961d3311ab99f3528d0bb5"><div class="ttname"><a href="a01113.html#a4454db821441ca68bad263d82c40fb7aa16ee546d9c961d3311ab99f3528d0bb5">tbb::complete</a></div><div class="ttdef"><b>Definition:</b> <a href="a01075_source.html#l00067">task_group.h:67</a></div></div>
<div class="ttc" id="a01113_html_a4454db821441ca68bad263d82c40fb7aa2aee070418c1a4ee59b714d978e39b5e"><div class="ttname"><a href="a01113.html#a4454db821441ca68bad263d82c40fb7aa2aee070418c1a4ee59b714d978e39b5e">tbb::canceled</a></div><div class="ttdef"><b>Definition:</b> <a href="a01075_source.html#l00068">task_group.h:68</a></div></div>
<div class="ttc" id="a01113_html_a4454db821441ca68bad263d82c40fb7aaab1411f4c406df521cf3a57b4540a109"><div class="ttname"><a href="a01113.html#a4454db821441ca68bad263d82c40fb7aaab1411f4c406df521cf3a57b4540a109">tbb::not_complete</a></div><div class="ttdef"><b>Definition:</b> <a href="a01075_source.html#l00066">task_group.h:66</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9dde30d14920b656e12809567da8f19b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01084.html#ab6dd3eee12dcbf8bc4c41513c4c4c9fb">__TBB_EXPORTED_FUNC</a> tbb::assertion_failure </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01016.html#ac89988b817e773286215b17e80359ff3">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>comment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process an assertion failure. </p>
<p>Normally called from __TBB_ASSERT macro. If assertion handler is null, print message for assertion failure and abort. Otherwise call the assertion handler. </p>

<p>Definition at line <a class="el" href="a01084_source.html#l00060">60</a> of file <a class="el" href="a01084_source.html">tbb_assert_impl.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                                                                                                                              {</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        <span class="keywordflow">if</span>( <a class="code" href="a01098.html#ae280c5f9fb1a931d4313fc9a8097c662">assertion_handler_type</a> a = <a class="code" href="a01113.html#ae4ee10785517963c93564636c8854272">assertion_handler</a> ) {</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            (*a)(filename,line,expression,comment);</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">bool</span> already_failed;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;            <span class="keywordflow">if</span>( !already_failed ) {</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                already_failed = <span class="keyword">true</span>;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;                fprintf( stderr, <span class="stringliteral">&quot;Assertion %s failed on line %d of file %s\n&quot;</span>,</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;                         expression, line, filename );</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                <span class="keywordflow">if</span>( comment )</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;                    fprintf( stderr, <span class="stringliteral">&quot;Detailed description: %s\n&quot;</span>, comment );</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="preprocessor">#if _MSC_VER &amp;&amp; _DEBUG</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                <span class="keywordflow">if</span>(1 == _CrtDbgReport(_CRT_ASSERT, filename, line, <span class="stringliteral">&quot;tbb_debug.dll&quot;</span>, <span class="stringliteral">&quot;%s\r\n%s&quot;</span>, expression, comment?comment:<span class="stringliteral">&quot;&quot;</span>))</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                        _CrtDbgBreak();</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;                fflush(stderr);</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                std::abort();</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            }</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        }</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    }</div><div class="ttc" id="a01113_html_ae4ee10785517963c93564636c8854272"><div class="ttname"><a href="a01113.html#ae4ee10785517963c93564636c8854272">tbb::assertion_handler</a></div><div class="ttdeci">static assertion_handler_type assertion_handler</div><div class="ttdef"><b>Definition:</b> <a href="a01084_source.html#l00052">tbb_assert_impl.h:52</a></div></div>
<div class="ttc" id="a01098_html_ae280c5f9fb1a931d4313fc9a8097c662"><div class="ttname"><a href="a01098.html#ae280c5f9fb1a931d4313fc9a8097c662">assertion_handler_type</a></div><div class="ttdeci">void(* assertion_handler_type)(const char *filename, int line, const char *expression, const char *comment)</div><div class="ttdoc">Type for an assertion handler. </div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00131">tbb_stddef.h:131</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a33e73b97b02726c692bd8d9da8e3fb1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> tbb::atomic_fence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sequentially consistent full memory fence. </p>

<p>Definition at line <a class="el" href="a01089_source.html#l00343">343</a> of file <a class="el" href="a01089_source.html">tbb_machine.h</a>.</p>

<p>References <a class="el" href="a00999.html#af48655836e23a2cfcb961674e4d8a6d0">__TBB_full_memory_fence</a>.</p>

<p>Referenced by <a class="el" href="a00145.html#aba73b319c5ccbef0ba26bf83f6a34e33">tbb::internal::concurrent_monitor::abort_all()</a>, <a class="el" href="a00059.html#adb8d121b4784a910d8d2861a7062446b">tbb::internal::arena::advertise_new_work()</a>, <a class="el" href="a00302.html#a10c72a4aad7308d944cef26502ece55e">tbb::internal::generic_scheduler::get_task()</a>, <a class="el" href="a00302.html#afd799eae7903abc75b7a7aafd36e20db">tbb::internal::generic_scheduler::init_stack_info()</a>, <a class="el" href="a00145.html#a83b6f503d11bc425726dda8eb59424d5">tbb::internal::concurrent_monitor::notify()</a>, <a class="el" href="a00145.html#a9caaa87d7f556a282ab01886ac63e38b">tbb::internal::concurrent_monitor::notify_all()</a>, <a class="el" href="a00145.html#a2ef33e449ee8ede1d9413f4a814ee9cf">tbb::internal::concurrent_monitor::notify_one()</a>, <a class="el" href="a00145.html#a87e8231d37c0875953fc2283c1158115">tbb::internal::concurrent_monitor::prepare_wait()</a>, and <a class="el" href="a00302.html#a15b506cb1b1da8e37255fc2fcdf250f0">tbb::internal::generic_scheduler::steal_task_from()</a>.</p>
<div class="fragment"><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;{ <a class="code" href="a00999.html#af48655836e23a2cfcb961674e4d8a6d0">__TBB_full_memory_fence</a>(); }</div><div class="ttc" id="a00999_html_af48655836e23a2cfcb961674e4d8a6d0"><div class="ttname"><a href="a00999.html#af48655836e23a2cfcb961674e4d8a6d0">__TBB_full_memory_fence</a></div><div class="ttdeci">#define __TBB_full_memory_fence()</div><div class="ttdef"><b>Definition:</b> <a href="a00999_source.html#l00063">gcc_generic.h:63</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a01113_a33e73b97b02726c692bd8d9da8e3fb1b_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5f048ce5bfca13f3bada9bfb09c1687e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T tbb::CAS </td>
          <td>(</td>
          <td class="paramtype">volatile T &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>newv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>oldv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01069_source.html#l00034">34</a> of file <a class="el" href="a01069_source.html">spin_rw_mutex.cpp</a>.</p>

<p>References <a class="el" href="a01133.html#ad83994557e481148b704625b46dece25">tbb::internal::as_atomic()</a>.</p>

<p>Referenced by <a class="el" href="a00722.html#a467101edd40480cbc14a2d91ff812108">tbb::spin_rw_mutex_v3::internal_acquire_writer()</a>, <a class="el" href="a00722.html#a4ff4605d198a16900922eea80f5aac28">tbb::spin_rw_mutex_v3::internal_try_acquire_writer()</a>, and <a class="el" href="a00722.html#abe7bd52786921ba0f923444c91232b08">tbb::spin_rw_mutex_v3::internal_upgrade()</a>.</p>
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;                                                      {</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <span class="comment">// ICC (9.1 and 10.1 tried) unable to do implicit conversion</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <span class="comment">// from &quot;volatile T*&quot; to &quot;volatile void*&quot;, so explicit cast added.</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="a01133.html#ad83994557e481148b704625b46dece25">tbb::internal::as_atomic</a>(<a class="code" href="a01016.html#ae68d53ff4b00841ff67b2cfc6c316b29">addr</a>).compare_and_swap( newv, oldv );</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;}</div><div class="ttc" id="a01016_html_ae68d53ff4b00841ff67b2cfc6c316b29"><div class="ttname"><a href="a01016.html#ae68d53ff4b00841ff67b2cfc6c316b29">addr</a></div><div class="ttdeci">void * addr</div><div class="ttdef"><b>Definition:</b> <a href="a01016_source.html#l00080">ittnotify_static.h:80</a></div></div>
<div class="ttc" id="a01133_html_ad83994557e481148b704625b46dece25"><div class="ttname"><a href="a01133.html#ad83994557e481148b704625b46dece25">tbb::internal::as_atomic</a></div><div class="ttdeci">atomic&lt; T &gt; &amp; as_atomic(T &amp;t)</div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00547">atomic.h:547</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01113_a5f048ce5bfca13f3bada9bfb09c1687e_cgraph.svg" width="294" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01113_a5f048ce5bfca13f3bada9bfb09c1687e_icgraph.svg" width="494" height="198"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa2cfd6795ecbcc8ad30310c862f2b001"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t tbb::get_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00684.html">queuing_rw_mutex::scoped_lock</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01053_source.html#l00135">135</a> of file <a class="el" href="a01053_source.html">queuing_rw_mutex.cpp</a>.</p>

<p>References <a class="el" href="a01113.html#a61c32c9988b9e2a358c5eae7dd0e1f67">FLAG</a>.</p>

<p>Referenced by <a class="el" href="a00684.html#a50fb02b77f02a01c74754d163157ec77">tbb::queuing_rw_mutex::scoped_lock::release()</a>, and <a class="el" href="a00684.html#ae0f28ecfbbc5f8b3024cd47048b72b5b">tbb::queuing_rw_mutex::scoped_lock::upgrade_to_writer()</a>.</p>
<div class="fragment"><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                                                       {</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="keywordflow">return</span> uintptr_t(ptr) &amp; <a class="code" href="a01113.html#a61c32c9988b9e2a358c5eae7dd0e1f67">FLAG</a>;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;}</div><div class="ttc" id="a01113_html_a61c32c9988b9e2a358c5eae7dd0e1f67"><div class="ttname"><a href="a01113.html#a61c32c9988b9e2a358c5eae7dd0e1f67">tbb::FLAG</a></div><div class="ttdeci">static const tricky_pointer::word FLAG</div><div class="ttdoc">Mask for low order bit of a pointer. </div><div class="ttdef"><b>Definition:</b> <a href="a01053_source.html#l00132">queuing_rw_mutex.cpp:132</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01113_aa2cfd6795ecbcc8ad30310c862f2b001_icgraph.svg" width="551" height="132"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aaef1698b222ba9312ab24dcdcd98bbd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::is_current_task_group_canceling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01075_source.html#l00241">241</a> of file <a class="el" href="a01075_source.html">task_group.h</a>.</p>

<p>References <a class="el" href="a00778.html#a540796b339aa9e5bd08cad1cc91da84b">tbb::task::is_cancelled()</a>, and <a class="el" href="a00778.html#a8a82c421e571d0a87fec2ac40f1b6741">tbb::task::self()</a>.</p>
<div class="fragment"><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                                       {</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    <span class="keywordflow">return</span> task::self().is_cancelled();</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;}</div></div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a01113_aaef1698b222ba9312ab24dcdcd98bbd8_cgraph.svg" width="100%" height="404"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aed82c77b389b208a1c27012a2fc0b5fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;memory_semantics M, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T tbb::load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00079.html">atomic</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00965_source.html#l00521">521</a> of file <a class="el" href="a00965_source.html">atomic.h</a>.</p>

<p>Referenced by <a class="el" href="a01133.html#ac0353dd9836bc415fbc77299846ff9e2">tbb::internal::__TBB_FetchAndStoreGeneric()</a>, <a class="el" href="a00999.html#a9743aa954a48dd2aaa13977efbed76ec">__TBB_machine_unlock_byte()</a>, and <a class="el" href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">tbb::internal::atomic_impl&lt; tbb::strict_ppl::internal::concurrent_queue_rep_base::page * &gt;::load()</a>.</p>
<div class="fragment"><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;{ <span class="keywordflow">return</span> a.template load&lt;M&gt;(); }</div></div><!-- fragment -->
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01113_aed82c77b389b208a1c27012a2fc0b5fd_icgraph.svg" width="326" height="214"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aef8de49be152674baa036585a6fdb3cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00785.html">task_handle</a>&lt; typename internal::strip&lt;F&gt;::<a class="el" href="a01016.html#a1fcad32d6fbfbc9f0564e010c1aaddff">type</a> &gt; tbb::make_task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01075_source.html#l00247">247</a> of file <a class="el" href="a01075_source.html">task_group.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                                                                {</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="a01016.html#a1fcad32d6fbfbc9f0564e010c1aaddff">task_handle&lt; typename internal::strip&lt;F&gt;::type</a> &gt;( std::forward&lt;F&gt;(f) );</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;}</div><div class="ttc" id="a01016_html_a1fcad32d6fbfbc9f0564e010c1aaddff"><div class="ttname"><a href="a01016.html#a1fcad32d6fbfbc9f0564e010c1aaddff">type</a></div><div class="ttdeci">void const char const char int ITT_FORMAT __itt_group_sync x void const char ITT_FORMAT __itt_group_sync s void ITT_FORMAT __itt_group_sync p void ITT_FORMAT p void ITT_FORMAT p no args __itt_suppress_mode_t unsigned int void size_t ITT_FORMAT d void ITT_FORMAT p void ITT_FORMAT p __itt_model_site __itt_model_site_instance ITT_FORMAT p __itt_model_task __itt_model_task_instance ITT_FORMAT p void ITT_FORMAT p void ITT_FORMAT p void size_t ITT_FORMAT d void ITT_FORMAT p const wchar_t ITT_FORMAT s const char ITT_FORMAT s const char ITT_FORMAT s const char ITT_FORMAT s no args void ITT_FORMAT p size_t ITT_FORMAT d no args const wchar_t const wchar_t ITT_FORMAT s __itt_heap_function void size_t int ITT_FORMAT d __itt_heap_function void ITT_FORMAT p __itt_heap_function void void size_t int ITT_FORMAT d no args no args unsigned int ITT_FORMAT u const __itt_domain __itt_id ITT_FORMAT lu const __itt_domain __itt_id __itt_id __itt_string_handle ITT_FORMAT p const __itt_domain __itt_id ITT_FORMAT p const __itt_domain __itt_id __itt_timestamp __itt_timestamp ITT_FORMAT lu const __itt_domain __itt_id __itt_id __itt_string_handle ITT_FORMAT p const __itt_domain ITT_FORMAT p const __itt_domain __itt_string_handle unsigned long long ITT_FORMAT lu const __itt_domain __itt_id __itt_string_handle __itt_metadata_type type</div><div class="ttdef"><b>Definition:</b> <a href="a01016_source.html#l00185">ittnotify_static.h:185</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac41903d6b80e61bd6c605412e7820e08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> tbb::move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01113.html#a7805ca254302ff88b566f7dcde7e56b0">tbb_thread</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01113.html#a7805ca254302ff88b566f7dcde7e56b0">tbb_thread</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01100_source.html#l00309">309</a> of file <a class="el" href="a01100_source.html">tbb_thread.h</a>.</p>

<p>References <a class="el" href="a01133.html#abb11c7c316e44b5f97962d62e9ea5f70">tbb::internal::move_v3()</a>.</p>

<p>Referenced by <a class="el" href="a00562.html#a35e042bc0e1453c31e8b17a7c5a3955f">tbb::interface9::parallel_do_feeder&lt; Item &gt;::add()</a>, <a class="el" href="a00143.html#a84eae54922e807ea99eeb8aab6704df1">tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;::allocate_node_move_construct()</a>, <a class="el" href="a01133.html#a4fc0f7677fcad0cbc796143f575e1fd9">tbb::internal::allocator_move_assignment()</a>, <a class="el" href="a00496.html#a18d6f6c21765e531cf532f82cfb233a5">tbb::strict_ppl::internal::micro_queue&lt; Value &gt;::assign_and_destroy_item()</a>, <a class="el" href="a00142.html#a8fb4b90f717ac787199ae40909ffded2">tbb::concurrent_bounded_queue&lt; T, A &gt;::assign_and_destroy_item()</a>, <a class="el" href="a00738.html#a8d7077a17571f3d3f4c0c7f0cd979779">tbb::internal::stored_pack&lt; T, Types... &gt;::call()</a>, <a class="el" href="a00142.html#aad6fd2353d64c2c31d074cd99df58c02">tbb::concurrent_bounded_queue&lt; T, A &gt;::concurrent_bounded_queue()</a>, <a class="el" href="a00143.html#a1e9c7e1650a87c6fdfd282c61587059e">tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;::concurrent_hash_map()</a>, <a class="el" href="a00146.html#a14dd20a4673f77cff3eb6f269a888016">tbb::interface5::concurrent_priority_queue&lt; T, Compare, A &gt;::concurrent_priority_queue()</a>, <a class="el" href="a00147.html#ae918807d098d5d5b41cc6d606fa2e7a1">tbb::strict_ppl::concurrent_queue&lt; T, A &gt;::concurrent_queue()</a>, <a class="el" href="a00161.html#a68921822058efcbc76f5e9c2a68f5ede">tbb::interface5::internal::concurrent_unordered_base&lt; concurrent_unordered_map_traits&lt; Key, T, internal::hash_compare&lt; Key, Hasher, Key_equality &gt;, Allocator, false &gt; &gt;::concurrent_unordered_base()</a>, <a class="el" href="a00162.html#a3987b8ff1e91a6a426d1172021422639">tbb::interface5::concurrent_unordered_map&lt; Key, T, Hasher, Key_equality, Allocator &gt;::concurrent_unordered_map()</a>, <a class="el" href="a00164.html#aa7d2a00fa1eeb5140e8fb50ef8678e77">tbb::interface5::concurrent_unordered_multimap&lt; Key, T, Hasher, Key_equality, Allocator &gt;::concurrent_unordered_multimap()</a>, <a class="el" href="a00165.html#aa3ec1fc8f295567bf418702dfc71eb31">tbb::interface5::concurrent_unordered_multiset&lt; Key, Hasher, Key_equality, Allocator &gt;::concurrent_unordered_multiset()</a>, <a class="el" href="a00166.html#ad9329a555ecb3f5e8d7dc9de3798ef49">tbb::interface5::concurrent_unordered_set&lt; Key, Hasher, Key_equality, Allocator &gt;::concurrent_unordered_set()</a>, <a class="el" href="a00121.html#ab316f80a66b991801b4ec4ea88b852d9">tbb::cache_aligned_allocator&lt; T &gt;::construct()</a>, <a class="el" href="a00797.html#af54fa3029e33cebe5ba64a8538306fdf">tbb::tbb_allocator&lt; T &gt;::construct()</a>, <a class="el" href="a00493.html#a8be8f1b38d4b1b6bea2d83f611bf66e7">tbb::interface6::memory_pool_allocator&lt; T, P &gt;::construct()</a>, <a class="el" href="a00204.html#a50759462e8f469ff8aa037aca275fe4b">tbb::interface7::internal::delegated_function&lt; F, R &gt;::consume_result()</a>, <a class="el" href="a00245.html#a3243aaad22248ef78a3976b37bdf7da1">tbb::interface6::enumerable_thread_specific&lt; T, Allocator, ETS_key_type &gt;::create_local_by_move()</a>, <a class="el" href="a00245.html#a33e410c904bc378c66e8e6724ea16671">tbb::interface6::enumerable_thread_specific&lt; T, Allocator, ETS_key_type &gt;::enumerable_thread_specific()</a>, <a class="el" href="a00226.html#ae262a422fd49dda0f827b2504268f2c1">tbb::interface9::internal::do_iteration_task&lt; Body, Item &gt;::execute()</a>, <a class="el" href="a00146.html#aea4a5cc97588c94be5633b34e9ba5104">tbb::interface5::concurrent_priority_queue&lt; T, Compare, A &gt;::handle_operations()</a>, <a class="el" href="a00146.html#ac3fa7f5d148aff4ab6a90479ea53b10c">tbb::interface5::concurrent_priority_queue&lt; T, Compare, A &gt;::heapify()</a>, <a class="el" href="a00161.html#ae818d882c3918626e6d1b4b5d3985199">tbb::interface5::internal::concurrent_unordered_base&lt; concurrent_unordered_map_traits&lt; Key, T, internal::hash_compare&lt; Key, Hasher, Key_equality &gt;, Allocator, false &gt; &gt;::insert()</a>, <a class="el" href="a00143.html#ac26db94e9be23fbe80c1e5c9eeec085a">tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;::insert()</a>, <a class="el" href="a00563.html#a175967d810c185d6de60e63eaa1db50e">tbb::interface9::internal::parallel_do_feeder_impl&lt; Body, Item &gt;::internal_add_move()</a>, <a class="el" href="a00150.html#abd324c33f3759990fc3c9289f3b1f737">tbb::internal::concurrent_queue_base_v8::internal_push_move()</a>, <a class="el" href="a00150.html#a7c042eb5e7580b2ee12f612849b96605">tbb::internal::concurrent_queue_base_v8::internal_push_move_if_not_full()</a>, <a class="el" href="a00387.html#ab6c1e9d0aa14a4dceaaa5a941d908ce1">tbb::concurrent_vector&lt; T, A &gt;::internal_loop_guide::move_assign()</a>, <a class="el" href="a00387.html#a307813c6eeb270942692545f636a0c41">tbb::concurrent_vector&lt; T, A &gt;::internal_loop_guide::move_construct()</a>, <a class="el" href="a00147.html#a075ab93aa409c02fffe972a810fcb2a4">tbb::strict_ppl::concurrent_queue&lt; T, A &gt;::move_construct_item()</a>, <a class="el" href="a00150.html#ad68a38552f522922df54d62b01d48efe">tbb::internal::concurrent_queue_base_v8::move_content()</a>, <a class="el" href="a00142.html#aa640cb8a48e47aceab19f0e7c32f08f2">tbb::concurrent_bounded_queue&lt; T, A &gt;::move_item()</a>, <a class="el" href="a00142.html#a43e50f3fb6ef0702e3abbb9b454e3dd5">tbb::concurrent_bounded_queue&lt; T, A &gt;::move_page_item()</a>, <a class="el" href="a00133.html#a780f6aeeed80b1c974f22c76907df8c9">tbb::combinable&lt; T &gt;::operator=()</a>, <a class="el" href="a00314.html#addfe0ebcb1c72771eab4bca477f55ad7">tbb::interface6::concurrent_lru_cache&lt; key_type, value_type, value_functor_type &gt;::handle_object::operator=()</a>, <a class="el" href="a00146.html#a9b21bd56aff8c412c5fcdd0d88b48c98">tbb::interface5::concurrent_priority_queue&lt; T, Compare, A &gt;::operator=()</a>, <a class="el" href="a00127.html#a78a66603238d40da9ec6a750b6a2425c">tbb::captured_exception::operator=()</a>, <a class="el" href="a00168.html#a0d26889a94203cdb5f5460fade7497c7">tbb::concurrent_vector&lt; padded_element, padded_allocator_type &gt;::operator=()</a>, <a class="el" href="a00161.html#a353badce7ab9f9fd8ba129312155b078">tbb::interface5::internal::concurrent_unordered_base&lt; concurrent_unordered_map_traits&lt; Key, T, internal::hash_compare&lt; Key, Hasher, Key_equality &gt;, Allocator, false &gt; &gt;::operator=()</a>, <a class="el" href="a00143.html#ad0f01ce516b8d3ab574954843622c7cd">tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;::operator=()</a>, <a class="el" href="a00245.html#a324887df609279ad02d36b3b8e238729">tbb::interface6::enumerable_thread_specific&lt; T, Allocator, ETS_key_type &gt;::operator=()</a>, <a class="el" href="a00168.html#ac29a9f08c0fac7c20786c7b8f4f0321a">tbb::concurrent_vector&lt; padded_element, padded_allocator_type &gt;::push_back()</a>, <a class="el" href="a00146.html#aba5f10cadbaae7a3e6b1db21598e1cb5">tbb::interface5::concurrent_priority_queue&lt; T, Compare, A &gt;::reheap()</a>, <a class="el" href="a00072.html#a491a6f802d47932c3d3531a1dc068815">async_msg&lt; T &gt;::set()</a>, and <a class="el" href="a00446.html#ac93f27c3df5e31e64dbccc5f8da73ca0">internal::kernel_executor_helper&lt; StreamFactory, KernelInputTuple, typename tbb::internal::void_t&lt; typename StreamFactory::range_type &gt;::type &gt;::set_range()</a>.</p>
<div class="fragment"><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                                                   {</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    <a class="code" href="a01133.html#abb11c7c316e44b5f97962d62e9ea5f70">internal::move_v3</a>(t1, t2);</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;}</div><div class="ttc" id="a01133_html_abb11c7c316e44b5f97962d62e9ea5f70"><div class="ttname"><a href="a01133.html#abb11c7c316e44b5f97962d62e9ea5f70">tbb::internal::move_v3</a></div><div class="ttdeci">void __TBB_EXPORTED_FUNC move_v3(tbb_thread_v3 &amp;t1, tbb_thread_v3 &amp;t2)</div><div class="ttdef"><b>Definition:</b> <a href="a01099_source.html#l00151">tbb_thread.cpp:151</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a01113_ac41903d6b80e61bd6c605412e7820e08_cgraph.svg" width="100%" height="410"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a01113_ac41903d6b80e61bd6c605412e7820e08_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="afdaaf3f3248efc804c6f6fe35855704d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00121.html">cache_aligned_allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00121.html">cache_aligned_allocator</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00972_source.html#l00136">136</a> of file <a class="el" href="a00972_source.html">cache_aligned_allocator.h</a>.</p>

<p>References <a class="el" href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a>, <a class="el" href="a01128.html#ac608cedf571017350e29dd7ef60cea01">tbb::interface7::internal::cache_line_size</a>, <a class="el" href="a01133.html#a9083f0017633fb48d690ba23fbd4387f">tbb::internal::is_power_of_two()</a>, and <a class="el" href="a01147.html#ga9694b519576433b7ce9af226bfc7c422">tbb::internal::NFS_GetLineSize()</a>.</p>
<div class="fragment"><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;{<span class="keywordflow">return</span> <span class="keyword">false</span>;}</div></div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01113_afdaaf3f3248efc804c6f6fe35855704d_cgraph.svg" width="316" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a82ff968904aaa1bb0e2152f590c47be6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00797.html">tbb_allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00797.html">tbb_allocator</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01082_source.html#l00146">146</a> of file <a class="el" href="a01082_source.html">tbb_allocator.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;{<span class="keywordflow">return</span> <span class="keyword">false</span>;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a606762cf7c614cb5a1631955938737cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , template&lt; typename X1 &gt; class B1, typename T2 , template&lt; typename X2 &gt; class B2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00934.html">zero_allocator</a>&lt; T1, B1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00934.html">zero_allocator</a>&lt; T2, B2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01082_source.html#l00201">201</a> of file <a class="el" href="a01082_source.html">tbb_allocator.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                                                                                        {</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span> B1&lt;T1&gt; <span class="keyword">&gt;</span>(a) != <span class="keyword">static_cast&lt;</span> B2&lt;T2&gt; <span class="keyword">&gt;</span>(b);</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab7258c4acabadf94d03dc62e29396ea0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A1 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l01356">1356</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;{    <span class="keywordflow">return</span> !(a == b); }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a05667bcb12f763124fcda402d3720c6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare , typename A1 , typename A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const concurrent_hash_map&lt; Key, T, HashCompare, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const concurrent_hash_map&lt; Key, T, HashCompare, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00976_source.html#l01546">1546</a> of file <a class="el" href="a00976_source.html">concurrent_hash_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;{    <span class="keywordflow">return</span> !(a == b); }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa037c1f149250d61cd2fad4541a5e6cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00389.html">tick_count::interval_t</a> tbb::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00827.html">tick_count</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00827.html">tick_count</a> &amp;&#160;</td>
          <td class="paramname"><em>t0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01103_source.html#l00130">130</a> of file <a class="el" href="a01103_source.html">tick_count.h</a>.</p>

<p>References <a class="el" href="a00827.html#a1a4055b83a546a5907a6e2cbce57c3b0">tbb::tick_count::my_count</a>.</p>
<div class="fragment"><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                                                                                    {</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <span class="keywordflow">return</span> tick_count::interval_t( t1.my_count-t0.my_count );</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1523d0389a8cbda80c17ae4f45caa3a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A1 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l01360">1360</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;{    <span class="keywordflow">return</span> (std::lexicographical_compare(a.begin(), a.end(), b.begin(), b.end())); }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac6009f009cd331952d8944bcc9733375"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A1 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l01368">1368</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;{    <span class="keywordflow">return</span> !(b &lt; a); }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a49a6826cf4fb8845d26d8d1f1ad0b5fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00121.html">cache_aligned_allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00121.html">cache_aligned_allocator</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00972_source.html#l00133">133</a> of file <a class="el" href="a00972_source.html">cache_aligned_allocator.h</a>.</p>

<p>Referenced by <a class="el" href="a00309.html#a5280d9fda124b5f9df491d4d64e3a5e7">tbb::flow::interface10::graph_iterator&lt; GraphContainerType, GraphNodeType &gt;::operator!=()</a>.</p>
<div class="fragment"><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;{<span class="keywordflow">return</span> <span class="keyword">true</span>;}</div></div><!-- fragment -->
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01113_a49a6826cf4fb8845d26d8d1f1ad0b5fa_icgraph.svg" width="346" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="af1595d1bfc4f7be923c17b4ee5c556ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00797.html">tbb_allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00797.html">tbb_allocator</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01082_source.html#l00143">143</a> of file <a class="el" href="a01082_source.html">tbb_allocator.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;{<span class="keywordflow">return</span> <span class="keyword">true</span>;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7bf465e2f6730e2cea0c9531bec9fb2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , template&lt; typename X1 &gt; class B1, typename T2 , template&lt; typename X2 &gt; class B2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00934.html">zero_allocator</a>&lt; T1, B1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00934.html">zero_allocator</a>&lt; T2, B2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01082_source.html#l00197">197</a> of file <a class="el" href="a01082_source.html">tbb_allocator.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;                                                                                        {</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span> B1&lt;T1&gt; <span class="keyword">&gt;</span>(a) == <span class="keyword">static_cast&lt;</span> B2&lt;T2&gt; <span class="keyword">&gt;</span>(b);</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a79ecee2d23f2486c03e720ab9e3ac36c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A1 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l01344">1344</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>References <a class="el" href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">tbb::concurrent_vector&lt; T, A &gt;::begin()</a>, <a class="el" href="a00168.html#aad2c07653375e4a5f89c33b375eda610">tbb::concurrent_vector&lt; T, A &gt;::end()</a>, and <a class="el" href="a00168.html#a803268c16e3688ff4681251947d257c7">tbb::concurrent_vector&lt; T, A &gt;::size()</a>.</p>
<div class="fragment"><div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;                                                                                             {</div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;    <span class="comment">//TODO: call size() only once per vector (in operator==)</span></div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;    <span class="comment">// Simply:    return a.size() == b.size() &amp;&amp; std::equal(a.begin(), a.end(), b.begin());</span></div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;    <span class="keywordflow">if</span>(a.size() != b.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;    <span class="keyword">typename</span> concurrent_vector&lt;T, A1&gt;::const_iterator i(a.begin());</div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;    <span class="keyword">typename</span> concurrent_vector&lt;T, A2&gt;::const_iterator j(b.begin());</div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;    <span class="keywordflow">for</span>(; i != a.end(); ++i, ++j)</div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;        <span class="keywordflow">if</span>( !(*i == *j) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;}</div></div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01113_a79ecee2d23f2486c03e720ab9e3ac36c_cgraph.svg" width="351" height="170"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1db9470dd2871cb7394ab262dca2051a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare , typename A1 , typename A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::operator== </td>
          <td>(</td>
          <td class="paramtype">const concurrent_hash_map&lt; Key, T, HashCompare, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const concurrent_hash_map&lt; Key, T, HashCompare, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00976_source.html#l01534">1534</a> of file <a class="el" href="a00976_source.html">concurrent_hash_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;                                                                                                                                     {</div><div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;    <span class="keywordflow">if</span>(a.size() != b.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;    <span class="keyword">typename</span> concurrent_hash_map&lt;Key, T, HashCompare, A1&gt;::const_iterator i(a.begin()), i_end(a.end());</div><div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;    <span class="keyword">typename</span> concurrent_hash_map&lt;Key, T, HashCompare, A2&gt;::const_iterator j, j_end(b.end());</div><div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;    <span class="keywordflow">for</span>(; i != i_end; ++i) {</div><div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;        j = b.equal_range(i-&gt;first).first;</div><div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;        <span class="keywordflow">if</span>( j == j_end || !(i-&gt;second == j-&gt;second) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;    }</div><div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a78cfed58bfde865b68859beb54805019"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A1 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l01364">1364</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;{    <span class="keywordflow">return</span> b &lt; a; }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa0d82e59919a1f2c7caa06d061b2480f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A1 , class A2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tbb::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l01372">1372</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;{    <span class="keywordflow">return</span> !(a &lt; b); }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4c95ae5d0eb374299c1be4fdb8fb88e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01113.html#acce76b9d59c776788ddbd1588a18af42">assertion_handler_type</a> <a class="el" href="a01084.html#ab6dd3eee12dcbf8bc4c41513c4c4c9fb">__TBB_EXPORTED_FUNC</a> tbb::set_assertion_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01113.html#acce76b9d59c776788ddbd1588a18af42">assertion_handler_type</a>&#160;</td>
          <td class="paramname"><em>new_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set assertion handler and return previous value of it. </p>

<p>Definition at line <a class="el" href="a01084_source.html#l00054">54</a> of file <a class="el" href="a01084_source.html">tbb_assert_impl.h</a>.</p>

<p>References <a class="el" href="a01113.html#ae4ee10785517963c93564636c8854272">assertion_handler</a>.</p>
<div class="fragment"><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;                                                                                                           {</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <a class="code" href="a01098.html#ae280c5f9fb1a931d4313fc9a8097c662">assertion_handler_type</a> old_handler = <a class="code" href="a01113.html#ae4ee10785517963c93564636c8854272">assertion_handler</a>;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        <a class="code" href="a01113.html#ae4ee10785517963c93564636c8854272">assertion_handler</a> = new_handler;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        <span class="keywordflow">return</span> old_handler;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    }</div><div class="ttc" id="a01113_html_ae4ee10785517963c93564636c8854272"><div class="ttname"><a href="a01113.html#ae4ee10785517963c93564636c8854272">tbb::assertion_handler</a></div><div class="ttdeci">static assertion_handler_type assertion_handler</div><div class="ttdef"><b>Definition:</b> <a href="a01084_source.html#l00052">tbb_assert_impl.h:52</a></div></div>
<div class="ttc" id="a01098_html_ae280c5f9fb1a931d4313fc9a8097c662"><div class="ttname"><a href="a01098.html#ae280c5f9fb1a931d4313fc9a8097c662">assertion_handler_type</a></div><div class="ttdeci">void(* assertion_handler_type)(const char *filename, int line, const char *expression, const char *comment)</div><div class="ttdoc">Type for an assertion handler. </div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00131">tbb_stddef.h:131</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a219b97248f55c909aa3d84e43934b105"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;memory_semantics M, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> tbb::store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00079.html">atomic</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00965_source.html#l00524">524</a> of file <a class="el" href="a00965_source.html">atomic.h</a>.</p>

<p>References <a class="el" href="a01016.html#a2507091f87afae57e117a984a7c4dd61">value</a>.</p>

<p>Referenced by <a class="el" href="a01133.html#ac0353dd9836bc415fbc77299846ff9e2">tbb::internal::__TBB_FetchAndStoreGeneric()</a>, <a class="el" href="a00999.html#a9743aa954a48dd2aaa13977efbed76ec">__TBB_machine_unlock_byte()</a>, and <a class="el" href="a00083.html#af1db97c8907b00e2b54b81d15f02b4ef">tbb::internal::atomic_impl&lt; tbb::strict_ppl::internal::concurrent_queue_rep_base::page * &gt;::store()</a>.</p>
<div class="fragment"><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;{ a.template store&lt;M&gt;(<a class="code" href="a01016.html#a2507091f87afae57e117a984a7c4dd61">value</a>); }</div><div class="ttc" id="a01016_html_a2507091f87afae57e117a984a7c4dd61"><div class="ttname"><a href="a01016.html#a2507091f87afae57e117a984a7c4dd61">value</a></div><div class="ttdeci">void const char const char int ITT_FORMAT __itt_group_sync x void const char ITT_FORMAT __itt_group_sync s void ITT_FORMAT __itt_group_sync p void ITT_FORMAT p void ITT_FORMAT p no args __itt_suppress_mode_t unsigned int void size_t ITT_FORMAT d void ITT_FORMAT p void ITT_FORMAT p __itt_model_site __itt_model_site_instance ITT_FORMAT p __itt_model_task __itt_model_task_instance ITT_FORMAT p void ITT_FORMAT p void ITT_FORMAT p void size_t ITT_FORMAT d void ITT_FORMAT p const wchar_t ITT_FORMAT s const char ITT_FORMAT s const char ITT_FORMAT s const char ITT_FORMAT s no args void ITT_FORMAT p size_t ITT_FORMAT d no args const wchar_t const wchar_t ITT_FORMAT s __itt_heap_function void size_t int ITT_FORMAT d __itt_heap_function void ITT_FORMAT p __itt_heap_function void void size_t int ITT_FORMAT d no args no args unsigned int ITT_FORMAT u const __itt_domain __itt_id ITT_FORMAT lu const __itt_domain __itt_id __itt_id __itt_string_handle ITT_FORMAT p const __itt_domain __itt_id ITT_FORMAT p const __itt_domain __itt_id __itt_timestamp __itt_timestamp ITT_FORMAT lu const __itt_domain __itt_id __itt_id __itt_string_handle ITT_FORMAT p const __itt_domain ITT_FORMAT p const __itt_domain __itt_string_handle unsigned long long value</div><div class="ttdef"><b>Definition:</b> <a href="a01016_source.html#l00181">ittnotify_static.h:181</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01113_a219b97248f55c909aa3d84e43934b105_icgraph.svg" width="331" height="214"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a467930903ce9b7c240c4ad8f0fb8ae3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> tbb::swap </td>
          <td>(</td>
          <td class="paramtype">internal::tbb_thread_v3 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::tbb_thread_v3 &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01100_source.html#l00313">313</a> of file <a class="el" href="a01100_source.html">tbb_thread.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                                                                                               {</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    <a class="code" href="a01113.html#a467930903ce9b7c240c4ad8f0fb8ae3d">std::swap</a>(t1.my_handle, t2.my_handle);</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="preprocessor">#if _WIN32||_WIN64</span></div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <a class="code" href="a01113.html#a467930903ce9b7c240c4ad8f0fb8ae3d">std::swap</a>(t1.my_thread_id, t2.my_thread_id);</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="preprocessor">#endif </span><span class="comment">/* _WIN32||_WIN64 */</span><span class="preprocessor"></span></div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;}</div><div class="ttc" id="a01113_html_a467930903ce9b7c240c4ad8f0fb8ae3d"><div class="ttname"><a href="a01113.html#a467930903ce9b7c240c4ad8f0fb8ae3d">tbb::swap</a></div><div class="ttdeci">void swap(internal::tbb_thread_v3 &amp;t1, internal::tbb_thread_v3 &amp;t2) __TBB_NOEXCEPT(true)</div><div class="ttdef"><b>Definition:</b> <a href="a01100_source.html#l00313">tbb_thread.h:313</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4cd91084f08db8c2d23c6a0362e0c441"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> tbb::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l01376">1376</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>References <a class="el" href="a00168.html#a8603bd57324fb6b60ba006884c95279d">tbb::concurrent_vector&lt; T, A &gt;::swap()</a>.</p>
<div class="fragment"><div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;{    a.swap( b ); }</div></div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01113_a4cd91084f08db8c2d23c6a0362e0c441_cgraph.svg" width="290" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a16dc40ac2badc8b36b8cc70f92801b76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> tbb::swap </td>
          <td>(</td>
          <td class="paramtype">concurrent_hash_map&lt; Key, T, HashCompare, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">concurrent_hash_map&lt; Key, T, HashCompare, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00976_source.html#l01550">1550</a> of file <a class="el" href="a00976_source.html">concurrent_hash_map.h</a>.</p>

<p>Referenced by <a class="el" href="a00146.html#ac64c7b627708f0d6b2e5421fb0d49150">tbb::interface5::concurrent_priority_queue&lt; T, Compare, A &gt;::assign()</a>, <a class="el" href="a00143.html#a1e9c7e1650a87c6fdfd282c61587059e">tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;::concurrent_hash_map()</a>, <a class="el" href="a00161.html#a575d3be93a7c563abb1f9f035e5ac9f3">tbb::interface5::internal::concurrent_unordered_base&lt; concurrent_unordered_map_traits&lt; Key, T, internal::hash_compare&lt; Key, Hasher, Key_equality &gt;, Allocator, false &gt; &gt;::concurrent_unordered_base()</a>, <a class="el" href="a00143.html#ad4993bc44e0c923f2e8430d81367889d">tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;::get_allocator()</a>, <a class="el" href="a00808.html#a6a9263b2bb0ca86973443f283746bcab">tbb::internal::tbb_thread_v3::internal_move()</a>, <a class="el" href="a00326.html#a7ad888bfe73f0258cb8caeb9229f1524">tbb::interface5::internal::hash_map_base::internal_swap()</a>, <a class="el" href="a00245.html#a37b70bb1f2783ae7ea93baed5a3458bc">tbb::interface6::enumerable_thread_specific&lt; T, Allocator, ETS_key_type &gt;::internal_swap()</a>, <a class="el" href="a00146.html#ac0c3f41b10f04547f3438517c40cf8a5">tbb::interface5::concurrent_priority_queue&lt; T, Compare, A &gt;::operator=()</a>, <a class="el" href="a00161.html#a353badce7ab9f9fd8ba129312155b078">tbb::interface5::internal::concurrent_unordered_base&lt; concurrent_unordered_map_traits&lt; Key, T, internal::hash_compare&lt; Key, Hasher, Key_equality &gt;, Allocator, false &gt; &gt;::operator=()</a>, <a class="el" href="a00143.html#ad0f01ce516b8d3ab574954843622c7cd">tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;::operator=()</a>, <a class="el" href="a00808.html#ab2e10af48f3f2482e9e7236f2e05714c">tbb::internal::tbb_thread_v3::swap()</a>, <a class="el" href="a00146.html#aa6ee6d356e538b67a7cb4e242e6e36c9">tbb::interface5::concurrent_priority_queue&lt; T, Compare, A &gt;::swap()</a>, and <a class="el" href="a00143.html#a4c8edf603bc776a6c84c007702c1808e">tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;::swap()</a>.</p>
<div class="fragment"><div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;{    a.swap( b ); }</div></div><!-- fragment -->
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a01113_a16dc40ac2badc8b36b8cc70f92801b76_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5f474a376c6d74ac55c943da765d609b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#ac89988b817e773286215b17e80359ff3">int</a> tbb::TBB_runtime_interface_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns the interface version of the TBB shared library being used. </p>
<p>The version it returns is determined at runtime, not at compile/link time. So it can be different than the value of TBB_INTERFACE_VERSION obtained at compile time. </p>

<p>Definition at line <a class="el" href="a01092_source.html#l00258">258</a> of file <a class="el" href="a01092_source.html">tbb_misc.cpp</a>.</p>

<p>References <a class="el" href="a01006.html#ad76e4f500dfe7b08b47b2263bb04213f">__TBB_machine_cmpswp8</a>, <a class="el" href="a01020.html#a52d98d7825b94241b1651d4de6175b52">__TBB_machine_lockbyte()</a>, <a class="el" href="a01019.html#a07cc5b170eef7c9cc319f64552ac9815">__TBB_machine_store8_slow()</a>, <a class="el" href="a01019.html#a0fb35f23504db9a9dfc287d8007e368f">__TBB_machine_store8_slow_perf_warning()</a>, <a class="el" href="a01089.html#ad95ec7e5b7103614f039c4019bf3b3f6">__TBB_TryLockByte()</a>, <a class="el" href="a00082.html#a03a7500cc7bb0ad8ab421b2cafd48e9c">tbb::internal::atomic_backoff::pause()</a>, <a class="el" href="a01133.html#a0ddf43033695d442c64c4a44f6d6c211">tbb::internal::runtime_warning()</a>, <a class="el" href="a01098.html#a807df374ec89e4c365c22f804eed73ba">TBB_INTERFACE_VERSION</a>, and <a class="el" href="a01016.html#a2507091f87afae57e117a984a7c4dd61">value</a>.</p>
<div class="fragment"><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                                               {</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="a01098.html#a807df374ec89e4c365c22f804eed73ba">TBB_INTERFACE_VERSION</a>;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;}</div><div class="ttc" id="a01098_html_a807df374ec89e4c365c22f804eed73ba"><div class="ttname"><a href="a01098.html#a807df374ec89e4c365c22f804eed73ba">TBB_INTERFACE_VERSION</a></div><div class="ttdeci">#define TBB_INTERFACE_VERSION</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00029">tbb_stddef.h:29</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01113_a5f474a376c6d74ac55c943da765d609b_cgraph.svg" width="664" height="338"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a23d7a75a045cac9054ae7614eeb0545b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char tbb::ACQUIRED = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01053_source.html#l00052">52</a> of file <a class="el" href="a01053_source.html">queuing_rw_mutex.cpp</a>.</p>

<p>Referenced by <a class="el" href="a00684.html#a497dd2f219507fdd2d32ea91d44c5ac8">tbb::queuing_rw_mutex::scoped_lock::try_acquire_internal_lock()</a>.</p>

</div>
</div>
<a class="anchor" id="ae4ee10785517963c93564636c8854272"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01113.html#acce76b9d59c776788ddbd1588a18af42">assertion_handler_type</a> tbb::assertion_handler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01084_source.html#l00052">52</a> of file <a class="el" href="a01084_source.html">tbb_assert_impl.h</a>.</p>

<p>Referenced by <a class="el" href="a01113.html#a4c95ae5d0eb374299c1be4fdb8fb88e3">set_assertion_handler()</a>.</p>

</div>
</div>
<a class="anchor" id="a61c32c9988b9e2a358c5eae7dd0e1f67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00834.html#a895d00be1f535b43102d037b4e0197d6">tricky_pointer::word</a> tbb::FLAG = 0x1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask for low order bit of a pointer. </p>

<p>Definition at line <a class="el" href="a01053_source.html#l00132">132</a> of file <a class="el" href="a01053_source.html">queuing_rw_mutex.cpp</a>.</p>

<p>Referenced by <a class="el" href="a01113.html#aa2cfd6795ecbcc8ad30310c862f2b001">get_flag()</a>, <a class="el" href="a00684.html#a50fb02b77f02a01c74754d163157ec77">tbb::queuing_rw_mutex::scoped_lock::release()</a>, and <a class="el" href="a00684.html#ae0f28ecfbbc5f8b3024cd47048b72b5b">tbb::queuing_rw_mutex::scoped_lock::upgrade_to_writer()</a>.</p>

</div>
</div>
<a class="anchor" id="afa4b635d11688d1a0c6c74272b30c382"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char tbb::RELEASED = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a01053_source.html#l00051">51</a> of file <a class="el" href="a01053_source.html">queuing_rw_mutex.cpp</a>.</p>

<p>Referenced by <a class="el" href="a00684.html#ab4bf2fb86d6a418f9ea36474eb8893f9">tbb::queuing_rw_mutex::scoped_lock::acquire()</a>, <a class="el" href="a00684.html#a4843d40dddc37c1aa3444e27d35d2433">tbb::queuing_rw_mutex::scoped_lock::try_acquire()</a>, and <a class="el" href="a00684.html#a497dd2f219507fdd2d32ea91d44c5ac8">tbb::queuing_rw_mutex::scoped_lock::try_acquire_internal_lock()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<hr>
<p></p>
Copyright &copy; 2005-2019 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
