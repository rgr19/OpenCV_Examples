<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Intel(R) Threading Building Blocks Doxygen Documentation: tbb::concurrent_vector&lt; T, A &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Intel(R) Threading Building Blocks Doxygen Documentation
   &#160;<span id="projectnumber">version 4.2.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00168.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a01937.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tbb::concurrent_vector&lt; T, A &gt; Class Template Reference<div class="ingroups"><a class="el" href="a01146.html">Containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Concurrent vector container.  
 <a href="a00168.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00986_source.html">concurrent_vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tbb::concurrent_vector&lt; T, A &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a01938.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<div class="dynheader">
Collaboration diagram for tbb::concurrent_vector&lt; T, A &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a01939.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00300.html">generic_range_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00387.html">internal_loop_guide</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception-aware helper class for filling a segment by exception-danger operators of user class.  <a href="a00387.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00398.html">is_integer_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">True/false function override helper.  <a href="a00398.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00611.html">push_back_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ada098ff121699bfed7ae37e759eff93d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">internal::concurrent_vector_base_v3::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#ada098ff121699bfed7ae37e759eff93d">size_type</a></td></tr>
<tr class="separator:ada098ff121699bfed7ae37e759eff93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7560567b5735c57159e55b12d20b6710"><td class="memItemLeft" align="right" valign="top">typedef internal::allocator_base&lt; T, A &gt;::<a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a7560567b5735c57159e55b12d20b6710">allocator_type</a></td></tr>
<tr class="separator:a7560567b5735c57159e55b12d20b6710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf801a503d4e5fe739f53d7321dd2ef"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a5cf801a503d4e5fe739f53d7321dd2ef">value_type</a></td></tr>
<tr class="separator:a5cf801a503d4e5fe739f53d7321dd2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb52adb877d3b680dac5f0bd289700b"><td class="memItemLeft" align="right" valign="top">typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a1bb52adb877d3b680dac5f0bd289700b">difference_type</a></td></tr>
<tr class="separator:a1bb52adb877d3b680dac5f0bd289700b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412441e93ad8656f96b14c5ecb9d817f"><td class="memItemLeft" align="right" valign="top">typedef T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a412441e93ad8656f96b14c5ecb9d817f">reference</a></td></tr>
<tr class="separator:a412441e93ad8656f96b14c5ecb9d817f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecbb1eb2c7264df9d58255ce211207c"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a></td></tr>
<tr class="separator:a5ecbb1eb2c7264df9d58255ce211207c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c4f00678df69d2d11497e8dd6ed9cf"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#aa2c4f00678df69d2d11497e8dd6ed9cf">pointer</a></td></tr>
<tr class="separator:aa2c4f00678df69d2d11497e8dd6ed9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0d28eb686589cbaf4733ca0eabc071"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#afa0d28eb686589cbaf4733ca0eabc071">const_pointer</a></td></tr>
<tr class="separator:afa0d28eb686589cbaf4733ca0eabc071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cee8eaee236867c0b6e87309380cb0f"><td class="memItemLeft" align="right" valign="top">typedef internal::vector_iterator&lt; <a class="el" href="a00168.html">concurrent_vector</a>, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a></td></tr>
<tr class="separator:a4cee8eaee236867c0b6e87309380cb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a55035528c055ae985db2a61c8b0b2"><td class="memItemLeft" align="right" valign="top">typedef internal::vector_iterator&lt; <a class="el" href="a00168.html">concurrent_vector</a>, const T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a></td></tr>
<tr class="separator:aa9a55035528c055ae985db2a61c8b0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1623110816f9ef8f08e7bf6768aed273"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a1623110816f9ef8f08e7bf6768aed273">reverse_iterator</a></td></tr>
<tr class="separator:a1623110816f9ef8f08e7bf6768aed273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada43b048144c3814036da624d3bb8c58"><td class="memItemLeft" align="right" valign="top">typedef std::reverse_iterator&lt; <a class="el" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#ada43b048144c3814036da624d3bb8c58">const_reverse_iterator</a></td></tr>
<tr class="separator:ada43b048144c3814036da624d3bb8c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443492ee9918c9e3372b5daca82314ca"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00300.html">generic_range_type</a>&lt; <a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a443492ee9918c9e3372b5daca82314ca">range_type</a></td></tr>
<tr class="separator:a443492ee9918c9e3372b5daca82314ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1312eb29abf7ca07aa365c727b7844e3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00300.html">generic_range_type</a>&lt; <a class="el" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a1312eb29abf7ca07aa365c727b7844e3">const_range_type</a></td></tr>
<tr class="separator:a1312eb29abf7ca07aa365c727b7844e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5bd95c2241653c760704a92b2c887a48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a5bd95c2241653c760704a92b2c887a48">concurrent_vector</a> (const <a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> &amp;a=<a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a>())</td></tr>
<tr class="memdesc:a5bd95c2241653c760704a92b2c887a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct empty vector.  <a href="#a5bd95c2241653c760704a92b2c887a48">More...</a><br /></td></tr>
<tr class="separator:a5bd95c2241653c760704a92b2c887a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25dccd2f65fbfa148e92d01a11c20ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#aa25dccd2f65fbfa148e92d01a11c20ff">concurrent_vector</a> (std::initializer_list&lt; T &gt; init_list, const <a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> &amp;a=<a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a>())</td></tr>
<tr class="memdesc:aa25dccd2f65fbfa148e92d01a11c20ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from initializer_list.  <a href="#aa25dccd2f65fbfa148e92d01a11c20ff">More...</a><br /></td></tr>
<tr class="separator:aa25dccd2f65fbfa148e92d01a11c20ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b5a0e9069b30dc4e2e5fc2f191ccb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a03b5a0e9069b30dc4e2e5fc2f191ccb6">concurrent_vector</a> (const <a class="el" href="a00168.html">concurrent_vector</a> &amp;vector, const <a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> &amp;a=<a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a>())</td></tr>
<tr class="memdesc:a03b5a0e9069b30dc4e2e5fc2f191ccb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying constructor.  <a href="#a03b5a0e9069b30dc4e2e5fc2f191ccb6">More...</a><br /></td></tr>
<tr class="separator:a03b5a0e9069b30dc4e2e5fc2f191ccb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb048cfda83d0e7803888ead76c06a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#aafb048cfda83d0e7803888ead76c06a9">concurrent_vector</a> (<a class="el" href="a00168.html">concurrent_vector</a> &amp;&amp;source)</td></tr>
<tr class="memdesc:aafb048cfda83d0e7803888ead76c06a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#aafb048cfda83d0e7803888ead76c06a9">More...</a><br /></td></tr>
<tr class="separator:aafb048cfda83d0e7803888ead76c06a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef020f41f3017fecc43e70a22d3e0fc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#aef020f41f3017fecc43e70a22d3e0fc0">concurrent_vector</a> (<a class="el" href="a00168.html">concurrent_vector</a> &amp;&amp;source, const <a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> &amp;a)</td></tr>
<tr class="separator:aef020f41f3017fecc43e70a22d3e0fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0e376a31c3fdb91beaaa98441735f5"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:abb0e376a31c3fdb91beaaa98441735f5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00168.html#abb0e376a31c3fdb91beaaa98441735f5">concurrent_vector</a> (const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, M &gt; &amp;vector, const <a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> &amp;a=<a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a>())</td></tr>
<tr class="memdesc:abb0e376a31c3fdb91beaaa98441735f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying constructor for vector with different allocator type.  <a href="#abb0e376a31c3fdb91beaaa98441735f5">More...</a><br /></td></tr>
<tr class="separator:abb0e376a31c3fdb91beaaa98441735f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa898a39aad73711ceca70cd465dc0b4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#aa898a39aad73711ceca70cd465dc0b4f">concurrent_vector</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n)</td></tr>
<tr class="memdesc:aa898a39aad73711ceca70cd465dc0b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction with initial size specified by argument n.  <a href="#aa898a39aad73711ceca70cd465dc0b4f">More...</a><br /></td></tr>
<tr class="separator:aa898a39aad73711ceca70cd465dc0b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736c6e35f1df11625636968ea546e21f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a736c6e35f1df11625636968ea546e21f">concurrent_vector</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n, <a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a> t, const <a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> &amp;a=<a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a>())</td></tr>
<tr class="memdesc:a736c6e35f1df11625636968ea546e21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction with initial size specified by argument n, initialization by copying of t, and given allocator instance.  <a href="#a736c6e35f1df11625636968ea546e21f">More...</a><br /></td></tr>
<tr class="separator:a736c6e35f1df11625636968ea546e21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d384ec56032d18f63e26960029d3ce"><td class="memTemplParams" colspan="2">template&lt;class I &gt; </td></tr>
<tr class="memitem:ae0d384ec56032d18f63e26960029d3ce"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00168.html#ae0d384ec56032d18f63e26960029d3ce">concurrent_vector</a> (I first, I last, const <a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> &amp;a=<a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a>())</td></tr>
<tr class="memdesc:ae0d384ec56032d18f63e26960029d3ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction with copying iteration range and given allocator instance.  <a href="#ae0d384ec56032d18f63e26960029d3ce">More...</a><br /></td></tr>
<tr class="separator:ae0d384ec56032d18f63e26960029d3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920384aece0eb8beea3049956320ec91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html">concurrent_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a920384aece0eb8beea3049956320ec91">operator=</a> (const <a class="el" href="a00168.html">concurrent_vector</a> &amp;vector)</td></tr>
<tr class="memdesc:a920384aece0eb8beea3049956320ec91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <a href="#a920384aece0eb8beea3049956320ec91">More...</a><br /></td></tr>
<tr class="separator:a920384aece0eb8beea3049956320ec91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d26889a94203cdb5f5460fade7497c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html">concurrent_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a0d26889a94203cdb5f5460fade7497c7">operator=</a> (<a class="el" href="a00168.html">concurrent_vector</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a0d26889a94203cdb5f5460fade7497c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <a href="#a0d26889a94203cdb5f5460fade7497c7">More...</a><br /></td></tr>
<tr class="separator:a0d26889a94203cdb5f5460fade7497c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe7f0b60bbf304890a9293a35e6819d"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a1fe7f0b60bbf304890a9293a35e6819d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00168.html">concurrent_vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00168.html#a1fe7f0b60bbf304890a9293a35e6819d">operator=</a> (const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, M &gt; &amp;vector)</td></tr>
<tr class="memdesc:a1fe7f0b60bbf304890a9293a35e6819d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment for vector with different allocator type.  <a href="#a1fe7f0b60bbf304890a9293a35e6819d">More...</a><br /></td></tr>
<tr class="separator:a1fe7f0b60bbf304890a9293a35e6819d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8498a1335a3bbac2f4925a4e8d70cdb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html">concurrent_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a8498a1335a3bbac2f4925a4e8d70cdb8">operator=</a> (std::initializer_list&lt; T &gt; init_list)</td></tr>
<tr class="memdesc:a8498a1335a3bbac2f4925a4e8d70cdb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment for initializer_list.  <a href="#a8498a1335a3bbac2f4925a4e8d70cdb8">More...</a><br /></td></tr>
<tr class="separator:a8498a1335a3bbac2f4925a4e8d70cdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89c2db5358048debdc282ff995caffb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#ab89c2db5358048debdc282ff995caffb">grow_by</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> delta)</td></tr>
<tr class="memdesc:ab89c2db5358048debdc282ff995caffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grow by "delta" elements.  <a href="#ab89c2db5358048debdc282ff995caffb">More...</a><br /></td></tr>
<tr class="separator:ab89c2db5358048debdc282ff995caffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11fc991cda82cf93789fce31b37a16c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#aa11fc991cda82cf93789fce31b37a16c">grow_by</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> delta, <a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a> t)</td></tr>
<tr class="memdesc:aa11fc991cda82cf93789fce31b37a16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grow by "delta" elements using copying constructor.  <a href="#aa11fc991cda82cf93789fce31b37a16c">More...</a><br /></td></tr>
<tr class="separator:aa11fc991cda82cf93789fce31b37a16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd74483ff523213b78f44fb914c8eb4"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:acfd74483ff523213b78f44fb914c8eb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00168.html#acfd74483ff523213b78f44fb914c8eb4">grow_by</a> (I first, I last)</td></tr>
<tr class="separator:acfd74483ff523213b78f44fb914c8eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f57f1529e0ebd1ca6bd2d60003fcab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a95f57f1529e0ebd1ca6bd2d60003fcab">grow_by</a> (std::initializer_list&lt; T &gt; init_list)</td></tr>
<tr class="separator:a95f57f1529e0ebd1ca6bd2d60003fcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ef9895e88f9bf036b379035c18f035"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#ae9ef9895e88f9bf036b379035c18f035">grow_to_at_least</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n)</td></tr>
<tr class="memdesc:ae9ef9895e88f9bf036b379035c18f035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append minimal sequence of elements such that <a class="el" href="a00168.html#a803268c16e3688ff4681251947d257c7" title="Return size of vector. It may include elements under construction. ">size()</a>&gt;=n.  <a href="#ae9ef9895e88f9bf036b379035c18f035">More...</a><br /></td></tr>
<tr class="separator:ae9ef9895e88f9bf036b379035c18f035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422d9689ed72a5ef2b6b72f28e4143a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a422d9689ed72a5ef2b6b72f28e4143a2">grow_to_at_least</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n, <a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a> t)</td></tr>
<tr class="separator:a422d9689ed72a5ef2b6b72f28e4143a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68d1675fedef232bfae35f200ba007d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#ad68d1675fedef232bfae35f200ba007d">push_back</a> (<a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a> item)</td></tr>
<tr class="memdesc:ad68d1675fedef232bfae35f200ba007d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push item.  <a href="#ad68d1675fedef232bfae35f200ba007d">More...</a><br /></td></tr>
<tr class="separator:ad68d1675fedef232bfae35f200ba007d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29a9f08c0fac7c20786c7b8f4f0321a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#ac29a9f08c0fac7c20786c7b8f4f0321a">push_back</a> (T &amp;&amp;item)</td></tr>
<tr class="memdesc:ac29a9f08c0fac7c20786c7b8f4f0321a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push item, move-aware.  <a href="#ac29a9f08c0fac7c20786c7b8f4f0321a">More...</a><br /></td></tr>
<tr class="separator:ac29a9f08c0fac7c20786c7b8f4f0321a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae4c378515b89cc2b0a11c8cf1bcc50"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:afae4c378515b89cc2b0a11c8cf1bcc50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00168.html#afae4c378515b89cc2b0a11c8cf1bcc50">emplace_back</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:afae4c378515b89cc2b0a11c8cf1bcc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push item, create item "in place" with provided arguments.  <a href="#afae4c378515b89cc2b0a11c8cf1bcc50">More...</a><br /></td></tr>
<tr class="separator:afae4c378515b89cc2b0a11c8cf1bcc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3097cb46511504acfc9de7da5235f4a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a412441e93ad8656f96b14c5ecb9d817f">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a3097cb46511504acfc9de7da5235f4a6">operator[]</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> index)</td></tr>
<tr class="memdesc:a3097cb46511504acfc9de7da5235f4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reference to element at given index.  <a href="#a3097cb46511504acfc9de7da5235f4a6">More...</a><br /></td></tr>
<tr class="separator:a3097cb46511504acfc9de7da5235f4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6ca67f2f97fafca48395af2e693e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#abd6ca67f2f97fafca48395af2e693e73">operator[]</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> index) const </td></tr>
<tr class="memdesc:abd6ca67f2f97fafca48395af2e693e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get const reference to element at given index.  <a href="#abd6ca67f2f97fafca48395af2e693e73">More...</a><br /></td></tr>
<tr class="separator:abd6ca67f2f97fafca48395af2e693e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629a29eb21e528414b9d5c9becfe05cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a412441e93ad8656f96b14c5ecb9d817f">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a629a29eb21e528414b9d5c9becfe05cd">at</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> index)</td></tr>
<tr class="memdesc:a629a29eb21e528414b9d5c9becfe05cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reference to element at given index. Throws exceptions on errors.  <a href="#a629a29eb21e528414b9d5c9becfe05cd">More...</a><br /></td></tr>
<tr class="separator:a629a29eb21e528414b9d5c9becfe05cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dc6c1b55c0e0b73f0a8675ef2b60a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#ae4dc6c1b55c0e0b73f0a8675ef2b60a4">at</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> index) const </td></tr>
<tr class="memdesc:ae4dc6c1b55c0e0b73f0a8675ef2b60a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get const reference to element at given index. Throws exceptions on errors.  <a href="#ae4dc6c1b55c0e0b73f0a8675ef2b60a4">More...</a><br /></td></tr>
<tr class="separator:ae4dc6c1b55c0e0b73f0a8675ef2b60a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8201f65735edcc28aeec95b6e73d75b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a443492ee9918c9e3372b5daca82314ca">range_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a8201f65735edcc28aeec95b6e73d75b6">range</a> (size_t grainsize=1)</td></tr>
<tr class="memdesc:a8201f65735edcc28aeec95b6e73d75b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get range for iterating with parallel algorithms.  <a href="#a8201f65735edcc28aeec95b6e73d75b6">More...</a><br /></td></tr>
<tr class="separator:a8201f65735edcc28aeec95b6e73d75b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcc32ec9ccb48c3327a88fe288c7538"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a1312eb29abf7ca07aa365c727b7844e3">const_range_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a8fcc32ec9ccb48c3327a88fe288c7538">range</a> (size_t grainsize=1) const </td></tr>
<tr class="memdesc:a8fcc32ec9ccb48c3327a88fe288c7538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get const range for iterating with parallel algorithms.  <a href="#a8fcc32ec9ccb48c3327a88fe288c7538">More...</a><br /></td></tr>
<tr class="separator:a8fcc32ec9ccb48c3327a88fe288c7538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803268c16e3688ff4681251947d257c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a803268c16e3688ff4681251947d257c7">size</a> () const </td></tr>
<tr class="memdesc:a803268c16e3688ff4681251947d257c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size of vector. It may include elements under construction.  <a href="#a803268c16e3688ff4681251947d257c7">More...</a><br /></td></tr>
<tr class="separator:a803268c16e3688ff4681251947d257c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f6774107e65642f73c0dcc9a962fe7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#aa3f6774107e65642f73c0dcc9a962fe7">empty</a> () const </td></tr>
<tr class="memdesc:aa3f6774107e65642f73c0dcc9a962fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return false if vector is not empty or has elements under construction at least.  <a href="#aa3f6774107e65642f73c0dcc9a962fe7">More...</a><br /></td></tr>
<tr class="separator:aa3f6774107e65642f73c0dcc9a962fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c2ae9dfedc24d62554feb627df76c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a96c2ae9dfedc24d62554feb627df76c3">capacity</a> () const </td></tr>
<tr class="memdesc:a96c2ae9dfedc24d62554feb627df76c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size to which array can grow without allocating more memory. Concurrent allocations are not included in the value.  <a href="#a96c2ae9dfedc24d62554feb627df76c3">More...</a><br /></td></tr>
<tr class="separator:a96c2ae9dfedc24d62554feb627df76c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3284684328c58c0228c9a697ef3594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a0b3284684328c58c0228c9a697ef3594">reserve</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n)</td></tr>
<tr class="memdesc:a0b3284684328c58c0228c9a697ef3594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate enough space to grow to size n without having to allocate more memory later.  <a href="#a0b3284684328c58c0228c9a697ef3594">More...</a><br /></td></tr>
<tr class="separator:a0b3284684328c58c0228c9a697ef3594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e53a98a1e1fdb515fdc2b84e2314e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a65e53a98a1e1fdb515fdc2b84e2314e8">resize</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n)</td></tr>
<tr class="memdesc:a65e53a98a1e1fdb515fdc2b84e2314e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the vector. Not thread-safe.  <a href="#a65e53a98a1e1fdb515fdc2b84e2314e8">More...</a><br /></td></tr>
<tr class="separator:a65e53a98a1e1fdb515fdc2b84e2314e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941917a8a840ff08ce8810ca9476ff46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a941917a8a840ff08ce8810ca9476ff46">resize</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n, <a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a> t)</td></tr>
<tr class="memdesc:a941917a8a840ff08ce8810ca9476ff46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the vector, copy t for new elements. Not thread-safe.  <a href="#a941917a8a840ff08ce8810ca9476ff46">More...</a><br /></td></tr>
<tr class="separator:a941917a8a840ff08ce8810ca9476ff46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba805b5225ad3399550f78ea15e51e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#aba805b5225ad3399550f78ea15e51e93">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:aba805b5225ad3399550f78ea15e51e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize memory usage and fragmentation.  <a href="#aba805b5225ad3399550f78ea15e51e93">More...</a><br /></td></tr>
<tr class="separator:aba805b5225ad3399550f78ea15e51e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec9c3ab3360e04bdaa5174956a3206d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">max_size</a> () const </td></tr>
<tr class="memdesc:a0ec9c3ab3360e04bdaa5174956a3206d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper bound on argument to reserve.  <a href="#a0ec9c3ab3360e04bdaa5174956a3206d">More...</a><br /></td></tr>
<tr class="separator:a0ec9c3ab3360e04bdaa5174956a3206d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55636c80368ad7d400f3200313fcf5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">begin</a> ()</td></tr>
<tr class="memdesc:ab55636c80368ad7d400f3200313fcf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">start iterator  <a href="#ab55636c80368ad7d400f3200313fcf5f">More...</a><br /></td></tr>
<tr class="separator:ab55636c80368ad7d400f3200313fcf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2c07653375e4a5f89c33b375eda610"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#aad2c07653375e4a5f89c33b375eda610">end</a> ()</td></tr>
<tr class="memdesc:aad2c07653375e4a5f89c33b375eda610"><td class="mdescLeft">&#160;</td><td class="mdescRight">end iterator  <a href="#aad2c07653375e4a5f89c33b375eda610">More...</a><br /></td></tr>
<tr class="separator:aad2c07653375e4a5f89c33b375eda610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3eb33d1b10a988a87cc708ceb08f3a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#ad3eb33d1b10a988a87cc708ceb08f3a9">begin</a> () const </td></tr>
<tr class="memdesc:ad3eb33d1b10a988a87cc708ceb08f3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">start const iterator  <a href="#ad3eb33d1b10a988a87cc708ceb08f3a9">More...</a><br /></td></tr>
<tr class="separator:ad3eb33d1b10a988a87cc708ceb08f3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4ad0795a19d94df24595e748f0b193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a6a4ad0795a19d94df24595e748f0b193">end</a> () const </td></tr>
<tr class="memdesc:a6a4ad0795a19d94df24595e748f0b193"><td class="mdescLeft">&#160;</td><td class="mdescRight">end const iterator  <a href="#a6a4ad0795a19d94df24595e748f0b193">More...</a><br /></td></tr>
<tr class="separator:a6a4ad0795a19d94df24595e748f0b193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1c5441fa480c07ef37d9206b6260cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a7a1c5441fa480c07ef37d9206b6260cc">cbegin</a> () const </td></tr>
<tr class="memdesc:a7a1c5441fa480c07ef37d9206b6260cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">start const iterator  <a href="#a7a1c5441fa480c07ef37d9206b6260cc">More...</a><br /></td></tr>
<tr class="separator:a7a1c5441fa480c07ef37d9206b6260cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea80faf139feb54d6576c036e4ba898"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a9ea80faf139feb54d6576c036e4ba898">cend</a> () const </td></tr>
<tr class="memdesc:a9ea80faf139feb54d6576c036e4ba898"><td class="mdescLeft">&#160;</td><td class="mdescRight">end const iterator  <a href="#a9ea80faf139feb54d6576c036e4ba898">More...</a><br /></td></tr>
<tr class="separator:a9ea80faf139feb54d6576c036e4ba898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2f8dce0adcbef8e29273c23723a78e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a1623110816f9ef8f08e7bf6768aed273">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a9a2f8dce0adcbef8e29273c23723a78e">rbegin</a> ()</td></tr>
<tr class="memdesc:a9a2f8dce0adcbef8e29273c23723a78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse start iterator  <a href="#a9a2f8dce0adcbef8e29273c23723a78e">More...</a><br /></td></tr>
<tr class="separator:a9a2f8dce0adcbef8e29273c23723a78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618f38279a370c18f73ea2c29ded9cb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a1623110816f9ef8f08e7bf6768aed273">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a618f38279a370c18f73ea2c29ded9cb9">rend</a> ()</td></tr>
<tr class="memdesc:a618f38279a370c18f73ea2c29ded9cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse end iterator  <a href="#a618f38279a370c18f73ea2c29ded9cb9">More...</a><br /></td></tr>
<tr class="separator:a618f38279a370c18f73ea2c29ded9cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976b0bed19de9ab93f78c10184a4e38f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#ada43b048144c3814036da624d3bb8c58">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a976b0bed19de9ab93f78c10184a4e38f">rbegin</a> () const </td></tr>
<tr class="memdesc:a976b0bed19de9ab93f78c10184a4e38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse start const iterator  <a href="#a976b0bed19de9ab93f78c10184a4e38f">More...</a><br /></td></tr>
<tr class="separator:a976b0bed19de9ab93f78c10184a4e38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb98e17cb65d9c445d7fd1e662c2699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#ada43b048144c3814036da624d3bb8c58">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#abdb98e17cb65d9c445d7fd1e662c2699">rend</a> () const </td></tr>
<tr class="memdesc:abdb98e17cb65d9c445d7fd1e662c2699"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse end const iterator  <a href="#abdb98e17cb65d9c445d7fd1e662c2699">More...</a><br /></td></tr>
<tr class="separator:abdb98e17cb65d9c445d7fd1e662c2699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2627db4a7949522ea4727320b23a6348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#ada43b048144c3814036da624d3bb8c58">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a2627db4a7949522ea4727320b23a6348">crbegin</a> () const </td></tr>
<tr class="memdesc:a2627db4a7949522ea4727320b23a6348"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse start const iterator  <a href="#a2627db4a7949522ea4727320b23a6348">More...</a><br /></td></tr>
<tr class="separator:a2627db4a7949522ea4727320b23a6348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad097225c529dbb24cc0e13a444ab4752"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#ada43b048144c3814036da624d3bb8c58">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#ad097225c529dbb24cc0e13a444ab4752">crend</a> () const </td></tr>
<tr class="memdesc:ad097225c529dbb24cc0e13a444ab4752"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse end const iterator  <a href="#ad097225c529dbb24cc0e13a444ab4752">More...</a><br /></td></tr>
<tr class="separator:ad097225c529dbb24cc0e13a444ab4752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfc6d733cf543280b691ed8d7b7908a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a412441e93ad8656f96b14c5ecb9d817f">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a9bfc6d733cf543280b691ed8d7b7908a">front</a> ()</td></tr>
<tr class="memdesc:a9bfc6d733cf543280b691ed8d7b7908a"><td class="mdescLeft">&#160;</td><td class="mdescRight">the first item  <a href="#a9bfc6d733cf543280b691ed8d7b7908a">More...</a><br /></td></tr>
<tr class="separator:a9bfc6d733cf543280b691ed8d7b7908a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9067259572c2c41d014840d0f9d3cdce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a9067259572c2c41d014840d0f9d3cdce">front</a> () const </td></tr>
<tr class="memdesc:a9067259572c2c41d014840d0f9d3cdce"><td class="mdescLeft">&#160;</td><td class="mdescRight">the first item const  <a href="#a9067259572c2c41d014840d0f9d3cdce">More...</a><br /></td></tr>
<tr class="separator:a9067259572c2c41d014840d0f9d3cdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee3ddf1d05238a8a6887f6d824b76f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a412441e93ad8656f96b14c5ecb9d817f">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#aaee3ddf1d05238a8a6887f6d824b76f8">back</a> ()</td></tr>
<tr class="memdesc:aaee3ddf1d05238a8a6887f6d824b76f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">the last item  <a href="#aaee3ddf1d05238a8a6887f6d824b76f8">More...</a><br /></td></tr>
<tr class="separator:aaee3ddf1d05238a8a6887f6d824b76f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf66eb1e82dbcb430d9926a23711c720"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#acf66eb1e82dbcb430d9926a23711c720">back</a> () const </td></tr>
<tr class="memdesc:acf66eb1e82dbcb430d9926a23711c720"><td class="mdescLeft">&#160;</td><td class="mdescRight">the last item const  <a href="#acf66eb1e82dbcb430d9926a23711c720">More...</a><br /></td></tr>
<tr class="separator:acf66eb1e82dbcb430d9926a23711c720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b62a9614d3f2b59c9c7c1a2143fb1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a88b62a9614d3f2b59c9c7c1a2143fb1e">get_allocator</a> () const </td></tr>
<tr class="memdesc:a88b62a9614d3f2b59c9c7c1a2143fb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return allocator object  <a href="#a88b62a9614d3f2b59c9c7c1a2143fb1e">More...</a><br /></td></tr>
<tr class="separator:a88b62a9614d3f2b59c9c7c1a2143fb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87355dce93d0882aa73333a35c9b367c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a87355dce93d0882aa73333a35c9b367c">assign</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n, <a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a> t)</td></tr>
<tr class="memdesc:a87355dce93d0882aa73333a35c9b367c"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign n items by copying t item  <a href="#a87355dce93d0882aa73333a35c9b367c">More...</a><br /></td></tr>
<tr class="separator:a87355dce93d0882aa73333a35c9b367c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb5399a8499f88cf859eab39f0ed9e0"><td class="memTemplParams" colspan="2">template&lt;class I &gt; </td></tr>
<tr class="memitem:a7bb5399a8499f88cf859eab39f0ed9e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00168.html#a7bb5399a8499f88cf859eab39f0ed9e0">assign</a> (I first, I last)</td></tr>
<tr class="memdesc:a7bb5399a8499f88cf859eab39f0ed9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign range [first, last)  <a href="#a7bb5399a8499f88cf859eab39f0ed9e0">More...</a><br /></td></tr>
<tr class="separator:a7bb5399a8499f88cf859eab39f0ed9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584d6cda5794441b19d4f02bde399dff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a584d6cda5794441b19d4f02bde399dff">assign</a> (std::initializer_list&lt; T &gt; init_list)</td></tr>
<tr class="memdesc:a584d6cda5794441b19d4f02bde399dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">assigns an initializer list  <a href="#a584d6cda5794441b19d4f02bde399dff">More...</a><br /></td></tr>
<tr class="separator:a584d6cda5794441b19d4f02bde399dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8603bd57324fb6b60ba006884c95279d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a8603bd57324fb6b60ba006884c95279d">swap</a> (<a class="el" href="a00168.html">concurrent_vector</a> &amp;vector)</td></tr>
<tr class="memdesc:a8603bd57324fb6b60ba006884c95279d"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap two instances  <a href="#a8603bd57324fb6b60ba006884c95279d">More...</a><br /></td></tr>
<tr class="separator:a8603bd57324fb6b60ba006884c95279d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526ba408fb3064ef846940d633b8f365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a526ba408fb3064ef846940d633b8f365">clear</a> ()</td></tr>
<tr class="memdesc:a526ba408fb3064ef846940d633b8f365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear container while keeping memory allocated.  <a href="#a526ba408fb3064ef846940d633b8f365">More...</a><br /></td></tr>
<tr class="separator:a526ba408fb3064ef846940d633b8f365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bcaededc9a00e7aaecd6c262fd0b38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#ab5bcaededc9a00e7aaecd6c262fd0b38">~concurrent_vector</a> ()</td></tr>
<tr class="memdesc:ab5bcaededc9a00e7aaecd6c262fd0b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear and destroy vector.  <a href="#ab5bcaededc9a00e7aaecd6c262fd0b38">More...</a><br /></td></tr>
<tr class="separator:ab5bcaededc9a00e7aaecd6c262fd0b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675f1b62a651d350eb0d778a271e31e5"><td class="memItemLeft" align="right" valign="top">const internal::concurrent_vector_base_v3 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a675f1b62a651d350eb0d778a271e31e5">internal_vector_base</a> () const </td></tr>
<tr class="separator:a675f1b62a651d350eb0d778a271e31e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e2626d160361d8c6f4193ca0c7a4dd"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a96e2626d160361d8c6f4193ca0c7a4dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00168.html#a96e2626d160361d8c6f4193ca0c7a4dd">copy_range</a> (<a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *dst, const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *p_type_erased_iterator, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n)</td></tr>
<tr class="separator:a96e2626d160361d8c6f4193ca0c7a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a496efbef33d4076867c075c67793aa6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a496efbef33d4076867c075c67793aa6c">internal_free_segments</a> (<a class="el" href="a00696.html">segment_t</a> table[], <a class="el" href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">segment_index_t</a> k, <a class="el" href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">segment_index_t</a> first_block)</td></tr>
<tr class="memdesc:a496efbef33d4076867c075c67793aa6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free k segments from table.  <a href="#a496efbef33d4076867c075c67793aa6c">More...</a><br /></td></tr>
<tr class="separator:a496efbef33d4076867c075c67793aa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea8843a774a9f52a47e6661fccbde19"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a4ea8843a774a9f52a47e6661fccbde19">internal_subscript</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> index) const </td></tr>
<tr class="memdesc:a4ea8843a774a9f52a47e6661fccbde19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reference to element at given index.  <a href="#a4ea8843a774a9f52a47e6661fccbde19">More...</a><br /></td></tr>
<tr class="separator:a4ea8843a774a9f52a47e6661fccbde19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc22450ffcfb9d0b946f89869ca0c894"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#abc22450ffcfb9d0b946f89869ca0c894">internal_subscript_with_exceptions</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> index) const </td></tr>
<tr class="memdesc:abc22450ffcfb9d0b946f89869ca0c894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reference to element at given index with errors checks.  <a href="#abc22450ffcfb9d0b946f89869ca0c894">More...</a><br /></td></tr>
<tr class="separator:abc22450ffcfb9d0b946f89869ca0c894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb56cca0338422a9884cf8d756fb89d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a4eb56cca0338422a9884cf8d756fb89d">internal_assign_n</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n, <a class="el" href="a00168.html#afa0d28eb686589cbaf4733ca0eabc071">const_pointer</a> <a class="el" href="a01016.html#ae01354a6a694c51fb79588444a08cbee">p</a>)</td></tr>
<tr class="memdesc:a4eb56cca0338422a9884cf8d756fb89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign n items by copying t  <a href="#a4eb56cca0338422a9884cf8d756fb89d">More...</a><br /></td></tr>
<tr class="separator:a4eb56cca0338422a9884cf8d756fb89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874a5d44cc3dc7c4b67b3b52b8fc4bff"><td class="memTemplParams" colspan="2">template&lt;class I &gt; </td></tr>
<tr class="memitem:a874a5d44cc3dc7c4b67b3b52b8fc4bff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00168.html#a874a5d44cc3dc7c4b67b3b52b8fc4bff">internal_assign_range</a> (I first, I last, <a class="el" href="a00398.html">is_integer_tag</a>&lt; true &gt; *)</td></tr>
<tr class="memdesc:a874a5d44cc3dc7c4b67b3b52b8fc4bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign integer items by copying when arguments are treated as iterators. See C++ Standard 2003 23.1.1p9  <a href="#a874a5d44cc3dc7c4b67b3b52b8fc4bff">More...</a><br /></td></tr>
<tr class="separator:a874a5d44cc3dc7c4b67b3b52b8fc4bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1027eaca45b3f1f94a6db760ecb1a2c6"><td class="memTemplParams" colspan="2">template&lt;class I &gt; </td></tr>
<tr class="memitem:a1027eaca45b3f1f94a6db760ecb1a2c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00168.html#a1027eaca45b3f1f94a6db760ecb1a2c6">internal_assign_range</a> (I first, I last, <a class="el" href="a00398.html">is_integer_tag</a>&lt; false &gt; *)</td></tr>
<tr class="memdesc:a1027eaca45b3f1f94a6db760ecb1a2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline proxy assign by iterators  <a href="#a1027eaca45b3f1f94a6db760ecb1a2c6">More...</a><br /></td></tr>
<tr class="separator:a1027eaca45b3f1f94a6db760ecb1a2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebff613825ded62ed4648117829f5942"><td class="memTemplParams" colspan="2">template&lt;class I &gt; </td></tr>
<tr class="memitem:aebff613825ded62ed4648117829f5942"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00168.html#aebff613825ded62ed4648117829f5942">internal_assign_iterators</a> (I first, I last)</td></tr>
<tr class="memdesc:aebff613825ded62ed4648117829f5942"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign by iterators  <a href="#aebff613825ded62ed4648117829f5942">More...</a><br /></td></tr>
<tr class="separator:aebff613825ded62ed4648117829f5942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a00169"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00169')"><img src="closed.png" alt="-"/>&#160;Private Member Functions inherited from <a class="el" href="a00169.html">tbb::internal::concurrent_vector_base_v3</a></td></tr>
<tr class="memitem:a76e573e95d96877edbac7c02eaa08601 inherit pub_methods_a00169"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a76e573e95d96877edbac7c02eaa08601">concurrent_vector_base_v3</a> ()</td></tr>
<tr class="separator:a76e573e95d96877edbac7c02eaa08601 inherit pub_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01734e9de5b19fa4521cae624508b1a inherit pub_methods_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01098.html#a7a1df7e6f83415a1624716541dc4b741">__TBB_EXPORTED_METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#ad01734e9de5b19fa4521cae624508b1a">~concurrent_vector_base_v3</a> ()</td></tr>
<tr class="separator:ad01734e9de5b19fa4521cae624508b1a inherit pub_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07413aa0de51aeb5ec1ec35bbc0095f inherit pub_methods_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01098.html#a7a1df7e6f83415a1624716541dc4b741">__TBB_EXPORTED_METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#ae07413aa0de51aeb5ec1ec35bbc0095f">internal_reserve</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> element_size, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> max_size)</td></tr>
<tr class="separator:ae07413aa0de51aeb5ec1ec35bbc0095f inherit pub_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa358b781e8b59f324feba96f76f05757 inherit pub_methods_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> <a class="el" href="a01098.html#a7a1df7e6f83415a1624716541dc4b741">__TBB_EXPORTED_METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#aa358b781e8b59f324feba96f76f05757">internal_capacity</a> () const </td></tr>
<tr class="separator:aa358b781e8b59f324feba96f76f05757 inherit pub_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c8c2a7341dc8ea7a612341e27cb24e inherit pub_methods_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a62c8c2a7341dc8ea7a612341e27cb24e">internal_grow</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> start, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> finish, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> element_size, <a class="el" href="a00169.html#a4da4a55fd0545d1b669ca5cc49cd5308">internal_array_op2</a> init, const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *src)</td></tr>
<tr class="separator:a62c8c2a7341dc8ea7a612341e27cb24e inherit pub_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9334b74e81786c565f413134cf28b559 inherit pub_methods_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> <a class="el" href="a01098.html#a7a1df7e6f83415a1624716541dc4b741">__TBB_EXPORTED_METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a9334b74e81786c565f413134cf28b559">internal_grow_by</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> delta, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> element_size, <a class="el" href="a00169.html#a4da4a55fd0545d1b669ca5cc49cd5308">internal_array_op2</a> init, const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *src)</td></tr>
<tr class="separator:a9334b74e81786c565f413134cf28b559 inherit pub_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd7a3ced949af1191abe1ef5786f4f3 inherit pub_methods_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *<a class="el" href="a01098.html#a7a1df7e6f83415a1624716541dc4b741">__TBB_EXPORTED_METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a4bd7a3ced949af1191abe1ef5786f4f3">internal_push_back</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> element_size, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> &amp;index)</td></tr>
<tr class="separator:a4bd7a3ced949af1191abe1ef5786f4f3 inherit pub_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ab12f2be0114336e7bb0c291e611a2 inherit pub_methods_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">segment_index_t</a> <a class="el" href="a01098.html#a7a1df7e6f83415a1624716541dc4b741">__TBB_EXPORTED_METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">internal_clear</a> (<a class="el" href="a00169.html#ad7c52f713ea60b5771a0de1bdde7e7a9">internal_array_op1</a> destroy)</td></tr>
<tr class="separator:aa8ab12f2be0114336e7bb0c291e611a2 inherit pub_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aa29982c8e7708d413f1d30c5953e6 inherit pub_methods_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *<a class="el" href="a01098.html#a7a1df7e6f83415a1624716541dc4b741">__TBB_EXPORTED_METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a01aa29982c8e7708d413f1d30c5953e6">internal_compact</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> element_size, <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *table, <a class="el" href="a00169.html#ad7c52f713ea60b5771a0de1bdde7e7a9">internal_array_op1</a> destroy, <a class="el" href="a00169.html#a4da4a55fd0545d1b669ca5cc49cd5308">internal_array_op2</a> copy)</td></tr>
<tr class="separator:a01aa29982c8e7708d413f1d30c5953e6 inherit pub_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dff324e332e7b4df6dd933f0af0fb2 inherit pub_methods_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01098.html#a7a1df7e6f83415a1624716541dc4b741">__TBB_EXPORTED_METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#af0dff324e332e7b4df6dd933f0af0fb2">internal_copy</a> (const <a class="el" href="a00169.html">concurrent_vector_base_v3</a> &amp;src, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> element_size, <a class="el" href="a00169.html#a4da4a55fd0545d1b669ca5cc49cd5308">internal_array_op2</a> copy)</td></tr>
<tr class="separator:af0dff324e332e7b4df6dd933f0af0fb2 inherit pub_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de722203d5e6cb6a18075e451417664 inherit pub_methods_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01098.html#a7a1df7e6f83415a1624716541dc4b741">__TBB_EXPORTED_METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a2de722203d5e6cb6a18075e451417664">internal_assign</a> (const <a class="el" href="a00169.html">concurrent_vector_base_v3</a> &amp;src, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> element_size, <a class="el" href="a00169.html#ad7c52f713ea60b5771a0de1bdde7e7a9">internal_array_op1</a> destroy, <a class="el" href="a00169.html#a4da4a55fd0545d1b669ca5cc49cd5308">internal_array_op2</a> assign, <a class="el" href="a00169.html#a4da4a55fd0545d1b669ca5cc49cd5308">internal_array_op2</a> copy)</td></tr>
<tr class="separator:a2de722203d5e6cb6a18075e451417664 inherit pub_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bd255e3a4b2baa7ed51f6fe7ba0ece inherit pub_methods_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01098.html#a7a1df7e6f83415a1624716541dc4b741">__TBB_EXPORTED_METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a20bd255e3a4b2baa7ed51f6fe7ba0ece">internal_throw_exception</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>) const </td></tr>
<tr class="memdesc:a20bd255e3a4b2baa7ed51f6fe7ba0ece inherit pub_methods_a00169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obsolete.  <a href="#a20bd255e3a4b2baa7ed51f6fe7ba0ece">More...</a><br /></td></tr>
<tr class="separator:a20bd255e3a4b2baa7ed51f6fe7ba0ece inherit pub_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5913c17dffae92a75f8c1c3caaa7ecf6 inherit pub_methods_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01098.html#a7a1df7e6f83415a1624716541dc4b741">__TBB_EXPORTED_METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a5913c17dffae92a75f8c1c3caaa7ecf6">internal_swap</a> (<a class="el" href="a00169.html">concurrent_vector_base_v3</a> &amp;v)</td></tr>
<tr class="separator:a5913c17dffae92a75f8c1c3caaa7ecf6 inherit pub_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57151343a7f7c09dfc70bad5f149c417 inherit pub_methods_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01098.html#a7a1df7e6f83415a1624716541dc4b741">__TBB_EXPORTED_METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a57151343a7f7c09dfc70bad5f149c417">internal_resize</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> element_size, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> max_size, const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *src, <a class="el" href="a00169.html#ad7c52f713ea60b5771a0de1bdde7e7a9">internal_array_op1</a> destroy, <a class="el" href="a00169.html#a4da4a55fd0545d1b669ca5cc49cd5308">internal_array_op2</a> init)</td></tr>
<tr class="separator:a57151343a7f7c09dfc70bad5f149c417 inherit pub_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558417c6b3314944dfa6182db71841e3 inherit pub_methods_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> <a class="el" href="a01098.html#a7a1df7e6f83415a1624716541dc4b741">__TBB_EXPORTED_METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a558417c6b3314944dfa6182db71841e3">internal_grow_to_at_least_with_result</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> <a class="el" href="a01016.html#a0ff2395a84e0714023e69b0ff3d7363b">new_size</a>, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> element_size, <a class="el" href="a00169.html#a4da4a55fd0545d1b669ca5cc49cd5308">internal_array_op2</a> init, const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *src)</td></tr>
<tr class="separator:a558417c6b3314944dfa6182db71841e3 inherit pub_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d25fbe67e3ac09ab5c05bfb9963854 inherit pub_methods_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01098.html#a7a1df7e6f83415a1624716541dc4b741">__TBB_EXPORTED_METHOD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#ae9d25fbe67e3ac09ab5c05bfb9963854">internal_grow_to_at_least</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> <a class="el" href="a01016.html#a0ff2395a84e0714023e69b0ff3d7363b">new_size</a>, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> element_size, <a class="el" href="a00169.html#a4da4a55fd0545d1b669ca5cc49cd5308">internal_array_op2</a> init, const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *src)</td></tr>
<tr class="memdesc:ae9d25fbe67e3ac09ab5c05bfb9963854 inherit pub_methods_a00169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated entry point for backwards compatibility to TBB 2.1.  <a href="#ae9d25fbe67e3ac09ab5c05bfb9963854">More...</a><br /></td></tr>
<tr class="separator:ae9d25fbe67e3ac09ab5c05bfb9963854 inherit pub_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aa8d78091cca57343f1bd59026c9a9da6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">internal_allocator</a> (internal::concurrent_vector_base_v3 &amp;vb, size_t k)</td></tr>
<tr class="memdesc:aa8d78091cca57343f1bd59026c9a9da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate k items.  <a href="#aa8d78091cca57343f1bd59026c9a9da6">More...</a><br /></td></tr>
<tr class="separator:aa8d78091cca57343f1bd59026c9a9da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b1a671033a824c0027720427072328"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01084.html#ab6dd3eee12dcbf8bc4c41513c4c4c9fb">__TBB_EXPORTED_FUNC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a12b1a671033a824c0027720427072328">initialize_array</a> (<a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *<a class="el" href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">begin</a>, const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n)</td></tr>
<tr class="memdesc:a12b1a671033a824c0027720427072328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct n instances of T, starting at "begin".  <a href="#a12b1a671033a824c0027720427072328">More...</a><br /></td></tr>
<tr class="separator:a12b1a671033a824c0027720427072328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615b7ebb3f9219014924b523c44e085e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01084.html#ab6dd3eee12dcbf8bc4c41513c4c4c9fb">__TBB_EXPORTED_FUNC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a615b7ebb3f9219014924b523c44e085e">initialize_array_by</a> (<a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *<a class="el" href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">begin</a>, const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *src, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n)</td></tr>
<tr class="memdesc:a615b7ebb3f9219014924b523c44e085e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-construct n instances of T, starting at "begin".  <a href="#a615b7ebb3f9219014924b523c44e085e">More...</a><br /></td></tr>
<tr class="separator:a615b7ebb3f9219014924b523c44e085e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cf2fd728e2a39dfc51ebe41ccc3779"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01084.html#ab6dd3eee12dcbf8bc4c41513c4c4c9fb">__TBB_EXPORTED_FUNC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a99cf2fd728e2a39dfc51ebe41ccc3779">copy_array</a> (<a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *dst, const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *src, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n)</td></tr>
<tr class="memdesc:a99cf2fd728e2a39dfc51ebe41ccc3779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-construct n instances of T by copying single element pointed to by src, starting at "dst".  <a href="#a99cf2fd728e2a39dfc51ebe41ccc3779">More...</a><br /></td></tr>
<tr class="separator:a99cf2fd728e2a39dfc51ebe41ccc3779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265a4e7d777baedfb71172dfcf0f980f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01084.html#ab6dd3eee12dcbf8bc4c41513c4c4c9fb">__TBB_EXPORTED_FUNC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a265a4e7d777baedfb71172dfcf0f980f">move_array</a> (<a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *dst, const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *src, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n)</td></tr>
<tr class="memdesc:a265a4e7d777baedfb71172dfcf0f980f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct n instances of T, starting at "dst" by copying according element of src array.  <a href="#a265a4e7d777baedfb71172dfcf0f980f">More...</a><br /></td></tr>
<tr class="separator:a265a4e7d777baedfb71172dfcf0f980f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34fa7579d0ffd5d97c375757283e01b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01084.html#ab6dd3eee12dcbf8bc4c41513c4c4c9fb">__TBB_EXPORTED_FUNC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#ae34fa7579d0ffd5d97c375757283e01b">move_assign_array</a> (<a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *dst, const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *src, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n)</td></tr>
<tr class="memdesc:ae34fa7579d0ffd5d97c375757283e01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assign (using operator=) n instances of T, starting at "dst" by assigning according element of src array.  <a href="#ae34fa7579d0ffd5d97c375757283e01b">More...</a><br /></td></tr>
<tr class="separator:ae34fa7579d0ffd5d97c375757283e01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a76288d24c088a9b751664f37d5c6e"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a85a76288d24c088a9b751664f37d5c6e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01084.html#ab6dd3eee12dcbf8bc4c41513c4c4c9fb">__TBB_EXPORTED_FUNC</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00168.html#a85a76288d24c088a9b751664f37d5c6e">copy_range</a> (<a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *dst, const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *p_type_erased_iterator, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n)</td></tr>
<tr class="memdesc:a85a76288d24c088a9b751664f37d5c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-construct n instances of T, starting at "dst" by iterator range of [p_type_erased_iterator, p_type_erased_iterator+n).  <a href="#a85a76288d24c088a9b751664f37d5c6e">More...</a><br /></td></tr>
<tr class="separator:a85a76288d24c088a9b751664f37d5c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c957884197e510b1d7176aaf4736a0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01084.html#ab6dd3eee12dcbf8bc4c41513c4c4c9fb">__TBB_EXPORTED_FUNC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a36c957884197e510b1d7176aaf4736a0">assign_array</a> (<a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *dst, const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *src, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n)</td></tr>
<tr class="memdesc:a36c957884197e510b1d7176aaf4736a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign (using operator=) n instances of T, starting at "dst" by assigning according element of src array.  <a href="#a36c957884197e510b1d7176aaf4736a0">More...</a><br /></td></tr>
<tr class="separator:a36c957884197e510b1d7176aaf4736a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c028b499fb365ba97f067bdcddb0d6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01084.html#ab6dd3eee12dcbf8bc4c41513c4c4c9fb">__TBB_EXPORTED_FUNC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a> (<a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *<a class="el" href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">begin</a>, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n)</td></tr>
<tr class="memdesc:a68c028b499fb365ba97f067bdcddb0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy n instances of T, starting at "begin".  <a href="#a68c028b499fb365ba97f067bdcddb0d6">More...</a><br /></td></tr>
<tr class="separator:a68c028b499fb365ba97f067bdcddb0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_a00169"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_a00169')"><img src="closed.png" alt="-"/>&#160;Static Private Member Functions inherited from <a class="el" href="a00169.html">tbb::internal::concurrent_vector_base_v3</a></td></tr>
<tr class="memitem:a151f683d14625c45aeccddba8ee72109 inherit pub_static_methods_a00169"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">segment_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a151f683d14625c45aeccddba8ee72109">segment_index_of</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> index)</td></tr>
<tr class="separator:a151f683d14625c45aeccddba8ee72109 inherit pub_static_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ddd84ac42ff56a1b390cc0eec513ea inherit pub_static_methods_a00169"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">segment_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a95ddd84ac42ff56a1b390cc0eec513ea">segment_base</a> (<a class="el" href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">segment_index_t</a> k)</td></tr>
<tr class="separator:a95ddd84ac42ff56a1b390cc0eec513ea inherit pub_static_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55fb14b17ddb920eaf50596446b9963 inherit pub_static_methods_a00169"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">segment_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#ac55fb14b17ddb920eaf50596446b9963">segment_base_index_of</a> (<a class="el" href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">segment_index_t</a> &amp;index)</td></tr>
<tr class="separator:ac55fb14b17ddb920eaf50596446b9963 inherit pub_static_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c3e198aae8f0a1128cf629c740988b inherit pub_static_methods_a00169"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a68c3e198aae8f0a1128cf629c740988b">segment_size</a> (<a class="el" href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">segment_index_t</a> k)</td></tr>
<tr class="separator:a68c3e198aae8f0a1128cf629c740988b inherit pub_static_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3d3fb0f6d82bccdce60828b271744b inherit pub_static_methods_a00169"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a2b3d3fb0f6d82bccdce60828b271744b">is_first_element_in_segment</a> (<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> element_index)</td></tr>
<tr class="separator:a2b3d3fb0f6d82bccdce60828b271744b inherit pub_static_methods_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a134b00c8dd9200b9e45fe81919c66b11"><td class="memTemplParams" colspan="2">template&lt;typename C , typename U &gt; </td></tr>
<tr class="memitem:a134b00c8dd9200b9e45fe81919c66b11"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00168.html#a134b00c8dd9200b9e45fe81919c66b11">internal::vector_iterator</a></td></tr>
<tr class="separator:a134b00c8dd9200b9e45fe81919c66b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_a00052"><td colspan="2" onclick="javascript:toggleInherit('pro_types_a00052')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="a00052.html">tbb::internal::allocator_base&lt; T, A &gt;</a></td></tr>
<tr class="memitem:a86c703781d0a1e1d4d98d20bf6319a8a inherit pro_types_a00052"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00053.html">tbb::internal::allocator_rebind</a>&lt; A, T &gt;::<a class="el" href="a01016.html#a1fcad32d6fbfbc9f0564e010c1aaddff">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a></td></tr>
<tr class="separator:a86c703781d0a1e1d4d98d20bf6319a8a inherit pro_types_a00052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_a00052"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_a00052')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="a00052.html">tbb::internal::allocator_base&lt; T, A &gt;</a></td></tr>
<tr class="memitem:a7dac91e76a575c83d729c32f892419c7 inherit pro_methods_a00052"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#a7dac91e76a575c83d729c32f892419c7">allocator_base</a> (const <a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> &amp;a=<a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a>())</td></tr>
<tr class="separator:a7dac91e76a575c83d729c32f892419c7 inherit pro_methods_a00052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_a00052"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_a00052')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="a00052.html">tbb::internal::allocator_base&lt; T, A &gt;</a></td></tr>
<tr class="memitem:a72f9ed5aac2cf597dc1e6c8e614173b3 inherit pro_attribs_a00052"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html#a72f9ed5aac2cf597dc1e6c8e614173b3">my_allocator</a></td></tr>
<tr class="separator:a72f9ed5aac2cf597dc1e6c8e614173b3 inherit pro_attribs_a00052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_a00169"><td colspan="2" onclick="javascript:toggleInherit('pub_types_a00169')"><img src="closed.png" alt="-"/>&#160;Private Types inherited from <a class="el" href="a00169.html">tbb::internal::concurrent_vector_base_v3</a></td></tr>
<tr class="memitem:abbb8fe2e97a84e53773124c2c0616977 inherit pub_types_a00169"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00169.html#abbb8fe2e97a84e53773124c2c0616977affd2c6f15c2e2b031fb7846d15a1fbc4">default_initial_segments</a> = 1, 
<a class="el" href="a00169.html#abbb8fe2e97a84e53773124c2c0616977a55596bdb0c771a285e87ab3645b78e23">pointers_per_short_table</a> = 3, 
<a class="el" href="a00169.html#abbb8fe2e97a84e53773124c2c0616977a66806961c962fd17c06f0a7d8b7fa6a9">pointers_per_long_table</a> = sizeof(segment_index_t) * 8
 }</td></tr>
<tr class="separator:abbb8fe2e97a84e53773124c2c0616977 inherit pub_types_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537b5a463d9131c3777e71d05fa3a81b inherit pub_types_a00169"><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">segment_index_t</a></td></tr>
<tr class="separator:a537b5a463d9131c3777e71d05fa3a81b inherit pub_types_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c92dcfc62079e447c41d2b772cdd133 inherit pub_types_a00169"><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a></td></tr>
<tr class="separator:a0c92dcfc62079e447c41d2b772cdd133 inherit pub_types_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c52f713ea60b5771a0de1bdde7e7a9 inherit pub_types_a00169"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>(<a class="el" href="a01084.html#ab6dd3eee12dcbf8bc4c41513c4c4c9fb">__TBB_EXPORTED_FUNC</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#ad7c52f713ea60b5771a0de1bdde7e7a9">internal_array_op1</a>) (<a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *<a class="el" href="a01016.html#a50deeaccd8b2b4be185e1befc7860258">begin</a>, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n)</td></tr>
<tr class="memdesc:ad7c52f713ea60b5771a0de1bdde7e7a9 inherit pub_types_a00169"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operation on an n-element array starting at begin.  <a href="#ad7c52f713ea60b5771a0de1bdde7e7a9">More...</a><br /></td></tr>
<tr class="separator:ad7c52f713ea60b5771a0de1bdde7e7a9 inherit pub_types_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da4a55fd0545d1b669ca5cc49cd5308 inherit pub_types_a00169"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>(<a class="el" href="a01084.html#ab6dd3eee12dcbf8bc4c41513c4c4c9fb">__TBB_EXPORTED_FUNC</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a4da4a55fd0545d1b669ca5cc49cd5308">internal_array_op2</a>) (<a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *dst, const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *src, <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> n)</td></tr>
<tr class="memdesc:a4da4a55fd0545d1b669ca5cc49cd5308 inherit pub_types_a00169"><td class="mdescLeft">&#160;</td><td class="mdescRight">An operation on n-element destination array and n-element source array.  <a href="#a4da4a55fd0545d1b669ca5cc49cd5308">More...</a><br /></td></tr>
<tr class="separator:a4da4a55fd0545d1b669ca5cc49cd5308 inherit pub_types_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_a00169"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_a00169')"><img src="closed.png" alt="-"/>&#160;Private Attributes inherited from <a class="el" href="a00169.html">tbb::internal::concurrent_vector_base_v3</a></td></tr>
<tr class="memitem:a21eea9a9f25b8d2345f9c5dd112ab7bd inherit pub_attribs_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">vector_allocator_ptr</a> )(<a class="el" href="a00169.html">concurrent_vector_base_v3</a> &amp;, size_t)</td></tr>
<tr class="memdesc:a21eea9a9f25b8d2345f9c5dd112ab7bd inherit pub_attribs_a00169"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator function pointer  <a href="#a21eea9a9f25b8d2345f9c5dd112ab7bd">More...</a><br /></td></tr>
<tr class="separator:a21eea9a9f25b8d2345f9c5dd112ab7bd inherit pub_attribs_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d3103757a1ef6a70a597d6b174d5c7 inherit pub_attribs_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00079.html">atomic</a>&lt; <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">my_first_block</a></td></tr>
<tr class="memdesc:ad9d3103757a1ef6a70a597d6b174d5c7 inherit pub_attribs_a00169"><td class="mdescLeft">&#160;</td><td class="mdescRight">count of segments in the first block  <a href="#ad9d3103757a1ef6a70a597d6b174d5c7">More...</a><br /></td></tr>
<tr class="separator:ad9d3103757a1ef6a70a597d6b174d5c7 inherit pub_attribs_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3773deae9ac723547700419690b043 inherit pub_attribs_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00079.html">atomic</a>&lt; <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#a1f3773deae9ac723547700419690b043">my_early_size</a></td></tr>
<tr class="memdesc:a1f3773deae9ac723547700419690b043 inherit pub_attribs_a00169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requested size of vector.  <a href="#a1f3773deae9ac723547700419690b043">More...</a><br /></td></tr>
<tr class="separator:a1f3773deae9ac723547700419690b043 inherit pub_attribs_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5232333cf13be4c77bdfe7282f7e14 inherit pub_attribs_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00079.html">atomic</a>&lt; <a class="el" href="a00696.html">segment_t</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a></td></tr>
<tr class="memdesc:acc5232333cf13be4c77bdfe7282f7e14 inherit pub_attribs_a00169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the segments table.  <a href="#acc5232333cf13be4c77bdfe7282f7e14">More...</a><br /></td></tr>
<tr class="separator:acc5232333cf13be4c77bdfe7282f7e14 inherit pub_attribs_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb52d25144f5cecc228e171f476cf91d inherit pub_attribs_a00169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00696.html">segment_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html#adb52d25144f5cecc228e171f476cf91d">my_storage</a> [<a class="el" href="a00169.html#abbb8fe2e97a84e53773124c2c0616977a55596bdb0c771a285e87ab3645b78e23">pointers_per_short_table</a>]</td></tr>
<tr class="memdesc:adb52d25144f5cecc228e171f476cf91d inherit pub_attribs_a00169"><td class="mdescLeft">&#160;</td><td class="mdescRight">embedded storage of segment pointers  <a href="#adb52d25144f5cecc228e171f476cf91d">More...</a><br /></td></tr>
<tr class="separator:adb52d25144f5cecc228e171f476cf91d inherit pub_attribs_a00169"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, class A&gt;<br />
class tbb::concurrent_vector&lt; T, A &gt;</h3>

<p>Concurrent vector container. </p>
<p><a class="el" href="a00168.html" title="Concurrent vector container. ">concurrent_vector</a> is a container having the following main properties:</p><ul>
<li>It provides random indexed access to its elements. The index of the first element is 0.</li>
<li>It ensures safe concurrent growing its size (different threads can safely append new elements).</li>
<li>Adding new elements does not invalidate existing iterators and does not change indices of existing items.</li>
</ul>
<dl class="section user"><dt>Compatibility</dt><dd>The class meets all Container Requirements and Reversible Container Requirements from C++ Standard (See ISO/IEC 14882:2003(E), clause 23.1). But it doesn't meet Sequence Requirements due to absence of insert() and erase() methods.</dd></dl>
<dl class="section user"><dt>Exception Safety</dt><dd>Methods working with memory allocation and/or new elements construction can throw an exception if allocator fails to allocate memory or element's default constructor throws one. Concurrent vector's element of type T must conform to the following requirements:<ul>
<li>Throwing an exception is forbidden for destructor of T.</li>
<li>Default constructor of T must not throw an exception OR its non-virtual destructor must safely work when its object memory is zero-initialized.</li>
</ul>
Otherwise, the program's behavior is undefined. </dd></dl>
<dl class="section user"><dt></dt><dd>If an exception happens inside growth or assignment operation, an instance of the vector becomes invalid unless it is stated otherwise in the method documentation. Invalid state means:<ul>
<li>There are no guarantees that all items were initialized by a constructor. The rest of items is zero-filled, including item where exception happens.</li>
<li>An invalid vector instance cannot be repaired; it is unable to grow anymore.</li>
<li>Size and capacity reported by the vector are incorrect, and calculated as if the failed operation were successful.</li>
<li>Attempt to access not allocated elements using operator[] or iterators results in access violation or segmentation fault exception, and in case of using <a class="el" href="a00168.html#a629a29eb21e528414b9d5c9becfe05cd" title="Get reference to element at given index. Throws exceptions on errors. ">at()</a> method a C++ exception is thrown.</li>
</ul>
If a concurrent grow operation successfully completes, all the elements it has added to the vector will remain valid and accessible even if one of subsequent grow operations fails.</dd></dl>
<dl class="section user"><dt>Fragmentation</dt><dd>Unlike an STL vector, a <a class="el" href="a00168.html" title="Concurrent vector container. ">concurrent_vector</a> does not move existing elements if it needs to allocate more memory. The container is divided into a series of contiguous arrays of elements. The first reservation, growth, or assignment operation determines the size of the first array. Using small number of elements as initial size incurs fragmentation that may increase element access time. Internal layout can be optimized by method compact() that merges several smaller arrays into one solid.</dd></dl>
<dl class="section user"><dt>Changes since TBB 2.1</dt><dd><ul>
<li>Fixed guarantees of <a class="el" href="a00168.html#a803268c16e3688ff4681251947d257c7" title="Return size of vector. It may include elements under construction. ">concurrent_vector::size()</a> and <a class="el" href="a00168.html#ae9ef9895e88f9bf036b379035c18f035" title="Append minimal sequence of elements such that size()&gt;=n. ">grow_to_at_least()</a> methods to assure elements are allocated.</li>
<li>Methods <a class="el" href="a00168.html#aad2c07653375e4a5f89c33b375eda610" title="end iterator ">end()</a>/rbegin()/back() are partly thread-safe since they use <a class="el" href="a00168.html#a803268c16e3688ff4681251947d257c7" title="Return size of vector. It may include elements under construction. ">size()</a> to get the end of vector</li>
<li>Added <a class="el" href="a00168.html#a65e53a98a1e1fdb515fdc2b84e2314e8" title="Resize the vector. Not thread-safe. ">resize()</a> methods (not thread-safe)</li>
<li>Added cbegin/cend/crbegin/crend methods</li>
<li>Changed return type of methods grow* and push_back to iterator</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Changes since TBB 2.0</dt><dd><ul>
<li>Implemented exception-safety guarantees</li>
<li>Added template argument for allocator</li>
<li>Added allocator argument in constructors</li>
<li>Faster index calculation</li>
<li>First growth call specifies a number of segments to be merged in the first allocation.</li>
<li>Fixed memory blow up for swarm of vector's instances of small size</li>
<li>Added <a class="el" href="a00168.html#aa11fc991cda82cf93789fce31b37a16c" title="Grow by &quot;delta&quot; elements using copying constructor. ">grow_by(size_type n, const_reference t)</a> growth using copying constructor to init new items.</li>
<li>Added STL-like constructors.</li>
<li>Added operators ==, &lt; and derivatives</li>
<li>Added <a class="el" href="a00168.html#a629a29eb21e528414b9d5c9becfe05cd" title="Get reference to element at given index. Throws exceptions on errors. ">at()</a> method, approved for using after an exception was thrown inside the vector</li>
<li>Added <a class="el" href="a00168.html#a88b62a9614d3f2b59c9c7c1a2143fb1e" title="return allocator object ">get_allocator()</a> method.</li>
<li>Added <a class="el" href="a00168.html#a87355dce93d0882aa73333a35c9b367c" title="assign n items by copying t item ">assign()</a> methods</li>
<li>Added compact() method to defragment first segments</li>
<li>Added <a class="el" href="a00168.html#a8603bd57324fb6b60ba006884c95279d" title="swap two instances ">swap()</a> method</li>
<li><a class="el" href="a00168.html#a8201f65735edcc28aeec95b6e73d75b6" title="Get range for iterating with parallel algorithms. ">range()</a> defaults on grainsize = 1 supporting auto grainsize algorithms. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="a00986_source.html#l00065">65</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a7560567b5735c57159e55b12d20b6710"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::allocator_base&lt;T, A&gt;::<a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l00568">568</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa9a55035528c055ae985db2a61c8b0b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::vector_iterator&lt;<a class="el" href="a00168.html">concurrent_vector</a>,const T&gt; <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l00578">578</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="afa0d28eb686589cbaf4733ca0eabc071"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html#afa0d28eb686589cbaf4733ca0eabc071">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l00575">575</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1312eb29abf7ca07aa365c727b7844e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00300.html">generic_range_type</a>&lt;<a class="el" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a>&gt; <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html#a1312eb29abf7ca07aa365c727b7844e3">const_range_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l00594">594</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5ecbb1eb2c7264df9d58255ce211207c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T&amp; <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l00573">573</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ada43b048144c3814036da624d3bb8c58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a>&gt; <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html#ada43b048144c3814036da624d3bb8c58">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l00583">583</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1bb52adb877d3b680dac5f0bd289700b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ptrdiff_t <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html#a1bb52adb877d3b680dac5f0bd289700b">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l00571">571</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4cee8eaee236867c0b6e87309380cb0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef internal::vector_iterator&lt;<a class="el" href="a00168.html">concurrent_vector</a>,T&gt; <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l00577">577</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa2c4f00678df69d2d11497e8dd6ed9cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html#aa2c4f00678df69d2d11497e8dd6ed9cf">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l00574">574</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a443492ee9918c9e3372b5daca82314ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00300.html">generic_range_type</a>&lt;<a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>&gt; <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html#a443492ee9918c9e3372b5daca82314ca">range_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l00593">593</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a412441e93ad8656f96b14c5ecb9d817f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html#a412441e93ad8656f96b14c5ecb9d817f">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l00572">572</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1623110816f9ef8f08e7bf6768aed273"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>&gt; <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html#a1623110816f9ef8f08e7bf6768aed273">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l00582">582</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ada098ff121699bfed7ae37e759eff93d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">internal::concurrent_vector_base_v3::size_type</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l00567">567</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5cf801a503d4e5fe739f53d7321dd2ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html#a5cf801a503d4e5fe739f53d7321dd2ef">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l00570">570</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5bd95c2241653c760704a92b2c887a48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html">concurrent_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct empty vector. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00601">601</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;        : internal::allocator_base&lt;T, A&gt;(a), <a class="code" href="a01133.html#aaf8b38dbf7b0b00e96193a762ba1dd3a">internal::concurrent_vector_base</a>()</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;    {</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;        <a class="code" href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">vector_allocator_ptr</a> = &amp;<a class="code" href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">internal_allocator</a>;</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;    }</div><div class="ttc" id="a00168_html_aa8d78091cca57343f1bd59026c9a9da6"><div class="ttname"><a href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">tbb::concurrent_vector::internal_allocator</a></div><div class="ttdeci">static void * internal_allocator(internal::concurrent_vector_base_v3 &amp;vb, size_t k)</div><div class="ttdoc">Allocate k items. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01025">concurrent_vector.h:1025</a></div></div>
<div class="ttc" id="a01133_html_aaf8b38dbf7b0b00e96193a762ba1dd3a"><div class="ttname"><a href="a01133.html#aaf8b38dbf7b0b00e96193a762ba1dd3a">tbb::internal::concurrent_vector_base</a></div><div class="ttdeci">concurrent_vector_base_v3 concurrent_vector_base</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00289">concurrent_vector.h:289</a></div></div>
<div class="ttc" id="a00169_html_a21eea9a9f25b8d2345f9c5dd112ab7bd"><div class="ttname"><a href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">tbb::internal::concurrent_vector_base_v3::vector_allocator_ptr</a></div><div class="ttdeci">void *(* vector_allocator_ptr)(concurrent_vector_base_v3 &amp;, size_t)</div><div class="ttdoc">allocator function pointer </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00179">concurrent_vector.h:179</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa25dccd2f65fbfa148e92d01a11c20ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html">concurrent_vector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from initializer_list. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00611">611</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;        : internal::allocator_base&lt;T, A&gt;(a), <a class="code" href="a01133.html#aaf8b38dbf7b0b00e96193a762ba1dd3a">internal::concurrent_vector_base</a>()</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;    {</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;        <a class="code" href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">vector_allocator_ptr</a> = &amp;<a class="code" href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">internal_allocator</a>;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;        <a class="code" href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a> {</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;            <a class="code" href="a00168.html#aebff613825ded62ed4648117829f5942">internal_assign_iterators</a>(init_list.begin(), init_list.end());</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;        } <a class="code" href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a>(...) {</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;            segment_t *table = <a class="code" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a>.load&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;();;</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;            <a class="code" href="a00168.html#a496efbef33d4076867c075c67793aa6c">internal_free_segments</a>( table, <a class="code" href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">internal_clear</a>(&amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>), <a class="code" href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">my_first_block</a>.<a class="code" href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">load</a>&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;());</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;            <a class="code" href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a>();</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;        }</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;    }</div><div class="ttc" id="a00168_html_aebff613825ded62ed4648117829f5942"><div class="ttname"><a href="a00168.html#aebff613825ded62ed4648117829f5942">tbb::concurrent_vector::internal_assign_iterators</a></div><div class="ttdeci">void internal_assign_iterators(I first, I last)</div><div class="ttdoc">assign by iterators </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01262">concurrent_vector.h:1262</a></div></div>
<div class="ttc" id="a00083_html_a8451d0ce6e14c18c64c4b02436dbdc7d"><div class="ttname"><a href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">tbb::internal::atomic_impl::load</a></div><div class="ttdeci">value_type load() const </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00306">atomic.h:306</a></div></div>
<div class="ttc" id="a01098_html_a1e83dce98dc82007213f4109f8903cb8"><div class="ttname"><a href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a></div><div class="ttdeci">#define __TBB_CATCH(e)</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00288">tbb_stddef.h:288</a></div></div>
<div class="ttc" id="a00168_html_a496efbef33d4076867c075c67793aa6c"><div class="ttname"><a href="a00168.html#a496efbef33d4076867c075c67793aa6c">tbb::concurrent_vector::internal_free_segments</a></div><div class="ttdeci">void internal_free_segments(segment_t table[], segment_index_t k, segment_index_t first_block)</div><div class="ttdoc">Free k segments from table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01209">concurrent_vector.h:1209</a></div></div>
<div class="ttc" id="a00168_html_aa8d78091cca57343f1bd59026c9a9da6"><div class="ttname"><a href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">tbb::concurrent_vector::internal_allocator</a></div><div class="ttdeci">static void * internal_allocator(internal::concurrent_vector_base_v3 &amp;vb, size_t k)</div><div class="ttdoc">Allocate k items. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01025">concurrent_vector.h:1025</a></div></div>
<div class="ttc" id="a01133_html_aaf8b38dbf7b0b00e96193a762ba1dd3a"><div class="ttname"><a href="a01133.html#aaf8b38dbf7b0b00e96193a762ba1dd3a">tbb::internal::concurrent_vector_base</a></div><div class="ttdeci">concurrent_vector_base_v3 concurrent_vector_base</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00289">concurrent_vector.h:289</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a00169_html_a21eea9a9f25b8d2345f9c5dd112ab7bd"><div class="ttname"><a href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">tbb::internal::concurrent_vector_base_v3::vector_allocator_ptr</a></div><div class="ttdeci">void *(* vector_allocator_ptr)(concurrent_vector_base_v3 &amp;, size_t)</div><div class="ttdoc">allocator function pointer </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00179">concurrent_vector.h:179</a></div></div>
<div class="ttc" id="a01098_html_a6df2b2237c9996f178d7b4ac3691c443"><div class="ttname"><a href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a></div><div class="ttdeci">#define __TBB_TRY</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00287">tbb_stddef.h:287</a></div></div>
<div class="ttc" id="a01113_html_adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5"><div class="ttname"><a href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">tbb::relaxed</a></div><div class="ttdoc">No ordering. </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00051">atomic.h:51</a></div></div>
<div class="ttc" id="a00169_html_ad9d3103757a1ef6a70a597d6b174d5c7"><div class="ttname"><a href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">tbb::internal::concurrent_vector_base_v3::my_first_block</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_first_block</div><div class="ttdoc">count of segments in the first block </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00182">concurrent_vector.h:182</a></div></div>
<div class="ttc" id="a00169_html_acc5232333cf13be4c77bdfe7282f7e14"><div class="ttname"><a href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">tbb::internal::concurrent_vector_base_v3::my_segment</a></div><div class="ttdeci">atomic&lt; segment_t * &gt; my_segment</div><div class="ttdoc">Pointer to the segments table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00188">concurrent_vector.h:188</a></div></div>
<div class="ttc" id="a00169_html_aa8ab12f2be0114336e7bb0c291e611a2"><div class="ttname"><a href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">tbb::internal::concurrent_vector_base_v3::internal_clear</a></div><div class="ttdeci">segment_index_t __TBB_EXPORTED_METHOD internal_clear(internal_array_op1 destroy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00505">concurrent_vector.cpp:505</a></div></div>
<div class="ttc" id="a01098_html_affef623b71eccade29a6276f789315b8"><div class="ttname"><a href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a></div><div class="ttdeci">#define __TBB_RETHROW()</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00290">tbb_stddef.h:290</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a03b5a0e9069b30dc4e2e5fc2f191ccb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html">concurrent_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copying constructor. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00627">627</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;        : internal::allocator_base&lt;T, A&gt;(a), <a class="code" href="a01133.html#aaf8b38dbf7b0b00e96193a762ba1dd3a">internal::concurrent_vector_base</a>()</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;    {</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;        <a class="code" href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">vector_allocator_ptr</a> = &amp;<a class="code" href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">internal_allocator</a>;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;        <a class="code" href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a> {</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;            <a class="code" href="a00169.html#af0dff324e332e7b4df6dd933f0af0fb2">internal_copy</a>(vector, <span class="keyword">sizeof</span>(T), &amp;<a class="code" href="a00168.html#a99cf2fd728e2a39dfc51ebe41ccc3779">copy_array</a>);</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;        } <a class="code" href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a>(...) {</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;            segment_t *table = <a class="code" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a>.load&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;();</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;            <a class="code" href="a00168.html#a496efbef33d4076867c075c67793aa6c">internal_free_segments</a>( table, <a class="code" href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">internal_clear</a>(&amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>), <a class="code" href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">my_first_block</a>.<a class="code" href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">load</a>&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;());</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;            <a class="code" href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a>();</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;        }</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;    }</div><div class="ttc" id="a00083_html_a8451d0ce6e14c18c64c4b02436dbdc7d"><div class="ttname"><a href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">tbb::internal::atomic_impl::load</a></div><div class="ttdeci">value_type load() const </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00306">atomic.h:306</a></div></div>
<div class="ttc" id="a01098_html_a1e83dce98dc82007213f4109f8903cb8"><div class="ttname"><a href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a></div><div class="ttdeci">#define __TBB_CATCH(e)</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00288">tbb_stddef.h:288</a></div></div>
<div class="ttc" id="a00168_html_a99cf2fd728e2a39dfc51ebe41ccc3779"><div class="ttname"><a href="a00168.html#a99cf2fd728e2a39dfc51ebe41ccc3779">tbb::concurrent_vector::copy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC copy_array(void *dst, const void *src, size_type n)</div><div class="ttdoc">Copy-construct n instances of T by copying single element pointed to by src, starting at &quot;dst&quot;...</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01293">concurrent_vector.h:1293</a></div></div>
<div class="ttc" id="a00168_html_a496efbef33d4076867c075c67793aa6c"><div class="ttname"><a href="a00168.html#a496efbef33d4076867c075c67793aa6c">tbb::concurrent_vector::internal_free_segments</a></div><div class="ttdeci">void internal_free_segments(segment_t table[], segment_index_t k, segment_index_t first_block)</div><div class="ttdoc">Free k segments from table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01209">concurrent_vector.h:1209</a></div></div>
<div class="ttc" id="a00168_html_aa8d78091cca57343f1bd59026c9a9da6"><div class="ttname"><a href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">tbb::concurrent_vector::internal_allocator</a></div><div class="ttdeci">static void * internal_allocator(internal::concurrent_vector_base_v3 &amp;vb, size_t k)</div><div class="ttdoc">Allocate k items. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01025">concurrent_vector.h:1025</a></div></div>
<div class="ttc" id="a01133_html_aaf8b38dbf7b0b00e96193a762ba1dd3a"><div class="ttname"><a href="a01133.html#aaf8b38dbf7b0b00e96193a762ba1dd3a">tbb::internal::concurrent_vector_base</a></div><div class="ttdeci">concurrent_vector_base_v3 concurrent_vector_base</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00289">concurrent_vector.h:289</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a00169_html_a21eea9a9f25b8d2345f9c5dd112ab7bd"><div class="ttname"><a href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">tbb::internal::concurrent_vector_base_v3::vector_allocator_ptr</a></div><div class="ttdeci">void *(* vector_allocator_ptr)(concurrent_vector_base_v3 &amp;, size_t)</div><div class="ttdoc">allocator function pointer </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00179">concurrent_vector.h:179</a></div></div>
<div class="ttc" id="a01098_html_a6df2b2237c9996f178d7b4ac3691c443"><div class="ttname"><a href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a></div><div class="ttdeci">#define __TBB_TRY</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00287">tbb_stddef.h:287</a></div></div>
<div class="ttc" id="a01113_html_adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5"><div class="ttname"><a href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">tbb::relaxed</a></div><div class="ttdoc">No ordering. </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00051">atomic.h:51</a></div></div>
<div class="ttc" id="a00169_html_ad9d3103757a1ef6a70a597d6b174d5c7"><div class="ttname"><a href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">tbb::internal::concurrent_vector_base_v3::my_first_block</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_first_block</div><div class="ttdoc">count of segments in the first block </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00182">concurrent_vector.h:182</a></div></div>
<div class="ttc" id="a00169_html_acc5232333cf13be4c77bdfe7282f7e14"><div class="ttname"><a href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">tbb::internal::concurrent_vector_base_v3::my_segment</a></div><div class="ttdeci">atomic&lt; segment_t * &gt; my_segment</div><div class="ttdoc">Pointer to the segments table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00188">concurrent_vector.h:188</a></div></div>
<div class="ttc" id="a00169_html_aa8ab12f2be0114336e7bb0c291e611a2"><div class="ttname"><a href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">tbb::internal::concurrent_vector_base_v3::internal_clear</a></div><div class="ttdeci">segment_index_t __TBB_EXPORTED_METHOD internal_clear(internal_array_op1 destroy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00505">concurrent_vector.cpp:505</a></div></div>
<div class="ttc" id="a01098_html_affef623b71eccade29a6276f789315b8"><div class="ttname"><a href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a></div><div class="ttdeci">#define __TBB_RETHROW()</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00290">tbb_stddef.h:290</a></div></div>
<div class="ttc" id="a00169_html_af0dff324e332e7b4df6dd933f0af0fb2"><div class="ttname"><a href="a00169.html#af0dff324e332e7b4df6dd933f0af0fb2">tbb::internal::concurrent_vector_base_v3::internal_copy</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_copy(const concurrent_vector_base_v3 &amp;src, size_type element_size, internal_array_op2 copy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00360">concurrent_vector.cpp:360</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aafb048cfda83d0e7803888ead76c06a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html">concurrent_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00643">643</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;        : internal::allocator_base&lt;T, A&gt;(<a class="code" href="a01113.html#ac41903d6b80e61bd6c605412e7820e08">std::move</a>(source)), <a class="code" href="a01133.html#aaf8b38dbf7b0b00e96193a762ba1dd3a">internal::concurrent_vector_base</a>()</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    {</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;        <a class="code" href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">vector_allocator_ptr</a> = &amp;<a class="code" href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">internal_allocator</a>;</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;        <a class="code" href="a00169.html#a5913c17dffae92a75f8c1c3caaa7ecf6">concurrent_vector_base_v3::internal_swap</a>(source);</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;    }</div><div class="ttc" id="a00169_html_a5913c17dffae92a75f8c1c3caaa7ecf6"><div class="ttname"><a href="a00169.html#a5913c17dffae92a75f8c1c3caaa7ecf6">tbb::internal::concurrent_vector_base_v3::internal_swap</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_swap(concurrent_vector_base_v3 &amp;v)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00586">concurrent_vector.cpp:586</a></div></div>
<div class="ttc" id="a00168_html_aa8d78091cca57343f1bd59026c9a9da6"><div class="ttname"><a href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">tbb::concurrent_vector::internal_allocator</a></div><div class="ttdeci">static void * internal_allocator(internal::concurrent_vector_base_v3 &amp;vb, size_t k)</div><div class="ttdoc">Allocate k items. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01025">concurrent_vector.h:1025</a></div></div>
<div class="ttc" id="a01133_html_aaf8b38dbf7b0b00e96193a762ba1dd3a"><div class="ttname"><a href="a01133.html#aaf8b38dbf7b0b00e96193a762ba1dd3a">tbb::internal::concurrent_vector_base</a></div><div class="ttdeci">concurrent_vector_base_v3 concurrent_vector_base</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00289">concurrent_vector.h:289</a></div></div>
<div class="ttc" id="a00169_html_a21eea9a9f25b8d2345f9c5dd112ab7bd"><div class="ttname"><a href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">tbb::internal::concurrent_vector_base_v3::vector_allocator_ptr</a></div><div class="ttdeci">void *(* vector_allocator_ptr)(concurrent_vector_base_v3 &amp;, size_t)</div><div class="ttdoc">allocator function pointer </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00179">concurrent_vector.h:179</a></div></div>
<div class="ttc" id="a01113_html_ac41903d6b80e61bd6c605412e7820e08"><div class="ttname"><a href="a01113.html#ac41903d6b80e61bd6c605412e7820e08">tbb::move</a></div><div class="ttdeci">void move(tbb_thread &amp;t1, tbb_thread &amp;t2)</div><div class="ttdef"><b>Definition:</b> <a href="a01100_source.html#l00309">tbb_thread.h:309</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aef020f41f3017fecc43e70a22d3e0fc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html">concurrent_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l00650">650</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;        : internal::allocator_base&lt;T, A&gt;(a), <a class="code" href="a01133.html#aaf8b38dbf7b0b00e96193a762ba1dd3a">internal::concurrent_vector_base</a>()</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;    {</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;        <a class="code" href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">vector_allocator_ptr</a> = &amp;<a class="code" href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">internal_allocator</a>;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;        <span class="comment">//C++ standard requires instances of an allocator being compared for equality,</span></div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;        <span class="comment">//which means that memory allocated by one instance is possible to deallocate with the other one.</span></div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;        <span class="keywordflow">if</span> (a == source.my_allocator) {</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;            <a class="code" href="a00169.html#a5913c17dffae92a75f8c1c3caaa7ecf6">concurrent_vector_base_v3::internal_swap</a>(source);</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;            <a class="code" href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a> {</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;                <a class="code" href="a00169.html#af0dff324e332e7b4df6dd933f0af0fb2">internal_copy</a>(source, <span class="keyword">sizeof</span>(T), &amp;<a class="code" href="a00168.html#a265a4e7d777baedfb71172dfcf0f980f">move_array</a>);</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;            } <a class="code" href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a>(...) {</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;                segment_t *table = <a class="code" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a>.load&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;();</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;                <a class="code" href="a00168.html#a496efbef33d4076867c075c67793aa6c">internal_free_segments</a>( table, <a class="code" href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">internal_clear</a>(&amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>), <a class="code" href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">my_first_block</a>.<a class="code" href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">load</a>&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;());</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;                <a class="code" href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a>();</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;            }</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;        }</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;    }</div><div class="ttc" id="a00169_html_a5913c17dffae92a75f8c1c3caaa7ecf6"><div class="ttname"><a href="a00169.html#a5913c17dffae92a75f8c1c3caaa7ecf6">tbb::internal::concurrent_vector_base_v3::internal_swap</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_swap(concurrent_vector_base_v3 &amp;v)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00586">concurrent_vector.cpp:586</a></div></div>
<div class="ttc" id="a00083_html_a8451d0ce6e14c18c64c4b02436dbdc7d"><div class="ttname"><a href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">tbb::internal::atomic_impl::load</a></div><div class="ttdeci">value_type load() const </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00306">atomic.h:306</a></div></div>
<div class="ttc" id="a01098_html_a1e83dce98dc82007213f4109f8903cb8"><div class="ttname"><a href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a></div><div class="ttdeci">#define __TBB_CATCH(e)</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00288">tbb_stddef.h:288</a></div></div>
<div class="ttc" id="a00168_html_a496efbef33d4076867c075c67793aa6c"><div class="ttname"><a href="a00168.html#a496efbef33d4076867c075c67793aa6c">tbb::concurrent_vector::internal_free_segments</a></div><div class="ttdeci">void internal_free_segments(segment_t table[], segment_index_t k, segment_index_t first_block)</div><div class="ttdoc">Free k segments from table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01209">concurrent_vector.h:1209</a></div></div>
<div class="ttc" id="a00168_html_aa8d78091cca57343f1bd59026c9a9da6"><div class="ttname"><a href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">tbb::concurrent_vector::internal_allocator</a></div><div class="ttdeci">static void * internal_allocator(internal::concurrent_vector_base_v3 &amp;vb, size_t k)</div><div class="ttdoc">Allocate k items. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01025">concurrent_vector.h:1025</a></div></div>
<div class="ttc" id="a01133_html_aaf8b38dbf7b0b00e96193a762ba1dd3a"><div class="ttname"><a href="a01133.html#aaf8b38dbf7b0b00e96193a762ba1dd3a">tbb::internal::concurrent_vector_base</a></div><div class="ttdeci">concurrent_vector_base_v3 concurrent_vector_base</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00289">concurrent_vector.h:289</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a00169_html_a21eea9a9f25b8d2345f9c5dd112ab7bd"><div class="ttname"><a href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">tbb::internal::concurrent_vector_base_v3::vector_allocator_ptr</a></div><div class="ttdeci">void *(* vector_allocator_ptr)(concurrent_vector_base_v3 &amp;, size_t)</div><div class="ttdoc">allocator function pointer </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00179">concurrent_vector.h:179</a></div></div>
<div class="ttc" id="a01098_html_a6df2b2237c9996f178d7b4ac3691c443"><div class="ttname"><a href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a></div><div class="ttdeci">#define __TBB_TRY</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00287">tbb_stddef.h:287</a></div></div>
<div class="ttc" id="a01113_html_adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5"><div class="ttname"><a href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">tbb::relaxed</a></div><div class="ttdoc">No ordering. </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00051">atomic.h:51</a></div></div>
<div class="ttc" id="a00169_html_ad9d3103757a1ef6a70a597d6b174d5c7"><div class="ttname"><a href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">tbb::internal::concurrent_vector_base_v3::my_first_block</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_first_block</div><div class="ttdoc">count of segments in the first block </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00182">concurrent_vector.h:182</a></div></div>
<div class="ttc" id="a00169_html_acc5232333cf13be4c77bdfe7282f7e14"><div class="ttname"><a href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">tbb::internal::concurrent_vector_base_v3::my_segment</a></div><div class="ttdeci">atomic&lt; segment_t * &gt; my_segment</div><div class="ttdoc">Pointer to the segments table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00188">concurrent_vector.h:188</a></div></div>
<div class="ttc" id="a00169_html_aa8ab12f2be0114336e7bb0c291e611a2"><div class="ttname"><a href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">tbb::internal::concurrent_vector_base_v3::internal_clear</a></div><div class="ttdeci">segment_index_t __TBB_EXPORTED_METHOD internal_clear(internal_array_op1 destroy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00505">concurrent_vector.cpp:505</a></div></div>
<div class="ttc" id="a01098_html_affef623b71eccade29a6276f789315b8"><div class="ttname"><a href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a></div><div class="ttdeci">#define __TBB_RETHROW()</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00290">tbb_stddef.h:290</a></div></div>
<div class="ttc" id="a00168_html_a265a4e7d777baedfb71172dfcf0f980f"><div class="ttname"><a href="a00168.html#a265a4e7d777baedfb71172dfcf0f980f">tbb::concurrent_vector::move_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC move_array(void *dst, const void *src, size_type n)</div><div class="ttdoc">Move-construct n instances of T, starting at &quot;dst&quot; by copying according element of src array...</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01299">concurrent_vector.h:1299</a></div></div>
<div class="ttc" id="a00169_html_af0dff324e332e7b4df6dd933f0af0fb2"><div class="ttname"><a href="a00169.html#af0dff324e332e7b4df6dd933f0af0fb2">tbb::internal::concurrent_vector_base_v3::internal_copy</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_copy(const concurrent_vector_base_v3 &amp;src, size_type element_size, internal_array_op2 copy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00360">concurrent_vector.cpp:360</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abb0e376a31c3fdb91beaaa98441735f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<div class="memtemplate">
template&lt;class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html">concurrent_vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copying constructor for vector with different allocator type. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00673">673</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;        : internal::allocator_base&lt;T, A&gt;(a), <a class="code" href="a01133.html#aaf8b38dbf7b0b00e96193a762ba1dd3a">internal::concurrent_vector_base</a>()</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;    {</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;        <a class="code" href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">vector_allocator_ptr</a> = &amp;<a class="code" href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">internal_allocator</a>;</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;        <a class="code" href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a> {</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;            <a class="code" href="a00169.html#af0dff324e332e7b4df6dd933f0af0fb2">internal_copy</a>(vector.internal_vector_base(), <span class="keyword">sizeof</span>(T), &amp;<a class="code" href="a00168.html#a99cf2fd728e2a39dfc51ebe41ccc3779">copy_array</a>);</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;        } <a class="code" href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a>(...) {</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;            segment_t *table = <a class="code" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a>.load&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;();</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;            <a class="code" href="a00168.html#a496efbef33d4076867c075c67793aa6c">internal_free_segments</a>( table, <a class="code" href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">internal_clear</a>(&amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>), <a class="code" href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">my_first_block</a>.<a class="code" href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">load</a>&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;() );</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;            <a class="code" href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a>();</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;        }</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;    }</div><div class="ttc" id="a00083_html_a8451d0ce6e14c18c64c4b02436dbdc7d"><div class="ttname"><a href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">tbb::internal::atomic_impl::load</a></div><div class="ttdeci">value_type load() const </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00306">atomic.h:306</a></div></div>
<div class="ttc" id="a01098_html_a1e83dce98dc82007213f4109f8903cb8"><div class="ttname"><a href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a></div><div class="ttdeci">#define __TBB_CATCH(e)</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00288">tbb_stddef.h:288</a></div></div>
<div class="ttc" id="a00168_html_a99cf2fd728e2a39dfc51ebe41ccc3779"><div class="ttname"><a href="a00168.html#a99cf2fd728e2a39dfc51ebe41ccc3779">tbb::concurrent_vector::copy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC copy_array(void *dst, const void *src, size_type n)</div><div class="ttdoc">Copy-construct n instances of T by copying single element pointed to by src, starting at &quot;dst&quot;...</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01293">concurrent_vector.h:1293</a></div></div>
<div class="ttc" id="a00168_html_a496efbef33d4076867c075c67793aa6c"><div class="ttname"><a href="a00168.html#a496efbef33d4076867c075c67793aa6c">tbb::concurrent_vector::internal_free_segments</a></div><div class="ttdeci">void internal_free_segments(segment_t table[], segment_index_t k, segment_index_t first_block)</div><div class="ttdoc">Free k segments from table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01209">concurrent_vector.h:1209</a></div></div>
<div class="ttc" id="a00168_html_aa8d78091cca57343f1bd59026c9a9da6"><div class="ttname"><a href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">tbb::concurrent_vector::internal_allocator</a></div><div class="ttdeci">static void * internal_allocator(internal::concurrent_vector_base_v3 &amp;vb, size_t k)</div><div class="ttdoc">Allocate k items. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01025">concurrent_vector.h:1025</a></div></div>
<div class="ttc" id="a01133_html_aaf8b38dbf7b0b00e96193a762ba1dd3a"><div class="ttname"><a href="a01133.html#aaf8b38dbf7b0b00e96193a762ba1dd3a">tbb::internal::concurrent_vector_base</a></div><div class="ttdeci">concurrent_vector_base_v3 concurrent_vector_base</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00289">concurrent_vector.h:289</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a00169_html_a21eea9a9f25b8d2345f9c5dd112ab7bd"><div class="ttname"><a href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">tbb::internal::concurrent_vector_base_v3::vector_allocator_ptr</a></div><div class="ttdeci">void *(* vector_allocator_ptr)(concurrent_vector_base_v3 &amp;, size_t)</div><div class="ttdoc">allocator function pointer </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00179">concurrent_vector.h:179</a></div></div>
<div class="ttc" id="a01098_html_a6df2b2237c9996f178d7b4ac3691c443"><div class="ttname"><a href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a></div><div class="ttdeci">#define __TBB_TRY</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00287">tbb_stddef.h:287</a></div></div>
<div class="ttc" id="a01113_html_adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5"><div class="ttname"><a href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">tbb::relaxed</a></div><div class="ttdoc">No ordering. </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00051">atomic.h:51</a></div></div>
<div class="ttc" id="a00169_html_ad9d3103757a1ef6a70a597d6b174d5c7"><div class="ttname"><a href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">tbb::internal::concurrent_vector_base_v3::my_first_block</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_first_block</div><div class="ttdoc">count of segments in the first block </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00182">concurrent_vector.h:182</a></div></div>
<div class="ttc" id="a00169_html_acc5232333cf13be4c77bdfe7282f7e14"><div class="ttname"><a href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">tbb::internal::concurrent_vector_base_v3::my_segment</a></div><div class="ttdeci">atomic&lt; segment_t * &gt; my_segment</div><div class="ttdoc">Pointer to the segments table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00188">concurrent_vector.h:188</a></div></div>
<div class="ttc" id="a00169_html_aa8ab12f2be0114336e7bb0c291e611a2"><div class="ttname"><a href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">tbb::internal::concurrent_vector_base_v3::internal_clear</a></div><div class="ttdeci">segment_index_t __TBB_EXPORTED_METHOD internal_clear(internal_array_op1 destroy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00505">concurrent_vector.cpp:505</a></div></div>
<div class="ttc" id="a01098_html_affef623b71eccade29a6276f789315b8"><div class="ttname"><a href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a></div><div class="ttdeci">#define __TBB_RETHROW()</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00290">tbb_stddef.h:290</a></div></div>
<div class="ttc" id="a00169_html_af0dff324e332e7b4df6dd933f0af0fb2"><div class="ttname"><a href="a00169.html#af0dff324e332e7b4df6dd933f0af0fb2">tbb::internal::concurrent_vector_base_v3::internal_copy</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_copy(const concurrent_vector_base_v3 &amp;src, size_type element_size, internal_array_op2 copy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00360">concurrent_vector.cpp:360</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa898a39aad73711ceca70cd465dc0b4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html">concurrent_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construction with initial size specified by argument n. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00687">687</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;    {</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;        <a class="code" href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">vector_allocator_ptr</a> = &amp;<a class="code" href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">internal_allocator</a>;</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;        <a class="code" href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a> {</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;            <a class="code" href="a00169.html#a57151343a7f7c09dfc70bad5f149c417">internal_resize</a>( n, <span class="keyword">sizeof</span>(T), <a class="code" href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">max_size</a>(), NULL, &amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>, &amp;<a class="code" href="a00168.html#a12b1a671033a824c0027720427072328">initialize_array</a> );</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;        } <a class="code" href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a>(...) {</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;            segment_t *table = <a class="code" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a>.load&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;();</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;            <a class="code" href="a00168.html#a496efbef33d4076867c075c67793aa6c">internal_free_segments</a>( table, <a class="code" href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">internal_clear</a>(&amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>), <a class="code" href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">my_first_block</a>.<a class="code" href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">load</a>&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;() );</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;            <a class="code" href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a>();</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;        }</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;    }</div><div class="ttc" id="a00168_html_a12b1a671033a824c0027720427072328"><div class="ttname"><a href="a00168.html#a12b1a671033a824c0027720427072328">tbb::concurrent_vector::initialize_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC initialize_array(void *begin, const void *, size_type n)</div><div class="ttdoc">Construct n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01283">concurrent_vector.h:1283</a></div></div>
<div class="ttc" id="a00083_html_a8451d0ce6e14c18c64c4b02436dbdc7d"><div class="ttname"><a href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">tbb::internal::atomic_impl::load</a></div><div class="ttdeci">value_type load() const </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00306">atomic.h:306</a></div></div>
<div class="ttc" id="a01098_html_a1e83dce98dc82007213f4109f8903cb8"><div class="ttname"><a href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a></div><div class="ttdeci">#define __TBB_CATCH(e)</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00288">tbb_stddef.h:288</a></div></div>
<div class="ttc" id="a00168_html_a0ec9c3ab3360e04bdaa5174956a3206d"><div class="ttname"><a href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">tbb::concurrent_vector::max_size</a></div><div class="ttdeci">size_type max_size() const </div><div class="ttdoc">Upper bound on argument to reserve. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00926">concurrent_vector.h:926</a></div></div>
<div class="ttc" id="a00168_html_a496efbef33d4076867c075c67793aa6c"><div class="ttname"><a href="a00168.html#a496efbef33d4076867c075c67793aa6c">tbb::concurrent_vector::internal_free_segments</a></div><div class="ttdeci">void internal_free_segments(segment_t table[], segment_index_t k, segment_index_t first_block)</div><div class="ttdoc">Free k segments from table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01209">concurrent_vector.h:1209</a></div></div>
<div class="ttc" id="a00168_html_aa8d78091cca57343f1bd59026c9a9da6"><div class="ttname"><a href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">tbb::concurrent_vector::internal_allocator</a></div><div class="ttdeci">static void * internal_allocator(internal::concurrent_vector_base_v3 &amp;vb, size_t k)</div><div class="ttdoc">Allocate k items. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01025">concurrent_vector.h:1025</a></div></div>
<div class="ttc" id="a00169_html_a57151343a7f7c09dfc70bad5f149c417"><div class="ttname"><a href="a00169.html#a57151343a7f7c09dfc70bad5f149c417">tbb::internal::concurrent_vector_base_v3::internal_resize</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_resize(size_type n, size_type element_size, size_type max_size, const void *src, internal_array_op1 destroy, internal_array_op2 init)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00490">concurrent_vector.cpp:490</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a00169_html_a21eea9a9f25b8d2345f9c5dd112ab7bd"><div class="ttname"><a href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">tbb::internal::concurrent_vector_base_v3::vector_allocator_ptr</a></div><div class="ttdeci">void *(* vector_allocator_ptr)(concurrent_vector_base_v3 &amp;, size_t)</div><div class="ttdoc">allocator function pointer </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00179">concurrent_vector.h:179</a></div></div>
<div class="ttc" id="a01098_html_a6df2b2237c9996f178d7b4ac3691c443"><div class="ttname"><a href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a></div><div class="ttdeci">#define __TBB_TRY</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00287">tbb_stddef.h:287</a></div></div>
<div class="ttc" id="a01113_html_adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5"><div class="ttname"><a href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">tbb::relaxed</a></div><div class="ttdoc">No ordering. </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00051">atomic.h:51</a></div></div>
<div class="ttc" id="a00169_html_ad9d3103757a1ef6a70a597d6b174d5c7"><div class="ttname"><a href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">tbb::internal::concurrent_vector_base_v3::my_first_block</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_first_block</div><div class="ttdoc">count of segments in the first block </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00182">concurrent_vector.h:182</a></div></div>
<div class="ttc" id="a00169_html_acc5232333cf13be4c77bdfe7282f7e14"><div class="ttname"><a href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">tbb::internal::concurrent_vector_base_v3::my_segment</a></div><div class="ttdeci">atomic&lt; segment_t * &gt; my_segment</div><div class="ttdoc">Pointer to the segments table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00188">concurrent_vector.h:188</a></div></div>
<div class="ttc" id="a00169_html_aa8ab12f2be0114336e7bb0c291e611a2"><div class="ttname"><a href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">tbb::internal::concurrent_vector_base_v3::internal_clear</a></div><div class="ttdeci">segment_index_t __TBB_EXPORTED_METHOD internal_clear(internal_array_op1 destroy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00505">concurrent_vector.cpp:505</a></div></div>
<div class="ttc" id="a01098_html_affef623b71eccade29a6276f789315b8"><div class="ttname"><a href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a></div><div class="ttdeci">#define __TBB_RETHROW()</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00290">tbb_stddef.h:290</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a736c6e35f1df11625636968ea546e21f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html">concurrent_vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construction with initial size specified by argument n, initialization by copying of t, and given allocator instance. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00700">700</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;        : internal::allocator_base&lt;T, A&gt;(a)</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;    {</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;        <a class="code" href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">vector_allocator_ptr</a> = &amp;<a class="code" href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">internal_allocator</a>;</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;        <a class="code" href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a> {</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;            <a class="code" href="a00169.html#a57151343a7f7c09dfc70bad5f149c417">internal_resize</a>( n, <span class="keyword">sizeof</span>(T), <a class="code" href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">max_size</a>(), static_cast&lt;const void*&gt;(&amp;t), &amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>, &amp;<a class="code" href="a00168.html#a615b7ebb3f9219014924b523c44e085e">initialize_array_by</a> );</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;        } <a class="code" href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a>(...) {</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;            segment_t *table = <a class="code" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a>.load&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;();</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;            <a class="code" href="a00168.html#a496efbef33d4076867c075c67793aa6c">internal_free_segments</a>( table, <a class="code" href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">internal_clear</a>(&amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>), <a class="code" href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">my_first_block</a>.<a class="code" href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">load</a>&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;() );</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;            <a class="code" href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a>();</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;        }</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;    }</div><div class="ttc" id="a00083_html_a8451d0ce6e14c18c64c4b02436dbdc7d"><div class="ttname"><a href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">tbb::internal::atomic_impl::load</a></div><div class="ttdeci">value_type load() const </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00306">atomic.h:306</a></div></div>
<div class="ttc" id="a01098_html_a1e83dce98dc82007213f4109f8903cb8"><div class="ttname"><a href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a></div><div class="ttdeci">#define __TBB_CATCH(e)</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00288">tbb_stddef.h:288</a></div></div>
<div class="ttc" id="a00168_html_a0ec9c3ab3360e04bdaa5174956a3206d"><div class="ttname"><a href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">tbb::concurrent_vector::max_size</a></div><div class="ttdeci">size_type max_size() const </div><div class="ttdoc">Upper bound on argument to reserve. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00926">concurrent_vector.h:926</a></div></div>
<div class="ttc" id="a00168_html_a496efbef33d4076867c075c67793aa6c"><div class="ttname"><a href="a00168.html#a496efbef33d4076867c075c67793aa6c">tbb::concurrent_vector::internal_free_segments</a></div><div class="ttdeci">void internal_free_segments(segment_t table[], segment_index_t k, segment_index_t first_block)</div><div class="ttdoc">Free k segments from table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01209">concurrent_vector.h:1209</a></div></div>
<div class="ttc" id="a00168_html_aa8d78091cca57343f1bd59026c9a9da6"><div class="ttname"><a href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">tbb::concurrent_vector::internal_allocator</a></div><div class="ttdeci">static void * internal_allocator(internal::concurrent_vector_base_v3 &amp;vb, size_t k)</div><div class="ttdoc">Allocate k items. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01025">concurrent_vector.h:1025</a></div></div>
<div class="ttc" id="a00169_html_a57151343a7f7c09dfc70bad5f149c417"><div class="ttname"><a href="a00169.html#a57151343a7f7c09dfc70bad5f149c417">tbb::internal::concurrent_vector_base_v3::internal_resize</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_resize(size_type n, size_type element_size, size_type max_size, const void *src, internal_array_op1 destroy, internal_array_op2 init)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00490">concurrent_vector.cpp:490</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a00169_html_a21eea9a9f25b8d2345f9c5dd112ab7bd"><div class="ttname"><a href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">tbb::internal::concurrent_vector_base_v3::vector_allocator_ptr</a></div><div class="ttdeci">void *(* vector_allocator_ptr)(concurrent_vector_base_v3 &amp;, size_t)</div><div class="ttdoc">allocator function pointer </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00179">concurrent_vector.h:179</a></div></div>
<div class="ttc" id="a01098_html_a6df2b2237c9996f178d7b4ac3691c443"><div class="ttname"><a href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a></div><div class="ttdeci">#define __TBB_TRY</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00287">tbb_stddef.h:287</a></div></div>
<div class="ttc" id="a01113_html_adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5"><div class="ttname"><a href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">tbb::relaxed</a></div><div class="ttdoc">No ordering. </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00051">atomic.h:51</a></div></div>
<div class="ttc" id="a00168_html_a615b7ebb3f9219014924b523c44e085e"><div class="ttname"><a href="a00168.html#a615b7ebb3f9219014924b523c44e085e">tbb::concurrent_vector::initialize_array_by</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC initialize_array_by(void *begin, const void *src, size_type n)</div><div class="ttdoc">Copy-construct n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01288">concurrent_vector.h:1288</a></div></div>
<div class="ttc" id="a00169_html_ad9d3103757a1ef6a70a597d6b174d5c7"><div class="ttname"><a href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">tbb::internal::concurrent_vector_base_v3::my_first_block</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_first_block</div><div class="ttdoc">count of segments in the first block </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00182">concurrent_vector.h:182</a></div></div>
<div class="ttc" id="a00169_html_acc5232333cf13be4c77bdfe7282f7e14"><div class="ttname"><a href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">tbb::internal::concurrent_vector_base_v3::my_segment</a></div><div class="ttdeci">atomic&lt; segment_t * &gt; my_segment</div><div class="ttdoc">Pointer to the segments table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00188">concurrent_vector.h:188</a></div></div>
<div class="ttc" id="a00169_html_aa8ab12f2be0114336e7bb0c291e611a2"><div class="ttname"><a href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">tbb::internal::concurrent_vector_base_v3::internal_clear</a></div><div class="ttdeci">segment_index_t __TBB_EXPORTED_METHOD internal_clear(internal_array_op1 destroy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00505">concurrent_vector.cpp:505</a></div></div>
<div class="ttc" id="a01098_html_affef623b71eccade29a6276f789315b8"><div class="ttname"><a href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a></div><div class="ttdeci">#define __TBB_RETHROW()</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00290">tbb_stddef.h:290</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae0d384ec56032d18f63e26960029d3ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<div class="memtemplate">
template&lt;class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::<a class="el" href="a00168.html">concurrent_vector</a> </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construction with copying iteration range and given allocator instance. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00715">715</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;        : internal::allocator_base&lt;T, A&gt;(a)</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;    {</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;        <a class="code" href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">vector_allocator_ptr</a> = &amp;<a class="code" href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">internal_allocator</a>;</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;        <a class="code" href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a> {</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;            <a class="code" href="a00168.html#a874a5d44cc3dc7c4b67b3b52b8fc4bff">internal_assign_range</a>(<a class="code" href="a01133.html#acf23419eb6d3adac787a4fee78cb3c27">first</a>, <a class="code" href="a01133.html#acb741ec0fd6aa234c464640f37d7c812">last</a>, <span class="keyword">static_cast&lt;</span>is_integer_tag&lt;std::numeric_limits&lt;I&gt;::is_integer<span class="keyword">&gt;</span> *&gt;(0) );</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;        } <a class="code" href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a>(...) {</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;            segment_t *table = <a class="code" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a>.load&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;();</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;            <a class="code" href="a00168.html#a496efbef33d4076867c075c67793aa6c">internal_free_segments</a>( table, <a class="code" href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">internal_clear</a>(&amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>), <a class="code" href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">my_first_block</a>.<a class="code" href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">load</a>&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;() );</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;            <a class="code" href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a>();</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;        }</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;    }</div><div class="ttc" id="a01133_html_acb741ec0fd6aa234c464640f37d7c812"><div class="ttname"><a href="a01133.html#acb741ec0fd6aa234c464640f37d7c812">tbb::internal::last</a></div><div class="ttdeci">auto last(Container &amp;c) -&gt; decltype(begin(c))</div><div class="ttdef"><b>Definition:</b> <a href="a00953_source.html#l00044">_range_iterator.h:44</a></div></div>
<div class="ttc" id="a00083_html_a8451d0ce6e14c18c64c4b02436dbdc7d"><div class="ttname"><a href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">tbb::internal::atomic_impl::load</a></div><div class="ttdeci">value_type load() const </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00306">atomic.h:306</a></div></div>
<div class="ttc" id="a01098_html_a1e83dce98dc82007213f4109f8903cb8"><div class="ttname"><a href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a></div><div class="ttdeci">#define __TBB_CATCH(e)</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00288">tbb_stddef.h:288</a></div></div>
<div class="ttc" id="a00168_html_a496efbef33d4076867c075c67793aa6c"><div class="ttname"><a href="a00168.html#a496efbef33d4076867c075c67793aa6c">tbb::concurrent_vector::internal_free_segments</a></div><div class="ttdeci">void internal_free_segments(segment_t table[], segment_index_t k, segment_index_t first_block)</div><div class="ttdoc">Free k segments from table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01209">concurrent_vector.h:1209</a></div></div>
<div class="ttc" id="a00168_html_aa8d78091cca57343f1bd59026c9a9da6"><div class="ttname"><a href="a00168.html#aa8d78091cca57343f1bd59026c9a9da6">tbb::concurrent_vector::internal_allocator</a></div><div class="ttdeci">static void * internal_allocator(internal::concurrent_vector_base_v3 &amp;vb, size_t k)</div><div class="ttdoc">Allocate k items. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01025">concurrent_vector.h:1025</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a00169_html_a21eea9a9f25b8d2345f9c5dd112ab7bd"><div class="ttname"><a href="a00169.html#a21eea9a9f25b8d2345f9c5dd112ab7bd">tbb::internal::concurrent_vector_base_v3::vector_allocator_ptr</a></div><div class="ttdeci">void *(* vector_allocator_ptr)(concurrent_vector_base_v3 &amp;, size_t)</div><div class="ttdoc">allocator function pointer </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00179">concurrent_vector.h:179</a></div></div>
<div class="ttc" id="a01098_html_a6df2b2237c9996f178d7b4ac3691c443"><div class="ttname"><a href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a></div><div class="ttdeci">#define __TBB_TRY</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00287">tbb_stddef.h:287</a></div></div>
<div class="ttc" id="a01113_html_adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5"><div class="ttname"><a href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">tbb::relaxed</a></div><div class="ttdoc">No ordering. </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00051">atomic.h:51</a></div></div>
<div class="ttc" id="a00169_html_ad9d3103757a1ef6a70a597d6b174d5c7"><div class="ttname"><a href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">tbb::internal::concurrent_vector_base_v3::my_first_block</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_first_block</div><div class="ttdoc">count of segments in the first block </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00182">concurrent_vector.h:182</a></div></div>
<div class="ttc" id="a00169_html_acc5232333cf13be4c77bdfe7282f7e14"><div class="ttname"><a href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">tbb::internal::concurrent_vector_base_v3::my_segment</a></div><div class="ttdeci">atomic&lt; segment_t * &gt; my_segment</div><div class="ttdoc">Pointer to the segments table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00188">concurrent_vector.h:188</a></div></div>
<div class="ttc" id="a00169_html_aa8ab12f2be0114336e7bb0c291e611a2"><div class="ttname"><a href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">tbb::internal::concurrent_vector_base_v3::internal_clear</a></div><div class="ttdeci">segment_index_t __TBB_EXPORTED_METHOD internal_clear(internal_array_op1 destroy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00505">concurrent_vector.cpp:505</a></div></div>
<div class="ttc" id="a01098_html_affef623b71eccade29a6276f789315b8"><div class="ttname"><a href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a></div><div class="ttdeci">#define __TBB_RETHROW()</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00290">tbb_stddef.h:290</a></div></div>
<div class="ttc" id="a01133_html_acf23419eb6d3adac787a4fee78cb3c27"><div class="ttname"><a href="a01133.html#acf23419eb6d3adac787a4fee78cb3c27">tbb::internal::first</a></div><div class="ttdeci">auto first(Container &amp;c) -&gt; decltype(begin(c))</div><div class="ttdef"><b>Definition:</b> <a href="a00953_source.html#l00038">_range_iterator.h:38</a></div></div>
<div class="ttc" id="a00168_html_a874a5d44cc3dc7c4b67b3b52b8fc4bff"><div class="ttname"><a href="a00168.html#a874a5d44cc3dc7c4b67b3b52b8fc4bff">tbb::concurrent_vector::internal_assign_range</a></div><div class="ttdeci">void internal_assign_range(I first, I last, is_integer_tag&lt; true &gt; *)</div><div class="ttdoc">assign integer items by copying when arguments are treated as iterators. See C++ Standard 2003 23...</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01053">concurrent_vector.h:1053</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab5bcaededc9a00e7aaecd6c262fd0b38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::~<a class="el" href="a00168.html">concurrent_vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear and destroy vector. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01016">1016</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;                         {</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;        segment_t *table = <a class="code" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a>.load&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;();</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;        <a class="code" href="a00168.html#a496efbef33d4076867c075c67793aa6c">internal_free_segments</a>( table, <a class="code" href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">internal_clear</a>(&amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>), <a class="code" href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">my_first_block</a>.<a class="code" href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">load</a>&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;() );</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;        <span class="comment">// base class destructor call should be then</span></div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;    }</div><div class="ttc" id="a00083_html_a8451d0ce6e14c18c64c4b02436dbdc7d"><div class="ttname"><a href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">tbb::internal::atomic_impl::load</a></div><div class="ttdeci">value_type load() const </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00306">atomic.h:306</a></div></div>
<div class="ttc" id="a00168_html_a496efbef33d4076867c075c67793aa6c"><div class="ttname"><a href="a00168.html#a496efbef33d4076867c075c67793aa6c">tbb::concurrent_vector::internal_free_segments</a></div><div class="ttdeci">void internal_free_segments(segment_t table[], segment_index_t k, segment_index_t first_block)</div><div class="ttdoc">Free k segments from table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01209">concurrent_vector.h:1209</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a01113_html_adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5"><div class="ttname"><a href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">tbb::relaxed</a></div><div class="ttdoc">No ordering. </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00051">atomic.h:51</a></div></div>
<div class="ttc" id="a00169_html_ad9d3103757a1ef6a70a597d6b174d5c7"><div class="ttname"><a href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">tbb::internal::concurrent_vector_base_v3::my_first_block</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_first_block</div><div class="ttdoc">count of segments in the first block </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00182">concurrent_vector.h:182</a></div></div>
<div class="ttc" id="a00169_html_acc5232333cf13be4c77bdfe7282f7e14"><div class="ttname"><a href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">tbb::internal::concurrent_vector_base_v3::my_segment</a></div><div class="ttdeci">atomic&lt; segment_t * &gt; my_segment</div><div class="ttdoc">Pointer to the segments table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00188">concurrent_vector.h:188</a></div></div>
<div class="ttc" id="a00169_html_aa8ab12f2be0114336e7bb0c291e611a2"><div class="ttname"><a href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">tbb::internal::concurrent_vector_base_v3::internal_clear</a></div><div class="ttdeci">segment_index_t __TBB_EXPORTED_METHOD internal_clear(internal_array_op1 destroy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00505">concurrent_vector.cpp:505</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a87355dce93d0882aa73333a35c9b367c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assign n items by copying t item </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00982">982</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;                                                {</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;        <a class="code" href="a00168.html#a526ba408fb3064ef846940d633b8f365">clear</a>();</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;        <a class="code" href="a00169.html#a57151343a7f7c09dfc70bad5f149c417">internal_resize</a>( n, <span class="keyword">sizeof</span>(T), <a class="code" href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">max_size</a>(), static_cast&lt;const void*&gt;(&amp;t), &amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>, &amp;<a class="code" href="a00168.html#a615b7ebb3f9219014924b523c44e085e">initialize_array_by</a> );</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;    }</div><div class="ttc" id="a00168_html_a526ba408fb3064ef846940d633b8f365"><div class="ttname"><a href="a00168.html#a526ba408fb3064ef846940d633b8f365">tbb::concurrent_vector::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdoc">Clear container while keeping memory allocated. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01011">concurrent_vector.h:1011</a></div></div>
<div class="ttc" id="a00168_html_a0ec9c3ab3360e04bdaa5174956a3206d"><div class="ttname"><a href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">tbb::concurrent_vector::max_size</a></div><div class="ttdeci">size_type max_size() const </div><div class="ttdoc">Upper bound on argument to reserve. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00926">concurrent_vector.h:926</a></div></div>
<div class="ttc" id="a00169_html_a57151343a7f7c09dfc70bad5f149c417"><div class="ttname"><a href="a00169.html#a57151343a7f7c09dfc70bad5f149c417">tbb::internal::concurrent_vector_base_v3::internal_resize</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_resize(size_type n, size_type element_size, size_type max_size, const void *src, internal_array_op1 destroy, internal_array_op2 init)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00490">concurrent_vector.cpp:490</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a00168_html_a615b7ebb3f9219014924b523c44e085e"><div class="ttname"><a href="a00168.html#a615b7ebb3f9219014924b523c44e085e">tbb::concurrent_vector::initialize_array_by</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC initialize_array_by(void *begin, const void *src, size_type n)</div><div class="ttdoc">Copy-construct n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01288">concurrent_vector.h:1288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7bb5399a8499f88cf859eab39f0ed9e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<div class="memtemplate">
template&lt;class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assign range [first, last) </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00989">989</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;                                 {</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;        <a class="code" href="a00168.html#a526ba408fb3064ef846940d633b8f365">clear</a>(); <a class="code" href="a00168.html#a874a5d44cc3dc7c4b67b3b52b8fc4bff">internal_assign_range</a>( <a class="code" href="a01133.html#acf23419eb6d3adac787a4fee78cb3c27">first</a>, <a class="code" href="a01133.html#acb741ec0fd6aa234c464640f37d7c812">last</a>, <span class="keyword">static_cast&lt;</span>is_integer_tag&lt;std::numeric_limits&lt;I&gt;::is_integer<span class="keyword">&gt;</span> *&gt;(0) );</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;    }</div><div class="ttc" id="a01133_html_acb741ec0fd6aa234c464640f37d7c812"><div class="ttname"><a href="a01133.html#acb741ec0fd6aa234c464640f37d7c812">tbb::internal::last</a></div><div class="ttdeci">auto last(Container &amp;c) -&gt; decltype(begin(c))</div><div class="ttdef"><b>Definition:</b> <a href="a00953_source.html#l00044">_range_iterator.h:44</a></div></div>
<div class="ttc" id="a00168_html_a526ba408fb3064ef846940d633b8f365"><div class="ttname"><a href="a00168.html#a526ba408fb3064ef846940d633b8f365">tbb::concurrent_vector::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdoc">Clear container while keeping memory allocated. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01011">concurrent_vector.h:1011</a></div></div>
<div class="ttc" id="a01133_html_acf23419eb6d3adac787a4fee78cb3c27"><div class="ttname"><a href="a01133.html#acf23419eb6d3adac787a4fee78cb3c27">tbb::internal::first</a></div><div class="ttdeci">auto first(Container &amp;c) -&gt; decltype(begin(c))</div><div class="ttdef"><b>Definition:</b> <a href="a00953_source.html#l00038">_range_iterator.h:38</a></div></div>
<div class="ttc" id="a00168_html_a874a5d44cc3dc7c4b67b3b52b8fc4bff"><div class="ttname"><a href="a00168.html#a874a5d44cc3dc7c4b67b3b52b8fc4bff">tbb::concurrent_vector::internal_assign_range</a></div><div class="ttdeci">void internal_assign_range(I first, I last, is_integer_tag&lt; true &gt; *)</div><div class="ttdoc">assign integer items by copying when arguments are treated as iterators. See C++ Standard 2003 23...</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01053">concurrent_vector.h:1053</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a584d6cda5794441b19d4f02bde399dff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assigns an initializer list </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00995">995</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;                                                  {</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;        <a class="code" href="a00168.html#a526ba408fb3064ef846940d633b8f365">clear</a>(); <a class="code" href="a00168.html#aebff613825ded62ed4648117829f5942">internal_assign_iterators</a>( init_list.begin(), init_list.end());</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;    }</div><div class="ttc" id="a00168_html_aebff613825ded62ed4648117829f5942"><div class="ttname"><a href="a00168.html#aebff613825ded62ed4648117829f5942">tbb::concurrent_vector::internal_assign_iterators</a></div><div class="ttdeci">void internal_assign_iterators(I first, I last)</div><div class="ttdoc">assign by iterators </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01262">concurrent_vector.h:1262</a></div></div>
<div class="ttc" id="a00168_html_a526ba408fb3064ef846940d633b8f365"><div class="ttname"><a href="a00168.html#a526ba408fb3064ef846940d633b8f365">tbb::concurrent_vector::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdoc">Clear container while keeping memory allocated. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01011">concurrent_vector.h:1011</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a36c957884197e510b1d7176aaf4736a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::assign_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign (using operator=) n instances of T, starting at "dst" by assigning according element of src array. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01323">1323</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>References <a class="el" href="a00387.html#a966c7386ce58e94878aa48d5fcbe2c91">tbb::concurrent_vector&lt; T, A &gt;::internal_loop_guide::assign()</a>.</p>
<div class="fragment"><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;                                                                                    {</div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;    internal_loop_guide loop(n, dst); loop.assign(src);</div><div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;}</div></div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00168_a36c957884197e510b1d7176aaf4736a0_cgraph.svg" width="363" height="67"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a629a29eb21e528414b9d5c9becfe05cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a412441e93ad8656f96b14c5ecb9d817f">reference</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get reference to element at given index. Throws exceptions on errors. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00870">870</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;                                    {</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="a00168.html#abc22450ffcfb9d0b946f89869ca0c894">internal_subscript_with_exceptions</a>(index);</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;    }</div><div class="ttc" id="a00168_html_abc22450ffcfb9d0b946f89869ca0c894"><div class="ttname"><a href="a00168.html#abc22450ffcfb9d0b946f89869ca0c894">tbb::concurrent_vector::internal_subscript_with_exceptions</a></div><div class="ttdeci">T &amp; internal_subscript_with_exceptions(size_type index) const </div><div class="ttdoc">Get reference to element at given index with errors checks. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01244">concurrent_vector.h:1244</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae4dc6c1b55c0e0b73f0a8675ef2b60a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get const reference to element at given index. Throws exceptions on errors. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00875">875</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;                                                {</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="a00168.html#abc22450ffcfb9d0b946f89869ca0c894">internal_subscript_with_exceptions</a>(index);</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;    }</div><div class="ttc" id="a00168_html_abc22450ffcfb9d0b946f89869ca0c894"><div class="ttname"><a href="a00168.html#abc22450ffcfb9d0b946f89869ca0c894">tbb::concurrent_vector::internal_subscript_with_exceptions</a></div><div class="ttdeci">T &amp; internal_subscript_with_exceptions(size_type index) const </div><div class="ttdoc">Get reference to element at given index with errors checks. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01244">concurrent_vector.h:1244</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aaee3ddf1d05238a8a6887f6d824b76f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a412441e93ad8656f96b14c5ecb9d817f">reference</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the last item </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00969">969</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;                     {</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;        <a class="code" href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a>( <a class="code" href="a00168.html#a803268c16e3688ff4681251947d257c7">size</a>()&gt;0, NULL);</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="a00168.html#a4ea8843a774a9f52a47e6661fccbde19">internal_subscript</a>( <a class="code" href="a00168.html#a803268c16e3688ff4681251947d257c7">size</a>()-1 );</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;    }</div><div class="ttc" id="a00168_html_a4ea8843a774a9f52a47e6661fccbde19"><div class="ttname"><a href="a00168.html#a4ea8843a774a9f52a47e6661fccbde19">tbb::concurrent_vector::internal_subscript</a></div><div class="ttdeci">T &amp; internal_subscript(size_type index) const </div><div class="ttdoc">Get reference to element at given index. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01227">concurrent_vector.h:1227</a></div></div>
<div class="ttc" id="a00168_html_a803268c16e3688ff4681251947d257c7"><div class="ttname"><a href="a00168.html#a803268c16e3688ff4681251947d257c7">tbb::concurrent_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Return size of vector. It may include elements under construction. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00893">concurrent_vector.h:893</a></div></div>
<div class="ttc" id="a01098_html_a7b58d28a34a1717e2ddb591f00658b10"><div class="ttname"><a href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a></div><div class="ttdeci">#define __TBB_ASSERT(predicate, comment)</div><div class="ttdoc">No-op version of __TBB_ASSERT. </div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00169">tbb_stddef.h:169</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acf66eb1e82dbcb430d9926a23711c720"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the last item const </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00974">974</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;                                 {</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;        <a class="code" href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a>( <a class="code" href="a00168.html#a803268c16e3688ff4681251947d257c7">size</a>()&gt;0, NULL);</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="a00168.html#a4ea8843a774a9f52a47e6661fccbde19">internal_subscript</a>( <a class="code" href="a00168.html#a803268c16e3688ff4681251947d257c7">size</a>()-1 );</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;    }</div><div class="ttc" id="a00168_html_a4ea8843a774a9f52a47e6661fccbde19"><div class="ttname"><a href="a00168.html#a4ea8843a774a9f52a47e6661fccbde19">tbb::concurrent_vector::internal_subscript</a></div><div class="ttdeci">T &amp; internal_subscript(size_type index) const </div><div class="ttdoc">Get reference to element at given index. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01227">concurrent_vector.h:1227</a></div></div>
<div class="ttc" id="a00168_html_a803268c16e3688ff4681251947d257c7"><div class="ttname"><a href="a00168.html#a803268c16e3688ff4681251947d257c7">tbb::concurrent_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Return size of vector. It may include elements under construction. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00893">concurrent_vector.h:893</a></div></div>
<div class="ttc" id="a01098_html_a7b58d28a34a1717e2ddb591f00658b10"><div class="ttname"><a href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a></div><div class="ttdeci">#define __TBB_ASSERT(predicate, comment)</div><div class="ttdoc">No-op version of __TBB_ASSERT. </div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00169">tbb_stddef.h:169</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab55636c80368ad7d400f3200313fcf5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start iterator </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00933">933</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>Referenced by <a class="el" href="a01113.html#a79ecee2d23f2486c03e720ab9e3ac36c">tbb::operator==()</a>.</p>
<div class="fragment"><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>(*<span class="keyword">this</span>,0);}</div><div class="ttc" id="a00168_html_a4cee8eaee236867c0b6e87309380cb0f"><div class="ttname"><a href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">tbb::concurrent_vector::iterator</a></div><div class="ttdeci">internal::vector_iterator&lt; concurrent_vector, T &gt; iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00577">concurrent_vector.h:577</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00168_ab55636c80368ad7d400f3200313fcf5f_icgraph.svg" width="322" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad3eb33d1b10a988a87cc708ceb08f3a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start const iterator </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00937">937</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a>(*<span class="keyword">this</span>,0);}</div><div class="ttc" id="a00168_html_aa9a55035528c055ae985db2a61c8b0b2"><div class="ttname"><a href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">tbb::concurrent_vector::const_iterator</a></div><div class="ttdeci">internal::vector_iterator&lt; concurrent_vector, const T &gt; const_iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00578">concurrent_vector.h:578</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a96c2ae9dfedc24d62554feb627df76c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum size to which array can grow without allocating more memory. Concurrent allocations are not included in the value. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00902">902</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="a00169.html#aa358b781e8b59f324feba96f76f05757">internal_capacity</a>();}</div><div class="ttc" id="a00169_html_aa358b781e8b59f324feba96f76f05757"><div class="ttname"><a href="a00169.html#aa358b781e8b59f324feba96f76f05757">tbb::internal::concurrent_vector_base_v3::internal_capacity</a></div><div class="ttdeci">size_type __TBB_EXPORTED_METHOD internal_capacity() const </div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00333">concurrent_vector.cpp:333</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7a1c5441fa480c07ef37d9206b6260cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>start const iterator </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00941">941</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a>(*<span class="keyword">this</span>,0);}</div><div class="ttc" id="a00168_html_aa9a55035528c055ae985db2a61c8b0b2"><div class="ttname"><a href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">tbb::concurrent_vector::const_iterator</a></div><div class="ttdeci">internal::vector_iterator&lt; concurrent_vector, const T &gt; const_iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00578">concurrent_vector.h:578</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9ea80faf139feb54d6576c036e4ba898"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>end const iterator </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00943">943</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a>(*<span class="keyword">this</span>,<a class="code" href="a00168.html#a803268c16e3688ff4681251947d257c7">size</a>());}</div><div class="ttc" id="a00168_html_aa9a55035528c055ae985db2a61c8b0b2"><div class="ttname"><a href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">tbb::concurrent_vector::const_iterator</a></div><div class="ttdeci">internal::vector_iterator&lt; concurrent_vector, const T &gt; const_iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00578">concurrent_vector.h:578</a></div></div>
<div class="ttc" id="a00168_html_a803268c16e3688ff4681251947d257c7"><div class="ttname"><a href="a00168.html#a803268c16e3688ff4681251947d257c7">tbb::concurrent_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Return size of vector. It may include elements under construction. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00893">concurrent_vector.h:893</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a526ba408fb3064ef846940d633b8f365"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear container while keeping memory allocated. </p>
<p>To free up the memory, use in conjunction with method compact(). Not thread safe </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01011">1011</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>Referenced by <a class="el" href="a00245.html#a85a0d8f088ef1ee07aeb2c0e944a4a5e">tbb::interface6::enumerable_thread_specific&lt; T, Allocator, ETS_key_type &gt;::clear()</a>.</p>
<div class="fragment"><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;                 {</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;        <a class="code" href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">internal_clear</a>(&amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>);</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;    }</div><div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a00169_html_aa8ab12f2be0114336e7bb0c291e611a2"><div class="ttname"><a href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">tbb::internal::concurrent_vector_base_v3::internal_clear</a></div><div class="ttdeci">segment_index_t __TBB_EXPORTED_METHOD internal_clear(internal_array_op1 destroy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00505">concurrent_vector.cpp:505</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00168_a526ba408fb3064ef846940d633b8f365_icgraph.svg" width="391" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a99cf2fd728e2a39dfc51ebe41ccc3779"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::copy_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-construct n instances of T by copying single element pointed to by src, starting at "dst". </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01293">1293</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>References <a class="el" href="a00387.html#aa5e11634fc5b8a5fff479d8e4e653195">tbb::concurrent_vector&lt; T, A &gt;::internal_loop_guide::copy()</a>.</p>
<div class="fragment"><div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;                                                                                  {</div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;    internal_loop_guide loop(n, dst); loop.copy(src);</div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;}</div></div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00168_a99cf2fd728e2a39dfc51ebe41ccc3779_cgraph.svg" width="388" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a85a76288d24c088a9b751664f37d5c6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a01084.html#ab6dd3eee12dcbf8bc4c41513c4c4c9fb">__TBB_EXPORTED_FUNC</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::copy_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname"><em>p_type_erased_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-construct n instances of T, starting at "dst" by iterator range of [p_type_erased_iterator, p_type_erased_iterator+n). </p>

</div>
</div>
<a class="anchor" id="a96e2626d160361d8c6f4193ca0c7a4dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::copy_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname"><em>p_type_erased_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l01317">1317</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>References <a class="el" href="a00387.html#a38612ea8f89823cb9476b794d0a5db8f">tbb::concurrent_vector&lt; T, A &gt;::internal_loop_guide::iterate()</a>.</p>
<div class="fragment"><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;                                                                                                    {</div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;    internal_loop_guide loop(n, dst);</div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;    loop.iterate( *(static_cast&lt;I*&gt;(const_cast&lt;void*&gt;(p_type_erased_iterator))) );</div><div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;}</div></div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00168_a96e2626d160361d8c6f4193ca0c7a4dd_cgraph.svg" width="363" height="67"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2627db4a7949522ea4727320b23a6348"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#ada43b048144c3814036da624d3bb8c58">const_reverse_iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reverse start const iterator </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00953">953</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="a00168.html#ada43b048144c3814036da624d3bb8c58">const_reverse_iterator</a>(<a class="code" href="a00168.html#aad2c07653375e4a5f89c33b375eda610">end</a>());}</div><div class="ttc" id="a00168_html_ada43b048144c3814036da624d3bb8c58"><div class="ttname"><a href="a00168.html#ada43b048144c3814036da624d3bb8c58">tbb::concurrent_vector::const_reverse_iterator</a></div><div class="ttdeci">std::reverse_iterator&lt; const_iterator &gt; const_reverse_iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00583">concurrent_vector.h:583</a></div></div>
<div class="ttc" id="a00168_html_aad2c07653375e4a5f89c33b375eda610"><div class="ttname"><a href="a00168.html#aad2c07653375e4a5f89c33b375eda610">tbb::concurrent_vector::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdoc">end iterator </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00935">concurrent_vector.h:935</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad097225c529dbb24cc0e13a444ab4752"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#ada43b048144c3814036da624d3bb8c58">const_reverse_iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reverse end const iterator </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00955">955</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="a00168.html#ada43b048144c3814036da624d3bb8c58">const_reverse_iterator</a>(<a class="code" href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">begin</a>());}</div><div class="ttc" id="a00168_html_ada43b048144c3814036da624d3bb8c58"><div class="ttname"><a href="a00168.html#ada43b048144c3814036da624d3bb8c58">tbb::concurrent_vector::const_reverse_iterator</a></div><div class="ttdeci">std::reverse_iterator&lt; const_iterator &gt; const_reverse_iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00583">concurrent_vector.h:583</a></div></div>
<div class="ttc" id="a00168_html_ab55636c80368ad7d400f3200313fcf5f"><div class="ttname"><a href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">tbb::concurrent_vector::begin</a></div><div class="ttdeci">iterator begin()</div><div class="ttdoc">start iterator </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00933">concurrent_vector.h:933</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a68c028b499fb365ba97f067bdcddb0d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::destroy_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy n instances of T, starting at "begin". </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01333">1333</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>References <a class="el" href="a01016.html#a50deeaccd8b2b4be185e1befc7860258">begin</a>.</p>
<div class="fragment"><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;                                                                      {</div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;    T* array = <span class="keyword">static_cast&lt;</span>T*<span class="keyword">&gt;</span>(<a class="code" href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">begin</a>);</div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;    <span class="keywordflow">for</span>( <a class="code" href="a00168.html#ada098ff121699bfed7ae37e759eff93d">size_type</a> j=n; j&gt;0; --j )</div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;        array[j-1].~T(); <span class="comment">// destructors are supposed to not throw any exceptions</span></div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;}</div><div class="ttc" id="a00168_html_ada098ff121699bfed7ae37e759eff93d"><div class="ttname"><a href="a00168.html#ada098ff121699bfed7ae37e759eff93d">tbb::concurrent_vector::size_type</a></div><div class="ttdeci">internal::concurrent_vector_base_v3::size_type size_type</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00567">concurrent_vector.h:567</a></div></div>
<div class="ttc" id="a00168_html_ab55636c80368ad7d400f3200313fcf5f"><div class="ttname"><a href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">tbb::concurrent_vector::begin</a></div><div class="ttdeci">iterator begin()</div><div class="ttdoc">start iterator </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00933">concurrent_vector.h:933</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afae4c378515b89cc2b0a11c8cf1bcc50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push item, create item "in place" with provided arguments. </p>
<p>Returns iterator pointing to the new element. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00849">849</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;    {</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;        push_back_helper prolog(*<span class="keyword">this</span>);</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;        <span class="keyword">new</span>(prolog.internal_push_back_result()) T(std::forward&lt;Args&gt;(args)...);</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;        <span class="keywordflow">return</span> prolog.return_iterator_and_dismiss();</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa3f6774107e65642f73c0dcc9a962fe7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return false if vector is not empty or has elements under construction at least. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00899">899</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>Referenced by <a class="el" href="a00245.html#adfa4b2e13e47ab825dc40c4f195d2bc5">tbb::interface6::enumerable_thread_specific&lt; T, Allocator, ETS_key_type &gt;::empty()</a>.</p>
<div class="fragment"><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;{<span class="keywordflow">return</span> !<a class="code" href="a00169.html#a1f3773deae9ac723547700419690b043">my_early_size</a>;}</div><div class="ttc" id="a00169_html_a1f3773deae9ac723547700419690b043"><div class="ttname"><a href="a00169.html#a1f3773deae9ac723547700419690b043">tbb::internal::concurrent_vector_base_v3::my_early_size</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_early_size</div><div class="ttdoc">Requested size of vector. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00185">concurrent_vector.h:185</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00168_aa3f6774107e65642f73c0dcc9a962fe7_icgraph.svg" width="391" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aad2c07653375e4a5f89c33b375eda610"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>end iterator </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00935">935</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>Referenced by <a class="el" href="a01113.html#a79ecee2d23f2486c03e720ab9e3ac36c">tbb::operator==()</a>.</p>
<div class="fragment"><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>(*<span class="keyword">this</span>,<a class="code" href="a00168.html#a803268c16e3688ff4681251947d257c7">size</a>());}</div><div class="ttc" id="a00168_html_a4cee8eaee236867c0b6e87309380cb0f"><div class="ttname"><a href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">tbb::concurrent_vector::iterator</a></div><div class="ttdeci">internal::vector_iterator&lt; concurrent_vector, T &gt; iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00577">concurrent_vector.h:577</a></div></div>
<div class="ttc" id="a00168_html_a803268c16e3688ff4681251947d257c7"><div class="ttname"><a href="a00168.html#a803268c16e3688ff4681251947d257c7">tbb::concurrent_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Return size of vector. It may include elements under construction. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00893">concurrent_vector.h:893</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00168_aad2c07653375e4a5f89c33b375eda610_icgraph.svg" width="351" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6a4ad0795a19d94df24595e748f0b193"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>end const iterator </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00939">939</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">const_iterator</a>(*<span class="keyword">this</span>,<a class="code" href="a00168.html#a803268c16e3688ff4681251947d257c7">size</a>());}</div><div class="ttc" id="a00168_html_aa9a55035528c055ae985db2a61c8b0b2"><div class="ttname"><a href="a00168.html#aa9a55035528c055ae985db2a61c8b0b2">tbb::concurrent_vector::const_iterator</a></div><div class="ttdeci">internal::vector_iterator&lt; concurrent_vector, const T &gt; const_iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00578">concurrent_vector.h:578</a></div></div>
<div class="ttc" id="a00168_html_a803268c16e3688ff4681251947d257c7"><div class="ttname"><a href="a00168.html#a803268c16e3688ff4681251947d257c7">tbb::concurrent_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Return size of vector. It may include elements under construction. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00893">concurrent_vector.h:893</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9bfc6d733cf543280b691ed8d7b7908a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a412441e93ad8656f96b14c5ecb9d817f">reference</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the first item </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00957">957</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;                      {</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;        <a class="code" href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a>( <a class="code" href="a00168.html#a803268c16e3688ff4681251947d257c7">size</a>()&gt;0, NULL);</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;        <span class="keyword">const</span> segment_value_t&amp; segment_value = <a class="code" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a>[0].template load&lt;relaxed&gt;();</div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;        <span class="keywordflow">return</span> (segment_value.template pointer&lt;T&gt;())[0];</div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;    }</div><div class="ttc" id="a00168_html_a803268c16e3688ff4681251947d257c7"><div class="ttname"><a href="a00168.html#a803268c16e3688ff4681251947d257c7">tbb::concurrent_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Return size of vector. It may include elements under construction. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00893">concurrent_vector.h:893</a></div></div>
<div class="ttc" id="a00169_html_acc5232333cf13be4c77bdfe7282f7e14"><div class="ttname"><a href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">tbb::internal::concurrent_vector_base_v3::my_segment</a></div><div class="ttdeci">atomic&lt; segment_t * &gt; my_segment</div><div class="ttdoc">Pointer to the segments table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00188">concurrent_vector.h:188</a></div></div>
<div class="ttc" id="a01098_html_a7b58d28a34a1717e2ddb591f00658b10"><div class="ttname"><a href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a></div><div class="ttdeci">#define __TBB_ASSERT(predicate, comment)</div><div class="ttdoc">No-op version of __TBB_ASSERT. </div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00169">tbb_stddef.h:169</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9067259572c2c41d014840d0f9d3cdce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the first item const </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00963">963</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;                                  {</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;        <a class="code" href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a>( <a class="code" href="a00168.html#a803268c16e3688ff4681251947d257c7">size</a>()&gt;0, NULL);</div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;        <span class="keyword">const</span> segment_value_t&amp; segment_value = <a class="code" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a>[0].template load&lt;relaxed&gt;();</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;        <span class="keywordflow">return</span> (segment_value.template pointer&lt;const T&gt;())[0];</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;    }</div><div class="ttc" id="a00168_html_a803268c16e3688ff4681251947d257c7"><div class="ttname"><a href="a00168.html#a803268c16e3688ff4681251947d257c7">tbb::concurrent_vector::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdoc">Return size of vector. It may include elements under construction. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00893">concurrent_vector.h:893</a></div></div>
<div class="ttc" id="a00169_html_acc5232333cf13be4c77bdfe7282f7e14"><div class="ttname"><a href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">tbb::internal::concurrent_vector_base_v3::my_segment</a></div><div class="ttdeci">atomic&lt; segment_t * &gt; my_segment</div><div class="ttdoc">Pointer to the segments table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00188">concurrent_vector.h:188</a></div></div>
<div class="ttc" id="a01098_html_a7b58d28a34a1717e2ddb591f00658b10"><div class="ttname"><a href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a></div><div class="ttdeci">#define __TBB_ASSERT(predicate, comment)</div><div class="ttdoc">No-op version of __TBB_ASSERT. </div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00169">tbb_stddef.h:169</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a88b62a9614d3f2b59c9c7c1a2143fb1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00052.html#a86c703781d0a1e1d4d98d20bf6319a8a">allocator_type</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return allocator object </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00979">979</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;{ <span class="keywordflow">return</span> this-&gt;<a class="code" href="a00052.html#a72f9ed5aac2cf597dc1e6c8e614173b3">my_allocator</a>; }</div><div class="ttc" id="a00052_html_a72f9ed5aac2cf597dc1e6c8e614173b3"><div class="ttname"><a href="a00052.html#a72f9ed5aac2cf597dc1e6c8e614173b3">tbb::internal::allocator_base::my_allocator</a></div><div class="ttdeci">allocator_type my_allocator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00473">concurrent_vector.h:473</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab89c2db5358048debdc282ff995caffb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::grow_by </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Grow by "delta" elements. </p>
<p>Returns iterator pointing to the first new element. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00776">776</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>Referenced by <a class="el" href="a00245.html#ade1bf325d0bd1ba6fb6ec3fd4b3c3f13">tbb::interface6::enumerable_thread_specific&lt; T, Allocator, ETS_key_type &gt;::create_local()</a>, <a class="el" href="a00245.html#aeceee0c7c771460d47bde9e4205c5a80">tbb::interface6::enumerable_thread_specific&lt; T, Allocator, ETS_key_type &gt;::create_local_by_copy()</a>, and <a class="el" href="a00245.html#a3243aaad22248ef78a3976b37bdf7da1">tbb::interface6::enumerable_thread_specific&lt; T, Allocator, ETS_key_type &gt;::create_local_by_move()</a>.</p>
<div class="fragment"><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;                                        {</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>(*<span class="keyword">this</span>, delta ? <a class="code" href="a00169.html#a9334b74e81786c565f413134cf28b559">internal_grow_by</a>( delta, <span class="keyword">sizeof</span>(T), &amp;<a class="code" href="a00168.html#a12b1a671033a824c0027720427072328">initialize_array</a>, NULL ) : <a class="code" href="a00169.html#a1f3773deae9ac723547700419690b043">my_early_size</a>.<a class="code" href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">load</a>());</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;    }</div><div class="ttc" id="a00168_html_a4cee8eaee236867c0b6e87309380cb0f"><div class="ttname"><a href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">tbb::concurrent_vector::iterator</a></div><div class="ttdeci">internal::vector_iterator&lt; concurrent_vector, T &gt; iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00577">concurrent_vector.h:577</a></div></div>
<div class="ttc" id="a00168_html_a12b1a671033a824c0027720427072328"><div class="ttname"><a href="a00168.html#a12b1a671033a824c0027720427072328">tbb::concurrent_vector::initialize_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC initialize_array(void *begin, const void *, size_type n)</div><div class="ttdoc">Construct n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01283">concurrent_vector.h:1283</a></div></div>
<div class="ttc" id="a00083_html_a8451d0ce6e14c18c64c4b02436dbdc7d"><div class="ttname"><a href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">tbb::internal::atomic_impl::load</a></div><div class="ttdeci">value_type load() const </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00306">atomic.h:306</a></div></div>
<div class="ttc" id="a00169_html_a9334b74e81786c565f413134cf28b559"><div class="ttname"><a href="a00169.html#a9334b74e81786c565f413134cf28b559">tbb::internal::concurrent_vector_base_v3::internal_grow_by</a></div><div class="ttdeci">size_type __TBB_EXPORTED_METHOD internal_grow_by(size_type delta, size_type element_size, internal_array_op2 init, const void *src)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00471">concurrent_vector.cpp:471</a></div></div>
<div class="ttc" id="a00169_html_a1f3773deae9ac723547700419690b043"><div class="ttname"><a href="a00169.html#a1f3773deae9ac723547700419690b043">tbb::internal::concurrent_vector_base_v3::my_early_size</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_early_size</div><div class="ttdoc">Requested size of vector. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00185">concurrent_vector.h:185</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00168_ab89c2db5358048debdc282ff995caffb_icgraph.svg" width="406" height="212"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa11fc991cda82cf93789fce31b37a16c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::grow_by </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Grow by "delta" elements using copying constructor. </p>
<p>Returns iterator pointing to the first new element. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00782">782</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;                                                           {</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>(*<span class="keyword">this</span>, delta ? <a class="code" href="a00169.html#a9334b74e81786c565f413134cf28b559">internal_grow_by</a>( delta, <span class="keyword">sizeof</span>(T), &amp;<a class="code" href="a00168.html#a615b7ebb3f9219014924b523c44e085e">initialize_array_by</a>, static_cast&lt;const void*&gt;(&amp;t) ) : <a class="code" href="a00169.html#a1f3773deae9ac723547700419690b043">my_early_size</a>.<a class="code" href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">load</a>());</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;    }</div><div class="ttc" id="a00168_html_a4cee8eaee236867c0b6e87309380cb0f"><div class="ttname"><a href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">tbb::concurrent_vector::iterator</a></div><div class="ttdeci">internal::vector_iterator&lt; concurrent_vector, T &gt; iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00577">concurrent_vector.h:577</a></div></div>
<div class="ttc" id="a00083_html_a8451d0ce6e14c18c64c4b02436dbdc7d"><div class="ttname"><a href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">tbb::internal::atomic_impl::load</a></div><div class="ttdeci">value_type load() const </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00306">atomic.h:306</a></div></div>
<div class="ttc" id="a00169_html_a9334b74e81786c565f413134cf28b559"><div class="ttname"><a href="a00169.html#a9334b74e81786c565f413134cf28b559">tbb::internal::concurrent_vector_base_v3::internal_grow_by</a></div><div class="ttdeci">size_type __TBB_EXPORTED_METHOD internal_grow_by(size_type delta, size_type element_size, internal_array_op2 init, const void *src)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00471">concurrent_vector.cpp:471</a></div></div>
<div class="ttc" id="a00168_html_a615b7ebb3f9219014924b523c44e085e"><div class="ttname"><a href="a00168.html#a615b7ebb3f9219014924b523c44e085e">tbb::concurrent_vector::initialize_array_by</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC initialize_array_by(void *begin, const void *src, size_type n)</div><div class="ttdoc">Copy-construct n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01288">concurrent_vector.h:1288</a></div></div>
<div class="ttc" id="a00169_html_a1f3773deae9ac723547700419690b043"><div class="ttname"><a href="a00169.html#a1f3773deae9ac723547700419690b043">tbb::internal::concurrent_vector_base_v3::my_early_size</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_early_size</div><div class="ttdoc">Requested size of vector. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00185">concurrent_vector.h:185</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acfd74483ff523213b78f44fb914c8eb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<div class="memtemplate">
template&lt;typename I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::grow_by </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns iterator pointing to the first new element. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00788">788</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;                                        {</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;        <span class="keyword">typename</span> std::iterator_traits&lt;I&gt;::difference_type delta = std::distance(<a class="code" href="a01133.html#acf23419eb6d3adac787a4fee78cb3c27">first</a>, <a class="code" href="a01133.html#acb741ec0fd6aa234c464640f37d7c812">last</a>);</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;        <a class="code" href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a>( delta &gt;= 0, NULL);</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>(*<span class="keyword">this</span>, delta ? <a class="code" href="a00169.html#a9334b74e81786c565f413134cf28b559">internal_grow_by</a>(delta, <span class="keyword">sizeof</span>(T), &amp;copy_range&lt;I&gt;, static_cast&lt;const void*&gt;(&amp;<a class="code" href="a01133.html#acf23419eb6d3adac787a4fee78cb3c27">first</a>)) : <a class="code" href="a00169.html#a1f3773deae9ac723547700419690b043">my_early_size</a>.<a class="code" href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">load</a>());</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;    }</div><div class="ttc" id="a00168_html_a4cee8eaee236867c0b6e87309380cb0f"><div class="ttname"><a href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">tbb::concurrent_vector::iterator</a></div><div class="ttdeci">internal::vector_iterator&lt; concurrent_vector, T &gt; iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00577">concurrent_vector.h:577</a></div></div>
<div class="ttc" id="a01133_html_acb741ec0fd6aa234c464640f37d7c812"><div class="ttname"><a href="a01133.html#acb741ec0fd6aa234c464640f37d7c812">tbb::internal::last</a></div><div class="ttdeci">auto last(Container &amp;c) -&gt; decltype(begin(c))</div><div class="ttdef"><b>Definition:</b> <a href="a00953_source.html#l00044">_range_iterator.h:44</a></div></div>
<div class="ttc" id="a00083_html_a8451d0ce6e14c18c64c4b02436dbdc7d"><div class="ttname"><a href="a00083.html#a8451d0ce6e14c18c64c4b02436dbdc7d">tbb::internal::atomic_impl::load</a></div><div class="ttdeci">value_type load() const </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00306">atomic.h:306</a></div></div>
<div class="ttc" id="a00169_html_a9334b74e81786c565f413134cf28b559"><div class="ttname"><a href="a00169.html#a9334b74e81786c565f413134cf28b559">tbb::internal::concurrent_vector_base_v3::internal_grow_by</a></div><div class="ttdeci">size_type __TBB_EXPORTED_METHOD internal_grow_by(size_type delta, size_type element_size, internal_array_op2 init, const void *src)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00471">concurrent_vector.cpp:471</a></div></div>
<div class="ttc" id="a01098_html_a7b58d28a34a1717e2ddb591f00658b10"><div class="ttname"><a href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a></div><div class="ttdeci">#define __TBB_ASSERT(predicate, comment)</div><div class="ttdoc">No-op version of __TBB_ASSERT. </div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00169">tbb_stddef.h:169</a></div></div>
<div class="ttc" id="a00169_html_a1f3773deae9ac723547700419690b043"><div class="ttname"><a href="a00169.html#a1f3773deae9ac723547700419690b043">tbb::internal::concurrent_vector_base_v3::my_early_size</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_early_size</div><div class="ttdoc">Requested size of vector. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00185">concurrent_vector.h:185</a></div></div>
<div class="ttc" id="a01133_html_acf23419eb6d3adac787a4fee78cb3c27"><div class="ttname"><a href="a01133.html#acf23419eb6d3adac787a4fee78cb3c27">tbb::internal::first</a></div><div class="ttdeci">auto first(Container &amp;c) -&gt; decltype(begin(c))</div><div class="ttdef"><b>Definition:</b> <a href="a00953_source.html#l00038">_range_iterator.h:38</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a95f57f1529e0ebd1ca6bd2d60003fcab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::grow_by </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns iterator pointing to the first new element. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00797">797</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;                                                         {</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="a00168.html#ab89c2db5358048debdc282ff995caffb">grow_by</a>( init_list.begin(), init_list.end() );</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;    }</div><div class="ttc" id="a00168_html_ab89c2db5358048debdc282ff995caffb"><div class="ttname"><a href="a00168.html#ab89c2db5358048debdc282ff995caffb">tbb::concurrent_vector::grow_by</a></div><div class="ttdeci">iterator grow_by(size_type delta)</div><div class="ttdoc">Grow by &quot;delta&quot; elements. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00776">concurrent_vector.h:776</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae9ef9895e88f9bf036b379035c18f035"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::grow_to_at_least </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append minimal sequence of elements such that <a class="el" href="a00168.html#a803268c16e3688ff4681251947d257c7" title="Return size of vector. It may include elements under construction. ">size()</a>&gt;=n. </p>
<p>The new elements are default constructed. Blocks until all elements in range [0..n) are allocated. May return while other elements are being constructed by other threads. Returns iterator that points to beginning of appended sequence. If no elements were appended, returns iterator pointing to nth element. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00807">807</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;                                             {</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;        <a class="code" href="a00168.html#ada098ff121699bfed7ae37e759eff93d">size_type</a> m=0;</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;        <span class="keywordflow">if</span>( n ) {</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;            m = <a class="code" href="a00169.html#a558417c6b3314944dfa6182db71841e3">internal_grow_to_at_least_with_result</a>( n, <span class="keyword">sizeof</span>(T), &amp;<a class="code" href="a00168.html#a12b1a671033a824c0027720427072328">initialize_array</a>, NULL );</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;            <span class="keywordflow">if</span>( m&gt;n ) m=n;</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;        }</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>(*<span class="keyword">this</span>, m);</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;    };</div><div class="ttc" id="a00168_html_a4cee8eaee236867c0b6e87309380cb0f"><div class="ttname"><a href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">tbb::concurrent_vector::iterator</a></div><div class="ttdeci">internal::vector_iterator&lt; concurrent_vector, T &gt; iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00577">concurrent_vector.h:577</a></div></div>
<div class="ttc" id="a00168_html_a12b1a671033a824c0027720427072328"><div class="ttname"><a href="a00168.html#a12b1a671033a824c0027720427072328">tbb::concurrent_vector::initialize_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC initialize_array(void *begin, const void *, size_type n)</div><div class="ttdoc">Construct n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01283">concurrent_vector.h:1283</a></div></div>
<div class="ttc" id="a00168_html_ada098ff121699bfed7ae37e759eff93d"><div class="ttname"><a href="a00168.html#ada098ff121699bfed7ae37e759eff93d">tbb::concurrent_vector::size_type</a></div><div class="ttdeci">internal::concurrent_vector_base_v3::size_type size_type</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00567">concurrent_vector.h:567</a></div></div>
<div class="ttc" id="a00169_html_a558417c6b3314944dfa6182db71841e3"><div class="ttname"><a href="a00169.html#a558417c6b3314944dfa6182db71841e3">tbb::internal::concurrent_vector_base_v3::internal_grow_to_at_least_with_result</a></div><div class="ttdeci">size_type __TBB_EXPORTED_METHOD internal_grow_to_at_least_with_result(size_type new_size, size_type element_size, internal_array_op2 init, const void *src)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00438">concurrent_vector.cpp:438</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a422d9689ed72a5ef2b6b72f28e4143a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::grow_to_at_least </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogous to <a class="el" href="a00168.html#ae9ef9895e88f9bf036b379035c18f035" title="Append minimal sequence of elements such that size()&gt;=n. ">grow_to_at_least( size_type n )</a> with exception that the new elements are initialized by copying of t instead of default construction. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00818">818</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;                                                                {</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;        <a class="code" href="a00168.html#ada098ff121699bfed7ae37e759eff93d">size_type</a> m=0;</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;        <span class="keywordflow">if</span>( n ) {</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;            m = <a class="code" href="a00169.html#a558417c6b3314944dfa6182db71841e3">internal_grow_to_at_least_with_result</a>( n, <span class="keyword">sizeof</span>(T), &amp;<a class="code" href="a00168.html#a615b7ebb3f9219014924b523c44e085e">initialize_array_by</a>, &amp;t);</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;            <span class="keywordflow">if</span>( m&gt;n ) m=n;</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;        }</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a>(*<span class="keyword">this</span>, m);</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;    };</div><div class="ttc" id="a00168_html_a4cee8eaee236867c0b6e87309380cb0f"><div class="ttname"><a href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">tbb::concurrent_vector::iterator</a></div><div class="ttdeci">internal::vector_iterator&lt; concurrent_vector, T &gt; iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00577">concurrent_vector.h:577</a></div></div>
<div class="ttc" id="a00168_html_ada098ff121699bfed7ae37e759eff93d"><div class="ttname"><a href="a00168.html#ada098ff121699bfed7ae37e759eff93d">tbb::concurrent_vector::size_type</a></div><div class="ttdeci">internal::concurrent_vector_base_v3::size_type size_type</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00567">concurrent_vector.h:567</a></div></div>
<div class="ttc" id="a00169_html_a558417c6b3314944dfa6182db71841e3"><div class="ttname"><a href="a00169.html#a558417c6b3314944dfa6182db71841e3">tbb::internal::concurrent_vector_base_v3::internal_grow_to_at_least_with_result</a></div><div class="ttdeci">size_type __TBB_EXPORTED_METHOD internal_grow_to_at_least_with_result(size_type new_size, size_type element_size, internal_array_op2 init, const void *src)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00438">concurrent_vector.cpp:438</a></div></div>
<div class="ttc" id="a00168_html_a615b7ebb3f9219014924b523c44e085e"><div class="ttname"><a href="a00168.html#a615b7ebb3f9219014924b523c44e085e">tbb::concurrent_vector::initialize_array_by</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC initialize_array_by(void *begin, const void *src, size_type n)</div><div class="ttdoc">Copy-construct n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01288">concurrent_vector.h:1288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a12b1a671033a824c0027720427072328"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::initialize_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct n instances of T, starting at "begin". </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01283">1283</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>References <a class="el" href="a00387.html#ae9a00cf3626842a07504faaf9cabad54">tbb::concurrent_vector&lt; T, A &gt;::internal_loop_guide::init()</a>.</p>
<div class="fragment"><div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;                                                                                       {</div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;    internal_loop_guide loop(n, <a class="code" href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">begin</a>); loop.init();</div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;}</div><div class="ttc" id="a00168_html_ab55636c80368ad7d400f3200313fcf5f"><div class="ttname"><a href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">tbb::concurrent_vector::begin</a></div><div class="ttdeci">iterator begin()</div><div class="ttdoc">start iterator </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00933">concurrent_vector.h:933</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00168_a12b1a671033a824c0027720427072328_cgraph.svg" width="378" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a615b7ebb3f9219014924b523c44e085e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::initialize_array_by </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-construct n instances of T, starting at "begin". </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01288">1288</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>References <a class="el" href="a00387.html#ae9a00cf3626842a07504faaf9cabad54">tbb::concurrent_vector&lt; T, A &gt;::internal_loop_guide::init()</a>.</p>
<div class="fragment"><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;                                                                                             {</div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;    internal_loop_guide loop(n, <a class="code" href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">begin</a>); loop.init(src);</div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;}</div><div class="ttc" id="a00168_html_ab55636c80368ad7d400f3200313fcf5f"><div class="ttname"><a href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">tbb::concurrent_vector::begin</a></div><div class="ttdeci">iterator begin()</div><div class="ttdoc">start iterator </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00933">concurrent_vector.h:933</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00168_a615b7ebb3f9219014924b523c44e085e_cgraph.svg" width="378" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa8d78091cca57343f1bd59026c9a9da6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a>* <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::internal_allocator </td>
          <td>(</td>
          <td class="paramtype">internal::concurrent_vector_base_v3 &amp;&#160;</td>
          <td class="paramname"><em>vb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate k items. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01025">1025</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;                                                                                     {</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>concurrent_vector&lt;T, A&gt;&amp;<span class="keyword">&gt;</span>(vb).<a class="code" href="a00052.html#a72f9ed5aac2cf597dc1e6c8e614173b3">my_allocator</a>.allocate(k);</div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;    }</div><div class="ttc" id="a00052_html_a72f9ed5aac2cf597dc1e6c8e614173b3"><div class="ttname"><a href="a00052.html#a72f9ed5aac2cf597dc1e6c8e614173b3">tbb::internal::allocator_base::my_allocator</a></div><div class="ttdeci">allocator_type my_allocator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00473">concurrent_vector.h:473</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aebff613825ded62ed4648117829f5942"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A &gt; </div>
<div class="memtemplate">
template&lt;class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::internal_assign_iterators </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assign by iterators </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01262">1262</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>References <a class="el" href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a>, <a class="el" href="a00169.html#ae07413aa0de51aeb5ec1ec35bbc0095f">tbb::internal::concurrent_vector_base_v3::internal_reserve()</a>, <a class="el" href="a00387.html#a38612ea8f89823cb9476b794d0a5db8f">tbb::concurrent_vector&lt; T, A &gt;::internal_loop_guide::iterate()</a>, <a class="el" href="a00169.html#a1f3773deae9ac723547700419690b043">tbb::internal::concurrent_vector_base_v3::my_early_size</a>, <a class="el" href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">tbb::internal::concurrent_vector_base_v3::my_first_block</a>, <a class="el" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">tbb::internal::concurrent_vector_base_v3::my_segment</a>, and <a class="el" href="a00169.html#a68c3e198aae8f0a1128cf629c740988b">tbb::internal::concurrent_vector_base_v3::segment_size()</a>.</p>
<div class="fragment"><div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;                                                                       {</div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;    <a class="code" href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a>(<a class="code" href="a00169.html#a1f3773deae9ac723547700419690b043">my_early_size</a> == 0, NULL);</div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;    <a class="code" href="a00168.html#ada098ff121699bfed7ae37e759eff93d">size_type</a> n = std::distance(<a class="code" href="a01133.html#acf23419eb6d3adac787a4fee78cb3c27">first</a>, <a class="code" href="a01133.html#acb741ec0fd6aa234c464640f37d7c812">last</a>);</div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;    <span class="keywordflow">if</span>( !n ) <span class="keywordflow">return</span>;</div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;    <a class="code" href="a00169.html#ae07413aa0de51aeb5ec1ec35bbc0095f">internal_reserve</a>(n, <span class="keyword">sizeof</span>(T), <a class="code" href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">max_size</a>());</div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;    <a class="code" href="a00169.html#a1f3773deae9ac723547700419690b043">my_early_size</a> = n;</div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;    <a class="code" href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">segment_index_t</a> k = 0;</div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;    <span class="comment">//TODO: unify segment iteration code with concurrent_base_v3::helper</span></div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;    <a class="code" href="a00168.html#ada098ff121699bfed7ae37e759eff93d">size_type</a> sz = <a class="code" href="a00169.html#a68c3e198aae8f0a1128cf629c740988b">segment_size</a>( <a class="code" href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">my_first_block</a> );</div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;    <span class="keywordflow">while</span>( sz &lt; n ) {</div><div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;        internal_loop_guide loop(sz, <a class="code" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a>[k].<span class="keyword">template</span> load&lt;relaxed&gt;().<span class="keyword">template</span> pointer&lt;void&gt;());</div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;        loop.iterate(<a class="code" href="a01133.html#acf23419eb6d3adac787a4fee78cb3c27">first</a>);</div><div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;        n -= sz;</div><div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;        <span class="keywordflow">if</span>( !k ) k = <a class="code" href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">my_first_block</a>;</div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;        <span class="keywordflow">else</span> { ++k; sz &lt;&lt;= 1; }</div><div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;    }</div><div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;    internal_loop_guide loop(n, <a class="code" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a>[k].<span class="keyword">template</span> load&lt;relaxed&gt;().<span class="keyword">template</span> pointer&lt;void&gt;());</div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;    loop.iterate(<a class="code" href="a01133.html#acf23419eb6d3adac787a4fee78cb3c27">first</a>);</div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;}</div><div class="ttc" id="a01133_html_acb741ec0fd6aa234c464640f37d7c812"><div class="ttname"><a href="a01133.html#acb741ec0fd6aa234c464640f37d7c812">tbb::internal::last</a></div><div class="ttdeci">auto last(Container &amp;c) -&gt; decltype(begin(c))</div><div class="ttdef"><b>Definition:</b> <a href="a00953_source.html#l00044">_range_iterator.h:44</a></div></div>
<div class="ttc" id="a00169_html_a537b5a463d9131c3777e71d05fa3a81b"><div class="ttname"><a href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">tbb::internal::concurrent_vector_base_v3::segment_index_t</a></div><div class="ttdeci">size_t segment_index_t</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00088">concurrent_vector.h:88</a></div></div>
<div class="ttc" id="a00168_html_ada098ff121699bfed7ae37e759eff93d"><div class="ttname"><a href="a00168.html#ada098ff121699bfed7ae37e759eff93d">tbb::concurrent_vector::size_type</a></div><div class="ttdeci">internal::concurrent_vector_base_v3::size_type size_type</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00567">concurrent_vector.h:567</a></div></div>
<div class="ttc" id="a00168_html_a0ec9c3ab3360e04bdaa5174956a3206d"><div class="ttname"><a href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">tbb::concurrent_vector::max_size</a></div><div class="ttdeci">size_type max_size() const </div><div class="ttdoc">Upper bound on argument to reserve. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00926">concurrent_vector.h:926</a></div></div>
<div class="ttc" id="a00169_html_a68c3e198aae8f0a1128cf629c740988b"><div class="ttname"><a href="a00169.html#a68c3e198aae8f0a1128cf629c740988b">tbb::internal::concurrent_vector_base_v3::segment_size</a></div><div class="ttdeci">static size_type segment_size(segment_index_t k)</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00229">concurrent_vector.h:229</a></div></div>
<div class="ttc" id="a00169_html_ae07413aa0de51aeb5ec1ec35bbc0095f"><div class="ttname"><a href="a00169.html#ae07413aa0de51aeb5ec1ec35bbc0095f">tbb::internal::concurrent_vector_base_v3::internal_reserve</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_reserve(size_type n, size_type element_size, size_type max_size)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00343">concurrent_vector.cpp:343</a></div></div>
<div class="ttc" id="a00169_html_ad9d3103757a1ef6a70a597d6b174d5c7"><div class="ttname"><a href="a00169.html#ad9d3103757a1ef6a70a597d6b174d5c7">tbb::internal::concurrent_vector_base_v3::my_first_block</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_first_block</div><div class="ttdoc">count of segments in the first block </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00182">concurrent_vector.h:182</a></div></div>
<div class="ttc" id="a00169_html_acc5232333cf13be4c77bdfe7282f7e14"><div class="ttname"><a href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">tbb::internal::concurrent_vector_base_v3::my_segment</a></div><div class="ttdeci">atomic&lt; segment_t * &gt; my_segment</div><div class="ttdoc">Pointer to the segments table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00188">concurrent_vector.h:188</a></div></div>
<div class="ttc" id="a01098_html_a7b58d28a34a1717e2ddb591f00658b10"><div class="ttname"><a href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a></div><div class="ttdeci">#define __TBB_ASSERT(predicate, comment)</div><div class="ttdoc">No-op version of __TBB_ASSERT. </div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00169">tbb_stddef.h:169</a></div></div>
<div class="ttc" id="a00169_html_a1f3773deae9ac723547700419690b043"><div class="ttname"><a href="a00169.html#a1f3773deae9ac723547700419690b043">tbb::internal::concurrent_vector_base_v3::my_early_size</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_early_size</div><div class="ttdoc">Requested size of vector. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00185">concurrent_vector.h:185</a></div></div>
<div class="ttc" id="a01133_html_acf23419eb6d3adac787a4fee78cb3c27"><div class="ttname"><a href="a01133.html#acf23419eb6d3adac787a4fee78cb3c27">tbb::internal::first</a></div><div class="ttdeci">auto first(Container &amp;c) -&gt; decltype(begin(c))</div><div class="ttdef"><b>Definition:</b> <a href="a00953_source.html#l00038">_range_iterator.h:38</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a00168_aebff613825ded62ed4648117829f5942_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4eb56cca0338422a9884cf8d756fb89d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::internal_assign_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00168.html#afa0d28eb686589cbaf4733ca0eabc071">const_pointer</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assign n items by copying t </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01038">1038</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;                                                         {</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;        <a class="code" href="a00169.html#a57151343a7f7c09dfc70bad5f149c417">internal_resize</a>( n, <span class="keyword">sizeof</span>(T), <a class="code" href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">max_size</a>(), static_cast&lt;const void*&gt;(<a class="code" href="a01016.html#ae01354a6a694c51fb79588444a08cbee">p</a>), &amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>, <a class="code" href="a01016.html#ae01354a6a694c51fb79588444a08cbee">p</a>? &amp;<a class="code" href="a00168.html#a615b7ebb3f9219014924b523c44e085e">initialize_array_by</a> : &amp;<a class="code" href="a00168.html#a12b1a671033a824c0027720427072328">initialize_array</a> );</div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;    }</div><div class="ttc" id="a00168_html_a12b1a671033a824c0027720427072328"><div class="ttname"><a href="a00168.html#a12b1a671033a824c0027720427072328">tbb::concurrent_vector::initialize_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC initialize_array(void *begin, const void *, size_type n)</div><div class="ttdoc">Construct n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01283">concurrent_vector.h:1283</a></div></div>
<div class="ttc" id="a00168_html_a0ec9c3ab3360e04bdaa5174956a3206d"><div class="ttname"><a href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">tbb::concurrent_vector::max_size</a></div><div class="ttdeci">size_type max_size() const </div><div class="ttdoc">Upper bound on argument to reserve. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00926">concurrent_vector.h:926</a></div></div>
<div class="ttc" id="a00169_html_a57151343a7f7c09dfc70bad5f149c417"><div class="ttname"><a href="a00169.html#a57151343a7f7c09dfc70bad5f149c417">tbb::internal::concurrent_vector_base_v3::internal_resize</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_resize(size_type n, size_type element_size, size_type max_size, const void *src, internal_array_op1 destroy, internal_array_op2 init)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00490">concurrent_vector.cpp:490</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a00168_html_a615b7ebb3f9219014924b523c44e085e"><div class="ttname"><a href="a00168.html#a615b7ebb3f9219014924b523c44e085e">tbb::concurrent_vector::initialize_array_by</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC initialize_array_by(void *begin, const void *src, size_type n)</div><div class="ttdoc">Copy-construct n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01288">concurrent_vector.h:1288</a></div></div>
<div class="ttc" id="a01016_html_ae01354a6a694c51fb79588444a08cbee"><div class="ttname"><a href="a01016.html#ae01354a6a694c51fb79588444a08cbee">p</a></div><div class="ttdeci">void const char const char int ITT_FORMAT __itt_group_sync p</div><div class="ttdef"><b>Definition:</b> <a href="a01016_source.html#l00080">ittnotify_static.h:80</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a874a5d44cc3dc7c4b67b3b52b8fc4bff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<div class="memtemplate">
template&lt;class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::internal_assign_range </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00398.html">is_integer_tag</a>&lt; true &gt; *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assign integer items by copying when arguments are treated as iterators. See C++ Standard 2003 23.1.1p9 </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01053">1053</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;                                                                        {</div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;        <a class="code" href="a00168.html#a4eb56cca0338422a9884cf8d756fb89d">internal_assign_n</a>(static_cast&lt;size_type&gt;(<a class="code" href="a01133.html#acf23419eb6d3adac787a4fee78cb3c27">first</a>), &amp;static_cast&lt;T&amp;&gt;(<a class="code" href="a01133.html#acb741ec0fd6aa234c464640f37d7c812">last</a>));</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;    }</div><div class="ttc" id="a01133_html_acb741ec0fd6aa234c464640f37d7c812"><div class="ttname"><a href="a01133.html#acb741ec0fd6aa234c464640f37d7c812">tbb::internal::last</a></div><div class="ttdeci">auto last(Container &amp;c) -&gt; decltype(begin(c))</div><div class="ttdef"><b>Definition:</b> <a href="a00953_source.html#l00044">_range_iterator.h:44</a></div></div>
<div class="ttc" id="a00168_html_a4eb56cca0338422a9884cf8d756fb89d"><div class="ttname"><a href="a00168.html#a4eb56cca0338422a9884cf8d756fb89d">tbb::concurrent_vector::internal_assign_n</a></div><div class="ttdeci">void internal_assign_n(size_type n, const_pointer p)</div><div class="ttdoc">assign n items by copying t </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01038">concurrent_vector.h:1038</a></div></div>
<div class="ttc" id="a01133_html_acf23419eb6d3adac787a4fee78cb3c27"><div class="ttname"><a href="a01133.html#acf23419eb6d3adac787a4fee78cb3c27">tbb::internal::first</a></div><div class="ttdeci">auto first(Container &amp;c) -&gt; decltype(begin(c))</div><div class="ttdef"><b>Definition:</b> <a href="a00953_source.html#l00038">_range_iterator.h:38</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1027eaca45b3f1f94a6db760ecb1a2c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<div class="memtemplate">
template&lt;class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::internal_assign_range </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00398.html">is_integer_tag</a>&lt; false &gt; *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inline proxy assign by iterators </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01058">1058</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;                                                                         {</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;        <a class="code" href="a00168.html#aebff613825ded62ed4648117829f5942">internal_assign_iterators</a>(<a class="code" href="a01133.html#acf23419eb6d3adac787a4fee78cb3c27">first</a>, <a class="code" href="a01133.html#acb741ec0fd6aa234c464640f37d7c812">last</a>);</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;    }</div><div class="ttc" id="a01133_html_acb741ec0fd6aa234c464640f37d7c812"><div class="ttname"><a href="a01133.html#acb741ec0fd6aa234c464640f37d7c812">tbb::internal::last</a></div><div class="ttdeci">auto last(Container &amp;c) -&gt; decltype(begin(c))</div><div class="ttdef"><b>Definition:</b> <a href="a00953_source.html#l00044">_range_iterator.h:44</a></div></div>
<div class="ttc" id="a00168_html_aebff613825ded62ed4648117829f5942"><div class="ttname"><a href="a00168.html#aebff613825ded62ed4648117829f5942">tbb::concurrent_vector::internal_assign_iterators</a></div><div class="ttdeci">void internal_assign_iterators(I first, I last)</div><div class="ttdoc">assign by iterators </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01262">concurrent_vector.h:1262</a></div></div>
<div class="ttc" id="a01133_html_acf23419eb6d3adac787a4fee78cb3c27"><div class="ttname"><a href="a01133.html#acf23419eb6d3adac787a4fee78cb3c27">tbb::internal::first</a></div><div class="ttdeci">auto first(Container &amp;c) -&gt; decltype(begin(c))</div><div class="ttdef"><b>Definition:</b> <a href="a00953_source.html#l00038">_range_iterator.h:38</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a496efbef33d4076867c075c67793aa6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::internal_free_segments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00696.html">segment_t</a>&#160;</td>
          <td class="paramname"><em>table</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">segment_index_t</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">segment_index_t</a>&#160;</td>
          <td class="paramname"><em>first_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free k segments from table. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01209">1209</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>References <a class="el" href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a>, <a class="el" href="a00696.html#afdee3df6fc6e03de5d3cfd9a16770803">tbb::internal::concurrent_vector_base_v3::segment_t::load()</a>, <a class="el" href="a00697.html#a458a8d0e48fa5038df8091fabeb6348d">tbb::internal::concurrent_vector_base_v3::segment_value_t::pointer()</a>, <a class="el" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">tbb::relaxed</a>, <a class="el" href="a00169.html#a68c3e198aae8f0a1128cf629c740988b">tbb::internal::concurrent_vector_base_v3::segment_size()</a>, and <a class="el" href="a00696.html#ac6bee01662b1aebc657c1f80c2d12634">tbb::internal::concurrent_vector_base_v3::segment_t::store()</a>.</p>
<div class="fragment"><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;                                                                                                                      {</div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;    <span class="comment">// Free the arrays</span></div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;    <span class="keywordflow">while</span>( k &gt; first_block ) {</div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;        --k;</div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;        segment_value_t segment_value = table[k].load&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;();</div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;        table[k].store&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;(segment_not_used());</div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;        <span class="keywordflow">if</span>( segment_value == segment_allocated() ) <span class="comment">// check for correct segment pointer</span></div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;            this-&gt;<a class="code" href="a00052.html#a72f9ed5aac2cf597dc1e6c8e614173b3">my_allocator</a>.deallocate( (segment_value.pointer&lt;T&gt;()), <a class="code" href="a00169.html#a68c3e198aae8f0a1128cf629c740988b">segment_size</a>(k) );</div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;    }</div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;    segment_value_t segment_value = table[0].load&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;();</div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;    <span class="keywordflow">if</span>( segment_value == segment_allocated() ) {</div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;        <a class="code" href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a>( first_block &gt; 0, NULL );</div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;        <span class="keywordflow">while</span>(k &gt; 0) table[--k].store&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">relaxed</a>&gt;(segment_not_used());</div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;        this-&gt;<a class="code" href="a00052.html#a72f9ed5aac2cf597dc1e6c8e614173b3">my_allocator</a>.deallocate( (segment_value.pointer&lt;T&gt;()), <a class="code" href="a00169.html#a68c3e198aae8f0a1128cf629c740988b">segment_size</a>(first_block) );</div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;    }</div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;}</div><div class="ttc" id="a00169_html_a68c3e198aae8f0a1128cf629c740988b"><div class="ttname"><a href="a00169.html#a68c3e198aae8f0a1128cf629c740988b">tbb::internal::concurrent_vector_base_v3::segment_size</a></div><div class="ttdeci">static size_type segment_size(segment_index_t k)</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00229">concurrent_vector.h:229</a></div></div>
<div class="ttc" id="a01113_html_adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5"><div class="ttname"><a href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aa73cb2e2bcb94442b8b2b72e93a76f2e5">tbb::relaxed</a></div><div class="ttdoc">No ordering. </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00051">atomic.h:51</a></div></div>
<div class="ttc" id="a01098_html_a7b58d28a34a1717e2ddb591f00658b10"><div class="ttname"><a href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a></div><div class="ttdeci">#define __TBB_ASSERT(predicate, comment)</div><div class="ttdoc">No-op version of __TBB_ASSERT. </div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00169">tbb_stddef.h:169</a></div></div>
<div class="ttc" id="a00052_html_a72f9ed5aac2cf597dc1e6c8e614173b3"><div class="ttname"><a href="a00052.html#a72f9ed5aac2cf597dc1e6c8e614173b3">tbb::internal::allocator_base::my_allocator</a></div><div class="ttdeci">allocator_type my_allocator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00473">concurrent_vector.h:473</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00168_a496efbef33d4076867c075c67793aa6c_cgraph.svg" width="620" height="291"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4ea8843a774a9f52a47e6661fccbde19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::internal_subscript </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get reference to element at given index. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01227">1227</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>References <a class="el" href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a>, <a class="el" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aaa92646b4dc7618530d3a9f51dd10a418">tbb::acquire</a>, <a class="el" href="a00169.html#a1f3773deae9ac723547700419690b043">tbb::internal::concurrent_vector_base_v3::my_early_size</a>, <a class="el" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">tbb::internal::concurrent_vector_base_v3::my_segment</a>, <a class="el" href="a00169.html#adb52d25144f5cecc228e171f476cf91d">tbb::internal::concurrent_vector_base_v3::my_storage</a>, <a class="el" href="a00697.html#a458a8d0e48fa5038df8091fabeb6348d">tbb::internal::concurrent_vector_base_v3::segment_value_t::pointer()</a>, <a class="el" href="a00169.html#abbb8fe2e97a84e53773124c2c0616977a55596bdb0c771a285e87ab3645b78e23">tbb::internal::concurrent_vector_base_v3::pointers_per_short_table</a>, and <a class="el" href="a00169.html#ac55fb14b17ddb920eaf50596446b9963">tbb::internal::concurrent_vector_base_v3::segment_base_index_of()</a>.</p>
<div class="fragment"><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;                                                                      {</div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;    <span class="comment">//TODO: unify both versions of internal_subscript</span></div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;    <a class="code" href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a>( index &lt; <a class="code" href="a00169.html#a1f3773deae9ac723547700419690b043">my_early_size</a>, <span class="stringliteral">&quot;index out of bounds&quot;</span> );</div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;    <a class="code" href="a00168.html#ada098ff121699bfed7ae37e759eff93d">size_type</a> j = index;</div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;    <a class="code" href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">segment_index_t</a> k = <a class="code" href="a00169.html#ac55fb14b17ddb920eaf50596446b9963">segment_base_index_of</a>( j );</div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;    <a class="code" href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a>( <a class="code" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a>.load&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aaa92646b4dc7618530d3a9f51dd10a418">acquire</a>&gt;() != <a class="code" href="a00169.html#adb52d25144f5cecc228e171f476cf91d">my_storage</a> || k &lt; <a class="code" href="a00169.html#abbb8fe2e97a84e53773124c2c0616977a55596bdb0c771a285e87ab3645b78e23">pointers_per_short_table</a>, <span class="stringliteral">&quot;index is being allocated&quot;</span> );</div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;    <span class="comment">//no need in load with acquire (load&lt;acquire&gt;) since thread works in own space or gets</span></div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;    <span class="comment">//the information about added elements via some form of external synchronization</span></div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;    <span class="comment">//TODO: why not make a load of my_segment relaxed as well ?</span></div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;    <span class="comment">//TODO: add an assertion that my_segment[k] is properly aligned to please ITT</span></div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;    segment_value_t segment_value =  <a class="code" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a>[k].template load&lt;relaxed&gt;();</div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;    <a class="code" href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a>( segment_value != segment_allocation_failed(), <span class="stringliteral">&quot;the instance is broken by bad allocation. Use at() instead&quot;</span> );</div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;    <a class="code" href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a>( segment_value != segment_not_used(), <span class="stringliteral">&quot;index is being allocated&quot;</span> );</div><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;    <span class="keywordflow">return</span> (( segment_value.pointer&lt;T&gt;()))[j];</div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;}</div><div class="ttc" id="a00169_html_a537b5a463d9131c3777e71d05fa3a81b"><div class="ttname"><a href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">tbb::internal::concurrent_vector_base_v3::segment_index_t</a></div><div class="ttdeci">size_t segment_index_t</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00088">concurrent_vector.h:88</a></div></div>
<div class="ttc" id="a01113_html_adb86d08473679d6fe0eabcdc766ffe3aaa92646b4dc7618530d3a9f51dd10a418"><div class="ttname"><a href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aaa92646b4dc7618530d3a9f51dd10a418">tbb::acquire</a></div><div class="ttdoc">Acquire. </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00047">atomic.h:47</a></div></div>
<div class="ttc" id="a00168_html_ada098ff121699bfed7ae37e759eff93d"><div class="ttname"><a href="a00168.html#ada098ff121699bfed7ae37e759eff93d">tbb::concurrent_vector::size_type</a></div><div class="ttdeci">internal::concurrent_vector_base_v3::size_type size_type</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00567">concurrent_vector.h:567</a></div></div>
<div class="ttc" id="a00169_html_adb52d25144f5cecc228e171f476cf91d"><div class="ttname"><a href="a00169.html#adb52d25144f5cecc228e171f476cf91d">tbb::internal::concurrent_vector_base_v3::my_storage</a></div><div class="ttdeci">segment_t my_storage[pointers_per_short_table]</div><div class="ttdoc">embedded storage of segment pointers </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00191">concurrent_vector.h:191</a></div></div>
<div class="ttc" id="a00169_html_ac55fb14b17ddb920eaf50596446b9963"><div class="ttname"><a href="a00169.html#ac55fb14b17ddb920eaf50596446b9963">tbb::internal::concurrent_vector_base_v3::segment_base_index_of</a></div><div class="ttdeci">static segment_index_t segment_base_index_of(segment_index_t &amp;index)</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00223">concurrent_vector.h:223</a></div></div>
<div class="ttc" id="a00169_html_acc5232333cf13be4c77bdfe7282f7e14"><div class="ttname"><a href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">tbb::internal::concurrent_vector_base_v3::my_segment</a></div><div class="ttdeci">atomic&lt; segment_t * &gt; my_segment</div><div class="ttdoc">Pointer to the segments table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00188">concurrent_vector.h:188</a></div></div>
<div class="ttc" id="a01098_html_a7b58d28a34a1717e2ddb591f00658b10"><div class="ttname"><a href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a></div><div class="ttdeci">#define __TBB_ASSERT(predicate, comment)</div><div class="ttdoc">No-op version of __TBB_ASSERT. </div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00169">tbb_stddef.h:169</a></div></div>
<div class="ttc" id="a00169_html_a1f3773deae9ac723547700419690b043"><div class="ttname"><a href="a00169.html#a1f3773deae9ac723547700419690b043">tbb::internal::concurrent_vector_base_v3::my_early_size</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_early_size</div><div class="ttdoc">Requested size of vector. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00185">concurrent_vector.h:185</a></div></div>
<div class="ttc" id="a00169_html_abbb8fe2e97a84e53773124c2c0616977a55596bdb0c771a285e87ab3645b78e23"><div class="ttname"><a href="a00169.html#abbb8fe2e97a84e53773124c2c0616977a55596bdb0c771a285e87ab3645b78e23">tbb::internal::concurrent_vector_base_v3::pointers_per_short_table</a></div><div class="ttdoc">Number of slots for segment pointers inside the class. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00096">concurrent_vector.h:96</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a00168_a4ea8843a774a9f52a47e6661fccbde19_cgraph.svg" width="100%" height="432"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="abc22450ffcfb9d0b946f89869ca0c894"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::internal_subscript_with_exceptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get reference to element at given index with errors checks. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01244">1244</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>References <a class="el" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aaa92646b4dc7618530d3a9f51dd10a418">tbb::acquire</a>, <a class="el" href="a01133.html#ace88c7330e7f616616785ffb001e04f9adaf339053aec4821d08d2c4685fe8d47">tbb::internal::eid_index_range_error</a>, <a class="el" href="a01133.html#ace88c7330e7f616616785ffb001e04f9aa0b938e9b3b66e4205ad62d4f3e50fef">tbb::internal::eid_out_of_range</a>, <a class="el" href="a01133.html#ace88c7330e7f616616785ffb001e04f9a67e985886f6fb2f88b7c247a46ba56b4">tbb::internal::eid_segment_range_error</a>, <a class="el" href="a00169.html#ad9829790b45c37c2af2ea85c1c804eb1">tbb::internal::concurrent_vector_base_v3::enforce_segment_allocated</a>, <a class="el" href="a00169.html#a1f3773deae9ac723547700419690b043">tbb::internal::concurrent_vector_base_v3::my_early_size</a>, <a class="el" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">tbb::internal::concurrent_vector_base_v3::my_segment</a>, <a class="el" href="a00169.html#adb52d25144f5cecc228e171f476cf91d">tbb::internal::concurrent_vector_base_v3::my_storage</a>, <a class="el" href="a00697.html#a458a8d0e48fa5038df8091fabeb6348d">tbb::internal::concurrent_vector_base_v3::segment_value_t::pointer()</a>, <a class="el" href="a00169.html#abbb8fe2e97a84e53773124c2c0616977a55596bdb0c771a285e87ab3645b78e23">tbb::internal::concurrent_vector_base_v3::pointers_per_short_table</a>, <a class="el" href="a00169.html#ac55fb14b17ddb920eaf50596446b9963">tbb::internal::concurrent_vector_base_v3::segment_base_index_of()</a>, and <a class="el" href="a01133.html#a61a681f9fd15fdb055f7725d6416ddf4">tbb::internal::throw_exception()</a>.</p>
<div class="fragment"><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;                                                                                      {</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;    <span class="keywordflow">if</span>( index &gt;= <a class="code" href="a00169.html#a1f3773deae9ac723547700419690b043">my_early_size</a> )</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;        <a class="code" href="a01133.html#a61a681f9fd15fdb055f7725d6416ddf4">internal::throw_exception</a>(<a class="code" href="a01133.html#ace88c7330e7f616616785ffb001e04f9aa0b938e9b3b66e4205ad62d4f3e50fef">internal::eid_out_of_range</a>); <span class="comment">// throw std::out_of_range</span></div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;    <a class="code" href="a00168.html#ada098ff121699bfed7ae37e759eff93d">size_type</a> j = index;</div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;    <a class="code" href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">segment_index_t</a> k = <a class="code" href="a00169.html#ac55fb14b17ddb920eaf50596446b9963">segment_base_index_of</a>( j );</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;    <span class="comment">//TODO: refactor this condition into separate helper function, e.g. fits_into_small_table</span></div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;    <span class="keywordflow">if</span>( <a class="code" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a>.load&lt;<a class="code" href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aaa92646b4dc7618530d3a9f51dd10a418">acquire</a>&gt;() == <a class="code" href="a00169.html#adb52d25144f5cecc228e171f476cf91d">my_storage</a> &amp;&amp; k &gt;= <a class="code" href="a00169.html#abbb8fe2e97a84e53773124c2c0616977a55596bdb0c771a285e87ab3645b78e23">pointers_per_short_table</a> )</div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;        <a class="code" href="a01133.html#a61a681f9fd15fdb055f7725d6416ddf4">internal::throw_exception</a>(<a class="code" href="a01133.html#ace88c7330e7f616616785ffb001e04f9a67e985886f6fb2f88b7c247a46ba56b4">internal::eid_segment_range_error</a>); <span class="comment">// throw std::range_error</span></div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;    <span class="comment">// no need in load with acquire (load&lt;acquire&gt;) since thread works in own space or gets</span></div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;    <span class="comment">//the information about added elements via some form of external synchronization</span></div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;    <span class="comment">//TODO: why not make a load of my_segment relaxed as well ?</span></div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;    <span class="comment">//TODO: add an assertion that my_segment[k] is properly aligned to please ITT</span></div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;    segment_value_t segment_value =  <a class="code" href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">my_segment</a>[k].template load&lt;relaxed&gt;();</div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;    <a class="code" href="a00169.html#ad9829790b45c37c2af2ea85c1c804eb1">enforce_segment_allocated</a>(segment_value, <a class="code" href="a01133.html#ace88c7330e7f616616785ffb001e04f9adaf339053aec4821d08d2c4685fe8d47">internal::eid_index_range_error</a>);</div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;    <span class="keywordflow">return</span> (segment_value.pointer&lt;T&gt;())[j];</div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;}</div><div class="ttc" id="a00169_html_a537b5a463d9131c3777e71d05fa3a81b"><div class="ttname"><a href="a00169.html#a537b5a463d9131c3777e71d05fa3a81b">tbb::internal::concurrent_vector_base_v3::segment_index_t</a></div><div class="ttdeci">size_t segment_index_t</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00088">concurrent_vector.h:88</a></div></div>
<div class="ttc" id="a01113_html_adb86d08473679d6fe0eabcdc766ffe3aaa92646b4dc7618530d3a9f51dd10a418"><div class="ttname"><a href="a01113.html#adb86d08473679d6fe0eabcdc766ffe3aaa92646b4dc7618530d3a9f51dd10a418">tbb::acquire</a></div><div class="ttdoc">Acquire. </div><div class="ttdef"><b>Definition:</b> <a href="a00965_source.html#l00047">atomic.h:47</a></div></div>
<div class="ttc" id="a00168_html_ada098ff121699bfed7ae37e759eff93d"><div class="ttname"><a href="a00168.html#ada098ff121699bfed7ae37e759eff93d">tbb::concurrent_vector::size_type</a></div><div class="ttdeci">internal::concurrent_vector_base_v3::size_type size_type</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00567">concurrent_vector.h:567</a></div></div>
<div class="ttc" id="a01133_html_ace88c7330e7f616616785ffb001e04f9adaf339053aec4821d08d2c4685fe8d47"><div class="ttname"><a href="a01133.html#ace88c7330e7f616616785ffb001e04f9adaf339053aec4821d08d2c4685fe8d47">tbb::internal::eid_index_range_error</a></div><div class="ttdef"><b>Definition:</b> <a href="a01088_source.html#l00074">tbb_exception.h:74</a></div></div>
<div class="ttc" id="a00169_html_adb52d25144f5cecc228e171f476cf91d"><div class="ttname"><a href="a00169.html#adb52d25144f5cecc228e171f476cf91d">tbb::internal::concurrent_vector_base_v3::my_storage</a></div><div class="ttdeci">segment_t my_storage[pointers_per_short_table]</div><div class="ttdoc">embedded storage of segment pointers </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00191">concurrent_vector.h:191</a></div></div>
<div class="ttc" id="a00169_html_ad9829790b45c37c2af2ea85c1c804eb1"><div class="ttname"><a href="a00169.html#ad9829790b45c37c2af2ea85c1c804eb1">tbb::internal::concurrent_vector_base_v3::enforce_segment_allocated</a></div><div class="ttdeci">friend void enforce_segment_allocated(segment_value_t const &amp;s, internal::exception_id exception=eid_bad_last_alloc)</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00122">concurrent_vector.h:122</a></div></div>
<div class="ttc" id="a01133_html_a61a681f9fd15fdb055f7725d6416ddf4"><div class="ttname"><a href="a01133.html#a61a681f9fd15fdb055f7725d6416ddf4">tbb::internal::throw_exception</a></div><div class="ttdeci">void throw_exception(exception_id eid)</div><div class="ttdoc">Versionless convenience wrapper for throw_exception_v4() </div><div class="ttdef"><b>Definition:</b> <a href="a01088_source.html#l00106">tbb_exception.h:106</a></div></div>
<div class="ttc" id="a00169_html_ac55fb14b17ddb920eaf50596446b9963"><div class="ttname"><a href="a00169.html#ac55fb14b17ddb920eaf50596446b9963">tbb::internal::concurrent_vector_base_v3::segment_base_index_of</a></div><div class="ttdeci">static segment_index_t segment_base_index_of(segment_index_t &amp;index)</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00223">concurrent_vector.h:223</a></div></div>
<div class="ttc" id="a01133_html_ace88c7330e7f616616785ffb001e04f9aa0b938e9b3b66e4205ad62d4f3e50fef"><div class="ttname"><a href="a01133.html#ace88c7330e7f616616785ffb001e04f9aa0b938e9b3b66e4205ad62d4f3e50fef">tbb::internal::eid_out_of_range</a></div><div class="ttdef"><b>Definition:</b> <a href="a01088_source.html#l00072">tbb_exception.h:72</a></div></div>
<div class="ttc" id="a00169_html_acc5232333cf13be4c77bdfe7282f7e14"><div class="ttname"><a href="a00169.html#acc5232333cf13be4c77bdfe7282f7e14">tbb::internal::concurrent_vector_base_v3::my_segment</a></div><div class="ttdeci">atomic&lt; segment_t * &gt; my_segment</div><div class="ttdoc">Pointer to the segments table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00188">concurrent_vector.h:188</a></div></div>
<div class="ttc" id="a00169_html_a1f3773deae9ac723547700419690b043"><div class="ttname"><a href="a00169.html#a1f3773deae9ac723547700419690b043">tbb::internal::concurrent_vector_base_v3::my_early_size</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_early_size</div><div class="ttdoc">Requested size of vector. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00185">concurrent_vector.h:185</a></div></div>
<div class="ttc" id="a00169_html_abbb8fe2e97a84e53773124c2c0616977a55596bdb0c771a285e87ab3645b78e23"><div class="ttname"><a href="a00169.html#abbb8fe2e97a84e53773124c2c0616977a55596bdb0c771a285e87ab3645b78e23">tbb::internal::concurrent_vector_base_v3::pointers_per_short_table</a></div><div class="ttdoc">Number of slots for segment pointers inside the class. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00096">concurrent_vector.h:96</a></div></div>
<div class="ttc" id="a01133_html_ace88c7330e7f616616785ffb001e04f9a67e985886f6fb2f88b7c247a46ba56b4"><div class="ttname"><a href="a01133.html#ace88c7330e7f616616785ffb001e04f9a67e985886f6fb2f88b7c247a46ba56b4">tbb::internal::eid_segment_range_error</a></div><div class="ttdef"><b>Definition:</b> <a href="a01088_source.html#l00073">tbb_exception.h:73</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a00168_abc22450ffcfb9d0b946f89869ca0c894_cgraph.svg" width="100%" height="503"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a675f1b62a651d350eb0d778a271e31e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const internal::concurrent_vector_base_v3&amp; <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::internal_vector_base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l01022">1022</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>Referenced by <a class="el" href="a00168.html#abb0e376a31c3fdb91beaaa98441735f5">tbb::concurrent_vector&lt; padded_element, padded_allocator_type &gt;::concurrent_vector()</a>, and <a class="el" href="a00168.html#a1fe7f0b60bbf304890a9293a35e6819d">tbb::concurrent_vector&lt; padded_element, padded_allocator_type &gt;::operator=()</a>.</p>
<div class="fragment"><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;{ <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div></div><!-- fragment -->
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00168_a675f1b62a651d350eb0d778a271e31e5_icgraph.svg" width="446" height="147"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0ec9c3ab3360e04bdaa5174956a3206d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Upper bound on argument to reserve. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00926">926</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;{<span class="keywordflow">return</span> (~<a class="code" href="a00168.html#ada098ff121699bfed7ae37e759eff93d">size_type</a>(0))/<span class="keyword">sizeof</span>(T);}</div><div class="ttc" id="a00168_html_ada098ff121699bfed7ae37e759eff93d"><div class="ttname"><a href="a00168.html#ada098ff121699bfed7ae37e759eff93d">tbb::concurrent_vector::size_type</a></div><div class="ttdeci">internal::concurrent_vector_base_v3::size_type size_type</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00567">concurrent_vector.h:567</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a265a4e7d777baedfb71172dfcf0f980f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::move_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-construct n instances of T, starting at "dst" by copying according element of src array. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01299">1299</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>References <a class="el" href="a00387.html#a307813c6eeb270942692545f636a0c41">tbb::concurrent_vector&lt; T, A &gt;::internal_loop_guide::move_construct()</a>.</p>
<div class="fragment"><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;                                                                                  {</div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;    internal_loop_guide loop(n, dst); loop.move_construct(src);</div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;}</div></div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a00168_a265a4e7d777baedfb71172dfcf0f980f_cgraph.svg" width="100%" height="410"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae34fa7579d0ffd5d97c375757283e01b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::move_assign_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assign (using operator=) n instances of T, starting at "dst" by assigning according element of src array. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01303">1303</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>References <a class="el" href="a00387.html#ab6c1e9d0aa14a4dceaaa5a941d908ce1">tbb::concurrent_vector&lt; T, A &gt;::internal_loop_guide::move_assign()</a>.</p>
<div class="fragment"><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;                                                                                         {</div><div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;    internal_loop_guide loop(n, dst); loop.move_assign(src);</div><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;}</div></div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a00168_ae34fa7579d0ffd5d97c375757283e01b_cgraph.svg" width="100%" height="410"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a920384aece0eb8beea3049956320ec91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html">concurrent_vector</a>&amp; <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00729">729</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;                                                                    {</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;        <span class="keywordflow">if</span>( <span class="keyword">this</span> != &amp;vector )</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;            <a class="code" href="a00169.html#a2de722203d5e6cb6a18075e451417664">internal_assign</a>(vector, <span class="keyword">sizeof</span>(T), &amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>, &amp;<a class="code" href="a00168.html#a36c957884197e510b1d7176aaf4736a0">assign_array</a>, &amp;<a class="code" href="a00168.html#a99cf2fd728e2a39dfc51ebe41ccc3779">copy_array</a>);</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;    }</div><div class="ttc" id="a00168_html_a99cf2fd728e2a39dfc51ebe41ccc3779"><div class="ttname"><a href="a00168.html#a99cf2fd728e2a39dfc51ebe41ccc3779">tbb::concurrent_vector::copy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC copy_array(void *dst, const void *src, size_type n)</div><div class="ttdoc">Copy-construct n instances of T by copying single element pointed to by src, starting at &quot;dst&quot;...</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01293">concurrent_vector.h:1293</a></div></div>
<div class="ttc" id="a00168_html_a36c957884197e510b1d7176aaf4736a0"><div class="ttname"><a href="a00168.html#a36c957884197e510b1d7176aaf4736a0">tbb::concurrent_vector::assign_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC assign_array(void *dst, const void *src, size_type n)</div><div class="ttdoc">Assign (using operator=) n instances of T, starting at &quot;dst&quot; by assigning according element of src ar...</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01323">concurrent_vector.h:1323</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a00169_html_a2de722203d5e6cb6a18075e451417664"><div class="ttname"><a href="a00169.html#a2de722203d5e6cb6a18075e451417664">tbb::internal::concurrent_vector_base_v3::internal_assign</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_assign(const concurrent_vector_base_v3 &amp;src, size_type element_size, internal_array_op1 destroy, internal_array_op2 assign, internal_array_op2 copy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00380">concurrent_vector.cpp:380</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0d26889a94203cdb5f5460fade7497c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html">concurrent_vector</a>&amp; <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00738">738</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;                                                              {</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;        <a class="code" href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a>(<span class="keyword">this</span> != &amp;other, <span class="stringliteral">&quot;Move assignment to itself is prohibited &quot;</span>);</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00111.html">tbb::internal::allocator_traits&lt;A&gt;::propagate_on_container_move_assignment</a> pocma_t;</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="a01016.html#a2507091f87afae57e117a984a7c4dd61">pocma_t::value</a> || this-&gt;<a class="code" href="a00052.html#a72f9ed5aac2cf597dc1e6c8e614173b3">my_allocator</a> == other.my_allocator) {</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;            <a class="code" href="a00168.html#a5bd95c2241653c760704a92b2c887a48">concurrent_vector</a> trash (<a class="code" href="a01113.html#ac41903d6b80e61bd6c605412e7820e08">std::move</a>(*<span class="keyword">this</span>));</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;            <a class="code" href="a00169.html#a5913c17dffae92a75f8c1c3caaa7ecf6">internal_swap</a>(other);</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;            <a class="code" href="a01133.html#a4fc0f7677fcad0cbc796143f575e1fd9">tbb::internal::allocator_move_assignment</a>(this-&gt;<a class="code" href="a00052.html#a72f9ed5aac2cf597dc1e6c8e614173b3">my_allocator</a>, other.my_allocator, pocma_t());</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;        } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;            <a class="code" href="a00169.html#a2de722203d5e6cb6a18075e451417664">internal_assign</a>(other, <span class="keyword">sizeof</span>(T), &amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>, &amp;<a class="code" href="a00168.html#ae34fa7579d0ffd5d97c375757283e01b">move_assign_array</a>, &amp;<a class="code" href="a00168.html#a265a4e7d777baedfb71172dfcf0f980f">move_array</a>);</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;        }</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;    }</div><div class="ttc" id="a00169_html_a5913c17dffae92a75f8c1c3caaa7ecf6"><div class="ttname"><a href="a00169.html#a5913c17dffae92a75f8c1c3caaa7ecf6">tbb::internal::concurrent_vector_base_v3::internal_swap</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_swap(concurrent_vector_base_v3 &amp;v)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00586">concurrent_vector.cpp:586</a></div></div>
<div class="ttc" id="a01133_html_a4fc0f7677fcad0cbc796143f575e1fd9"><div class="ttname"><a href="a01133.html#a4fc0f7677fcad0cbc796143f575e1fd9">tbb::internal::allocator_move_assignment</a></div><div class="ttdeci">void allocator_move_assignment(MyAlloc &amp;my_allocator, OtherAlloc &amp;other_allocator, traits_true_type)</div><div class="ttdef"><b>Definition:</b> <a href="a00937_source.html#l00054">_allocator_traits.h:54</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a00169_html_a2de722203d5e6cb6a18075e451417664"><div class="ttname"><a href="a00169.html#a2de722203d5e6cb6a18075e451417664">tbb::internal::concurrent_vector_base_v3::internal_assign</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_assign(const concurrent_vector_base_v3 &amp;src, size_type element_size, internal_array_op1 destroy, internal_array_op2 assign, internal_array_op2 copy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00380">concurrent_vector.cpp:380</a></div></div>
<div class="ttc" id="a01113_html_ac41903d6b80e61bd6c605412e7820e08"><div class="ttname"><a href="a01113.html#ac41903d6b80e61bd6c605412e7820e08">tbb::move</a></div><div class="ttdeci">void move(tbb_thread &amp;t1, tbb_thread &amp;t2)</div><div class="ttdef"><b>Definition:</b> <a href="a01100_source.html#l00309">tbb_thread.h:309</a></div></div>
<div class="ttc" id="a00111_html"><div class="ttname"><a href="a00111.html">tbb::internal::bool_constant</a></div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00469">tbb_stddef.h:469</a></div></div>
<div class="ttc" id="a01098_html_a7b58d28a34a1717e2ddb591f00658b10"><div class="ttname"><a href="a01098.html#a7b58d28a34a1717e2ddb591f00658b10">__TBB_ASSERT</a></div><div class="ttdeci">#define __TBB_ASSERT(predicate, comment)</div><div class="ttdoc">No-op version of __TBB_ASSERT. </div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00169">tbb_stddef.h:169</a></div></div>
<div class="ttc" id="a00052_html_a72f9ed5aac2cf597dc1e6c8e614173b3"><div class="ttname"><a href="a00052.html#a72f9ed5aac2cf597dc1e6c8e614173b3">tbb::internal::allocator_base::my_allocator</a></div><div class="ttdeci">allocator_type my_allocator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00473">concurrent_vector.h:473</a></div></div>
<div class="ttc" id="a00168_html_a5bd95c2241653c760704a92b2c887a48"><div class="ttname"><a href="a00168.html#a5bd95c2241653c760704a92b2c887a48">tbb::concurrent_vector::concurrent_vector</a></div><div class="ttdeci">concurrent_vector(const allocator_type &amp;a=allocator_type())</div><div class="ttdoc">Construct empty vector. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00601">concurrent_vector.h:601</a></div></div>
<div class="ttc" id="a00168_html_a265a4e7d777baedfb71172dfcf0f980f"><div class="ttname"><a href="a00168.html#a265a4e7d777baedfb71172dfcf0f980f">tbb::concurrent_vector::move_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC move_array(void *dst, const void *src, size_type n)</div><div class="ttdoc">Move-construct n instances of T, starting at &quot;dst&quot; by copying according element of src array...</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01299">concurrent_vector.h:1299</a></div></div>
<div class="ttc" id="a01016_html_a2507091f87afae57e117a984a7c4dd61"><div class="ttname"><a href="a01016.html#a2507091f87afae57e117a984a7c4dd61">value</a></div><div class="ttdeci">void const char const char int ITT_FORMAT __itt_group_sync x void const char ITT_FORMAT __itt_group_sync s void ITT_FORMAT __itt_group_sync p void ITT_FORMAT p void ITT_FORMAT p no args __itt_suppress_mode_t unsigned int void size_t ITT_FORMAT d void ITT_FORMAT p void ITT_FORMAT p __itt_model_site __itt_model_site_instance ITT_FORMAT p __itt_model_task __itt_model_task_instance ITT_FORMAT p void ITT_FORMAT p void ITT_FORMAT p void size_t ITT_FORMAT d void ITT_FORMAT p const wchar_t ITT_FORMAT s const char ITT_FORMAT s const char ITT_FORMAT s const char ITT_FORMAT s no args void ITT_FORMAT p size_t ITT_FORMAT d no args const wchar_t const wchar_t ITT_FORMAT s __itt_heap_function void size_t int ITT_FORMAT d __itt_heap_function void ITT_FORMAT p __itt_heap_function void void size_t int ITT_FORMAT d no args no args unsigned int ITT_FORMAT u const __itt_domain __itt_id ITT_FORMAT lu const __itt_domain __itt_id __itt_id __itt_string_handle ITT_FORMAT p const __itt_domain __itt_id ITT_FORMAT p const __itt_domain __itt_id __itt_timestamp __itt_timestamp ITT_FORMAT lu const __itt_domain __itt_id __itt_id __itt_string_handle ITT_FORMAT p const __itt_domain ITT_FORMAT p const __itt_domain __itt_string_handle unsigned long long value</div><div class="ttdef"><b>Definition:</b> <a href="a01016_source.html#l00181">ittnotify_static.h:181</a></div></div>
<div class="ttc" id="a00168_html_ae34fa7579d0ffd5d97c375757283e01b"><div class="ttname"><a href="a00168.html#ae34fa7579d0ffd5d97c375757283e01b">tbb::concurrent_vector::move_assign_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC move_assign_array(void *dst, const void *src, size_type n)</div><div class="ttdoc">Move-assign (using operator=) n instances of T, starting at &quot;dst&quot; by assigning according element of s...</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01303">concurrent_vector.h:1303</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1fe7f0b60bbf304890a9293a35e6819d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<div class="memtemplate">
template&lt;class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html">concurrent_vector</a>&amp; <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00168.html">concurrent_vector</a>&lt; T, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment for vector with different allocator type. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00755">755</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;                                                                          {</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;        <span class="keywordflow">if</span>( static_cast&lt;void*&gt;( <span class="keyword">this</span> ) != static_cast&lt;const void*&gt;( &amp;vector ) )</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;            <a class="code" href="a00169.html#a2de722203d5e6cb6a18075e451417664">internal_assign</a>(vector.internal_vector_base(),</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;                <span class="keyword">sizeof</span>(T), &amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>, &amp;<a class="code" href="a00168.html#a36c957884197e510b1d7176aaf4736a0">assign_array</a>, &amp;<a class="code" href="a00168.html#a99cf2fd728e2a39dfc51ebe41ccc3779">copy_array</a>);</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;    }</div><div class="ttc" id="a00168_html_a99cf2fd728e2a39dfc51ebe41ccc3779"><div class="ttname"><a href="a00168.html#a99cf2fd728e2a39dfc51ebe41ccc3779">tbb::concurrent_vector::copy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC copy_array(void *dst, const void *src, size_type n)</div><div class="ttdoc">Copy-construct n instances of T by copying single element pointed to by src, starting at &quot;dst&quot;...</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01293">concurrent_vector.h:1293</a></div></div>
<div class="ttc" id="a00168_html_a36c957884197e510b1d7176aaf4736a0"><div class="ttname"><a href="a00168.html#a36c957884197e510b1d7176aaf4736a0">tbb::concurrent_vector::assign_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC assign_array(void *dst, const void *src, size_type n)</div><div class="ttdoc">Assign (using operator=) n instances of T, starting at &quot;dst&quot; by assigning according element of src ar...</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01323">concurrent_vector.h:1323</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a00169_html_a2de722203d5e6cb6a18075e451417664"><div class="ttname"><a href="a00169.html#a2de722203d5e6cb6a18075e451417664">tbb::internal::concurrent_vector_base_v3::internal_assign</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_assign(const concurrent_vector_base_v3 &amp;src, size_type element_size, internal_array_op1 destroy, internal_array_op2 assign, internal_array_op2 copy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00380">concurrent_vector.cpp:380</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8498a1335a3bbac2f4925a4e8d70cdb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html">concurrent_vector</a>&amp; <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment for initializer_list. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00764">764</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;                                                                     {</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;        <a class="code" href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">internal_clear</a>(&amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>);</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;        <a class="code" href="a00168.html#aebff613825ded62ed4648117829f5942">internal_assign_iterators</a>(init_list.begin(), init_list.end());</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;    }</div><div class="ttc" id="a00168_html_aebff613825ded62ed4648117829f5942"><div class="ttname"><a href="a00168.html#aebff613825ded62ed4648117829f5942">tbb::concurrent_vector::internal_assign_iterators</a></div><div class="ttdeci">void internal_assign_iterators(I first, I last)</div><div class="ttdoc">assign by iterators </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01262">concurrent_vector.h:1262</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a00169_html_aa8ab12f2be0114336e7bb0c291e611a2"><div class="ttname"><a href="a00169.html#aa8ab12f2be0114336e7bb0c291e611a2">tbb::internal::concurrent_vector_base_v3::internal_clear</a></div><div class="ttdeci">segment_index_t __TBB_EXPORTED_METHOD internal_clear(internal_array_op1 destroy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00505">concurrent_vector.cpp:505</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3097cb46511504acfc9de7da5235f4a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a412441e93ad8656f96b14c5ecb9d817f">reference</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get reference to element at given index. </p>
<p>This method is thread-safe for concurrent reads, and also while growing the vector, as long as the calling thread has checked that index &lt; <a class="el" href="a00168.html#a803268c16e3688ff4681251947d257c7" title="Return size of vector. It may include elements under construction. ">size()</a>. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00860">860</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;                                            {</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="a00168.html#a4ea8843a774a9f52a47e6661fccbde19">internal_subscript</a>(index);</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;    }</div><div class="ttc" id="a00168_html_a4ea8843a774a9f52a47e6661fccbde19"><div class="ttname"><a href="a00168.html#a4ea8843a774a9f52a47e6661fccbde19">tbb::concurrent_vector::internal_subscript</a></div><div class="ttdeci">T &amp; internal_subscript(size_type index) const </div><div class="ttdoc">Get reference to element at given index. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01227">concurrent_vector.h:1227</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abd6ca67f2f97fafca48395af2e693e73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get const reference to element at given index. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00865">865</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;                                                        {</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="a00168.html#a4ea8843a774a9f52a47e6661fccbde19">internal_subscript</a>(index);</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;    }</div><div class="ttc" id="a00168_html_a4ea8843a774a9f52a47e6661fccbde19"><div class="ttname"><a href="a00168.html#a4ea8843a774a9f52a47e6661fccbde19">tbb::concurrent_vector::internal_subscript</a></div><div class="ttdeci">T &amp; internal_subscript(size_type index) const </div><div class="ttdoc">Get reference to element at given index. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01227">concurrent_vector.h:1227</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad68d1675fedef232bfae35f200ba007d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a>&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push item. </p>
<p>Returns iterator pointing to the new element. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00829">829</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;    {</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;        push_back_helper prolog(*<span class="keyword">this</span>);</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;        <span class="keyword">new</span>(prolog.internal_push_back_result()) T(item);</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;        <span class="keywordflow">return</span> prolog.return_iterator_and_dismiss();</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac29a9f08c0fac7c20786c7b8f4f0321a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a4cee8eaee236867c0b6e87309380cb0f">iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push item, move-aware. </p>
<p>Returns iterator pointing to the new element. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00839">839</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;    {</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;        push_back_helper prolog(*<span class="keyword">this</span>);</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;        <span class="keyword">new</span>(prolog.internal_push_back_result()) T(<a class="code" href="a01113.html#ac41903d6b80e61bd6c605412e7820e08">std::move</a>(item));</div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;        <span class="keywordflow">return</span> prolog.return_iterator_and_dismiss();</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;    }</div><div class="ttc" id="a01113_html_ac41903d6b80e61bd6c605412e7820e08"><div class="ttname"><a href="a01113.html#ac41903d6b80e61bd6c605412e7820e08">tbb::move</a></div><div class="ttdeci">void move(tbb_thread &amp;t1, tbb_thread &amp;t2)</div><div class="ttdef"><b>Definition:</b> <a href="a01100_source.html#l00309">tbb_thread.h:309</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8201f65735edcc28aeec95b6e73d75b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a443492ee9918c9e3372b5daca82314ca">range_type</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainsize</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get range for iterating with parallel algorithms. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00880">880</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;                                             {</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="a00168.html#a443492ee9918c9e3372b5daca82314ca">range_type</a>( <a class="code" href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">begin</a>(), <a class="code" href="a00168.html#aad2c07653375e4a5f89c33b375eda610">end</a>(), grainsize );</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;    }</div><div class="ttc" id="a00168_html_a443492ee9918c9e3372b5daca82314ca"><div class="ttname"><a href="a00168.html#a443492ee9918c9e3372b5daca82314ca">tbb::concurrent_vector::range_type</a></div><div class="ttdeci">generic_range_type&lt; iterator &gt; range_type</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00593">concurrent_vector.h:593</a></div></div>
<div class="ttc" id="a00168_html_ab55636c80368ad7d400f3200313fcf5f"><div class="ttname"><a href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">tbb::concurrent_vector::begin</a></div><div class="ttdeci">iterator begin()</div><div class="ttdoc">start iterator </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00933">concurrent_vector.h:933</a></div></div>
<div class="ttc" id="a00168_html_aad2c07653375e4a5f89c33b375eda610"><div class="ttname"><a href="a00168.html#aad2c07653375e4a5f89c33b375eda610">tbb::concurrent_vector::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdoc">end iterator </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00935">concurrent_vector.h:935</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8fcc32ec9ccb48c3327a88fe288c7538"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a1312eb29abf7ca07aa365c727b7844e3">const_range_type</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grainsize</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get const range for iterating with parallel algorithms. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00885">885</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;                                                         {</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="a00168.html#a1312eb29abf7ca07aa365c727b7844e3">const_range_type</a>( <a class="code" href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">begin</a>(), <a class="code" href="a00168.html#aad2c07653375e4a5f89c33b375eda610">end</a>(), grainsize );</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;    }</div><div class="ttc" id="a00168_html_a1312eb29abf7ca07aa365c727b7844e3"><div class="ttname"><a href="a00168.html#a1312eb29abf7ca07aa365c727b7844e3">tbb::concurrent_vector::const_range_type</a></div><div class="ttdeci">generic_range_type&lt; const_iterator &gt; const_range_type</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00594">concurrent_vector.h:594</a></div></div>
<div class="ttc" id="a00168_html_ab55636c80368ad7d400f3200313fcf5f"><div class="ttname"><a href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">tbb::concurrent_vector::begin</a></div><div class="ttdeci">iterator begin()</div><div class="ttdoc">start iterator </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00933">concurrent_vector.h:933</a></div></div>
<div class="ttc" id="a00168_html_aad2c07653375e4a5f89c33b375eda610"><div class="ttname"><a href="a00168.html#aad2c07653375e4a5f89c33b375eda610">tbb::concurrent_vector::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdoc">end iterator </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00935">concurrent_vector.h:935</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9a2f8dce0adcbef8e29273c23723a78e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a1623110816f9ef8f08e7bf6768aed273">reverse_iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reverse start iterator </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00945">945</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="a00168.html#a1623110816f9ef8f08e7bf6768aed273">reverse_iterator</a>(<a class="code" href="a00168.html#aad2c07653375e4a5f89c33b375eda610">end</a>());}</div><div class="ttc" id="a00168_html_aad2c07653375e4a5f89c33b375eda610"><div class="ttname"><a href="a00168.html#aad2c07653375e4a5f89c33b375eda610">tbb::concurrent_vector::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdoc">end iterator </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00935">concurrent_vector.h:935</a></div></div>
<div class="ttc" id="a00168_html_a1623110816f9ef8f08e7bf6768aed273"><div class="ttname"><a href="a00168.html#a1623110816f9ef8f08e7bf6768aed273">tbb::concurrent_vector::reverse_iterator</a></div><div class="ttdeci">std::reverse_iterator&lt; iterator &gt; reverse_iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00582">concurrent_vector.h:582</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a976b0bed19de9ab93f78c10184a4e38f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#ada43b048144c3814036da624d3bb8c58">const_reverse_iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reverse start const iterator </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00949">949</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="a00168.html#ada43b048144c3814036da624d3bb8c58">const_reverse_iterator</a>(<a class="code" href="a00168.html#aad2c07653375e4a5f89c33b375eda610">end</a>());}</div><div class="ttc" id="a00168_html_ada43b048144c3814036da624d3bb8c58"><div class="ttname"><a href="a00168.html#ada43b048144c3814036da624d3bb8c58">tbb::concurrent_vector::const_reverse_iterator</a></div><div class="ttdeci">std::reverse_iterator&lt; const_iterator &gt; const_reverse_iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00583">concurrent_vector.h:583</a></div></div>
<div class="ttc" id="a00168_html_aad2c07653375e4a5f89c33b375eda610"><div class="ttname"><a href="a00168.html#aad2c07653375e4a5f89c33b375eda610">tbb::concurrent_vector::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdoc">end iterator </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00935">concurrent_vector.h:935</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a618f38279a370c18f73ea2c29ded9cb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#a1623110816f9ef8f08e7bf6768aed273">reverse_iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reverse end iterator </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00947">947</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="a00168.html#a1623110816f9ef8f08e7bf6768aed273">reverse_iterator</a>(<a class="code" href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">begin</a>());}</div><div class="ttc" id="a00168_html_ab55636c80368ad7d400f3200313fcf5f"><div class="ttname"><a href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">tbb::concurrent_vector::begin</a></div><div class="ttdeci">iterator begin()</div><div class="ttdoc">start iterator </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00933">concurrent_vector.h:933</a></div></div>
<div class="ttc" id="a00168_html_a1623110816f9ef8f08e7bf6768aed273"><div class="ttname"><a href="a00168.html#a1623110816f9ef8f08e7bf6768aed273">tbb::concurrent_vector::reverse_iterator</a></div><div class="ttdeci">std::reverse_iterator&lt; iterator &gt; reverse_iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00582">concurrent_vector.h:582</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abdb98e17cb65d9c445d7fd1e662c2699"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00168.html#ada43b048144c3814036da624d3bb8c58">const_reverse_iterator</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reverse end const iterator </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00951">951</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="a00168.html#ada43b048144c3814036da624d3bb8c58">const_reverse_iterator</a>(<a class="code" href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">begin</a>());}</div><div class="ttc" id="a00168_html_ada43b048144c3814036da624d3bb8c58"><div class="ttname"><a href="a00168.html#ada43b048144c3814036da624d3bb8c58">tbb::concurrent_vector::const_reverse_iterator</a></div><div class="ttdeci">std::reverse_iterator&lt; const_iterator &gt; const_reverse_iterator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00583">concurrent_vector.h:583</a></div></div>
<div class="ttc" id="a00168_html_ab55636c80368ad7d400f3200313fcf5f"><div class="ttname"><a href="a00168.html#ab55636c80368ad7d400f3200313fcf5f">tbb::concurrent_vector::begin</a></div><div class="ttdeci">iterator begin()</div><div class="ttdoc">start iterator </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00933">concurrent_vector.h:933</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0b3284684328c58c0228c9a697ef3594"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate enough space to grow to size n without having to allocate more memory later. </p>
<p>Like most of the methods provided for STL compatibility, this method is <em>not</em> thread safe. The capacity afterwards may be bigger than the requested reservation. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00907">907</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>Referenced by <a class="el" href="a00245.html#a059dd6cad59b7397bc6ae2405b26a223">tbb::interface6::enumerable_thread_specific&lt; T, Allocator, ETS_key_type &gt;::internal_copy()</a>, and <a class="el" href="a00245.html#ae7ff6e515ba20c782222b654bb85e03d">tbb::interface6::enumerable_thread_specific&lt; T, Allocator, ETS_key_type &gt;::internal_move()</a>.</p>
<div class="fragment"><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;                                {</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;        <span class="keywordflow">if</span>( n )</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;            <a class="code" href="a00169.html#ae07413aa0de51aeb5ec1ec35bbc0095f">internal_reserve</a>(n, <span class="keyword">sizeof</span>(T), <a class="code" href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">max_size</a>());</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;    }</div><div class="ttc" id="a00168_html_a0ec9c3ab3360e04bdaa5174956a3206d"><div class="ttname"><a href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">tbb::concurrent_vector::max_size</a></div><div class="ttdeci">size_type max_size() const </div><div class="ttdoc">Upper bound on argument to reserve. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00926">concurrent_vector.h:926</a></div></div>
<div class="ttc" id="a00169_html_ae07413aa0de51aeb5ec1ec35bbc0095f"><div class="ttname"><a href="a00169.html#ae07413aa0de51aeb5ec1ec35bbc0095f">tbb::internal::concurrent_vector_base_v3::internal_reserve</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_reserve(size_type n, size_type element_size, size_type max_size)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00343">concurrent_vector.cpp:343</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00168_a0b3284684328c58c0228c9a697ef3594_icgraph.svg" width="418" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a65e53a98a1e1fdb515fdc2b84e2314e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the vector. Not thread-safe. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00913">913</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;                               {</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;        <a class="code" href="a00169.html#a57151343a7f7c09dfc70bad5f149c417">internal_resize</a>( n, <span class="keyword">sizeof</span>(T), <a class="code" href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">max_size</a>(), NULL, &amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>, &amp;<a class="code" href="a00168.html#a12b1a671033a824c0027720427072328">initialize_array</a> );</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;    }</div><div class="ttc" id="a00168_html_a12b1a671033a824c0027720427072328"><div class="ttname"><a href="a00168.html#a12b1a671033a824c0027720427072328">tbb::concurrent_vector::initialize_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC initialize_array(void *begin, const void *, size_type n)</div><div class="ttdoc">Construct n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01283">concurrent_vector.h:1283</a></div></div>
<div class="ttc" id="a00168_html_a0ec9c3ab3360e04bdaa5174956a3206d"><div class="ttname"><a href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">tbb::concurrent_vector::max_size</a></div><div class="ttdeci">size_type max_size() const </div><div class="ttdoc">Upper bound on argument to reserve. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00926">concurrent_vector.h:926</a></div></div>
<div class="ttc" id="a00169_html_a57151343a7f7c09dfc70bad5f149c417"><div class="ttname"><a href="a00169.html#a57151343a7f7c09dfc70bad5f149c417">tbb::internal::concurrent_vector_base_v3::internal_resize</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_resize(size_type n, size_type element_size, size_type max_size, const void *src, internal_array_op1 destroy, internal_array_op2 init)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00490">concurrent_vector.cpp:490</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a941917a8a840ff08ce8810ca9476ff46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00168.html#a5ecbb1eb2c7264df9d58255ce211207c">const_reference</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the vector, copy t for new elements. Not thread-safe. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00918">918</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;                                                  {</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;        <a class="code" href="a00169.html#a57151343a7f7c09dfc70bad5f149c417">internal_resize</a>( n, <span class="keyword">sizeof</span>(T), <a class="code" href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">max_size</a>(), static_cast&lt;const void*&gt;(&amp;t), &amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>, &amp;<a class="code" href="a00168.html#a615b7ebb3f9219014924b523c44e085e">initialize_array_by</a> );</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;    }</div><div class="ttc" id="a00168_html_a0ec9c3ab3360e04bdaa5174956a3206d"><div class="ttname"><a href="a00168.html#a0ec9c3ab3360e04bdaa5174956a3206d">tbb::concurrent_vector::max_size</a></div><div class="ttdeci">size_type max_size() const </div><div class="ttdoc">Upper bound on argument to reserve. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00926">concurrent_vector.h:926</a></div></div>
<div class="ttc" id="a00169_html_a57151343a7f7c09dfc70bad5f149c417"><div class="ttname"><a href="a00169.html#a57151343a7f7c09dfc70bad5f149c417">tbb::internal::concurrent_vector_base_v3::internal_resize</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_resize(size_type n, size_type element_size, size_type max_size, const void *src, internal_array_op1 destroy, internal_array_op2 init)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00490">concurrent_vector.cpp:490</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a00168_html_a615b7ebb3f9219014924b523c44e085e"><div class="ttname"><a href="a00168.html#a615b7ebb3f9219014924b523c44e085e">tbb::concurrent_vector::initialize_array_by</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC initialize_array_by(void *begin, const void *src, size_type n)</div><div class="ttdoc">Copy-construct n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01288">concurrent_vector.h:1288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aba805b5225ad3399550f78ea15e51e93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize memory usage and fragmentation. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01186">1186</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>References <a class="el" href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a>, <a class="el" href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a>, <a class="el" href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a>, <a class="el" href="a00388.html#a6ed9cc54885cd01bf0a35337c7d00124">tbb::internal::concurrent_vector_base_v3::internal_segments_table::first_block</a>, <a class="el" href="a00169.html#a01aa29982c8e7708d413f1d30c5953e6">tbb::internal::concurrent_vector_base_v3::internal_compact()</a>, <a class="el" href="a00169.html#abbb8fe2e97a84e53773124c2c0616977a66806961c962fd17c06f0a7d8b7fa6a9">tbb::internal::concurrent_vector_base_v3::pointers_per_long_table</a>, and <a class="el" href="a00388.html#a2653ccdc0ec7a5e71e68cc85992e8ef2">tbb::internal::concurrent_vector_base_v3::internal_segments_table::table</a>.</p>
<div class="fragment"><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;                                            {</div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;    internal_segments_table old;</div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;    <a class="code" href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a> {</div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;        <a class="code" href="a00169.html#a4da4a55fd0545d1b669ca5cc49cd5308">internal_array_op2</a> copy_or_move_array =</div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;<span class="preprocessor">#if __TBB_MOVE_IF_NOEXCEPT_PRESENT</span></div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;                &amp;move_array_if_noexcept</div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;                &amp;<a class="code" href="a00168.html#a99cf2fd728e2a39dfc51ebe41ccc3779">copy_array</a></div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;        ;</div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;        <span class="keywordflow">if</span>( <a class="code" href="a00169.html#a01aa29982c8e7708d413f1d30c5953e6">internal_compact</a>( <span class="keyword">sizeof</span>(T), &amp;old, &amp;<a class="code" href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">destroy_array</a>, copy_or_move_array ) )</div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;            <a class="code" href="a00168.html#a496efbef33d4076867c075c67793aa6c">internal_free_segments</a>( old.table, <a class="code" href="a00169.html#abbb8fe2e97a84e53773124c2c0616977a66806961c962fd17c06f0a7d8b7fa6a9">pointers_per_long_table</a>, old.first_block ); <span class="comment">// free joined and unnecessary segments</span></div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;    } <a class="code" href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a>(...) {</div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;        <span class="keywordflow">if</span>( old.first_block ) <span class="comment">// free segment allocated for compacting. Only for support of exceptions in ctor of user T[ype]</span></div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;            <a class="code" href="a00168.html#a496efbef33d4076867c075c67793aa6c">internal_free_segments</a>( old.table, 1, old.first_block );</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;        <a class="code" href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a>();</div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;    }</div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;}</div><div class="ttc" id="a01098_html_a1e83dce98dc82007213f4109f8903cb8"><div class="ttname"><a href="a01098.html#a1e83dce98dc82007213f4109f8903cb8">__TBB_CATCH</a></div><div class="ttdeci">#define __TBB_CATCH(e)</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00288">tbb_stddef.h:288</a></div></div>
<div class="ttc" id="a00168_html_a99cf2fd728e2a39dfc51ebe41ccc3779"><div class="ttname"><a href="a00168.html#a99cf2fd728e2a39dfc51ebe41ccc3779">tbb::concurrent_vector::copy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC copy_array(void *dst, const void *src, size_type n)</div><div class="ttdoc">Copy-construct n instances of T by copying single element pointed to by src, starting at &quot;dst&quot;...</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01293">concurrent_vector.h:1293</a></div></div>
<div class="ttc" id="a00169_html_a4da4a55fd0545d1b669ca5cc49cd5308"><div class="ttname"><a href="a00169.html#a4da4a55fd0545d1b669ca5cc49cd5308">tbb::internal::concurrent_vector_base_v3::internal_array_op2</a></div><div class="ttdeci">void(__TBB_EXPORTED_FUNC * internal_array_op2)(void *dst, const void *src, size_type n)</div><div class="ttdoc">An operation on n-element destination array and n-element source array. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00247">concurrent_vector.h:247</a></div></div>
<div class="ttc" id="a00168_html_a496efbef33d4076867c075c67793aa6c"><div class="ttname"><a href="a00168.html#a496efbef33d4076867c075c67793aa6c">tbb::concurrent_vector::internal_free_segments</a></div><div class="ttdeci">void internal_free_segments(segment_t table[], segment_index_t k, segment_index_t first_block)</div><div class="ttdoc">Free k segments from table. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01209">concurrent_vector.h:1209</a></div></div>
<div class="ttc" id="a00168_html_a68c028b499fb365ba97f067bdcddb0d6"><div class="ttname"><a href="a00168.html#a68c028b499fb365ba97f067bdcddb0d6">tbb::concurrent_vector::destroy_array</a></div><div class="ttdeci">static void __TBB_EXPORTED_FUNC destroy_array(void *begin, size_type n)</div><div class="ttdoc">Destroy n instances of T, starting at &quot;begin&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l01333">concurrent_vector.h:1333</a></div></div>
<div class="ttc" id="a01098_html_a6df2b2237c9996f178d7b4ac3691c443"><div class="ttname"><a href="a01098.html#a6df2b2237c9996f178d7b4ac3691c443">__TBB_TRY</a></div><div class="ttdeci">#define __TBB_TRY</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00287">tbb_stddef.h:287</a></div></div>
<div class="ttc" id="a00169_html_a01aa29982c8e7708d413f1d30c5953e6"><div class="ttname"><a href="a00169.html#a01aa29982c8e7708d413f1d30c5953e6">tbb::internal::concurrent_vector_base_v3::internal_compact</a></div><div class="ttdeci">void *__TBB_EXPORTED_METHOD internal_compact(size_type element_size, void *table, internal_array_op1 destroy, internal_array_op2 copy)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00515">concurrent_vector.cpp:515</a></div></div>
<div class="ttc" id="a00169_html_abbb8fe2e97a84e53773124c2c0616977a66806961c962fd17c06f0a7d8b7fa6a9"><div class="ttname"><a href="a00169.html#abbb8fe2e97a84e53773124c2c0616977a66806961c962fd17c06f0a7d8b7fa6a9">tbb::internal::concurrent_vector_base_v3::pointers_per_long_table</a></div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00097">concurrent_vector.h:97</a></div></div>
<div class="ttc" id="a01098_html_affef623b71eccade29a6276f789315b8"><div class="ttname"><a href="a01098.html#affef623b71eccade29a6276f789315b8">__TBB_RETHROW</a></div><div class="ttdeci">#define __TBB_RETHROW()</div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00290">tbb_stddef.h:290</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a00168_aba805b5225ad3399550f78ea15e51e93_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a803268c16e3688ff4681251947d257c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00169.html#a0c92dcfc62079e447c41d2b772cdd133">size_type</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return size of vector. It may include elements under construction. </p>

<p>Definition at line <a class="el" href="a00986_source.html#l00893">893</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>Referenced by <a class="el" href="a00245.html#ad225e2e8a968b131bf05d72f5686b924">tbb::interface6::enumerable_thread_specific&lt; T, Allocator, ETS_key_type &gt;::end()</a>, <a class="el" href="a00245.html#a059dd6cad59b7397bc6ae2405b26a223">tbb::interface6::enumerable_thread_specific&lt; T, Allocator, ETS_key_type &gt;::internal_copy()</a>, <a class="el" href="a00245.html#ae7ff6e515ba20c782222b654bb85e03d">tbb::interface6::enumerable_thread_specific&lt; T, Allocator, ETS_key_type &gt;::internal_move()</a>, <a class="el" href="a01113.html#a79ecee2d23f2486c03e720ab9e3ac36c">tbb::operator==()</a>, and <a class="el" href="a00245.html#a4c33c5390783e17daf2b25d53ae919fb">tbb::interface6::enumerable_thread_specific&lt; T, Allocator, ETS_key_type &gt;::size()</a>.</p>
<div class="fragment"><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;                           {</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;        <a class="code" href="a00168.html#ada098ff121699bfed7ae37e759eff93d">size_type</a> sz = <a class="code" href="a00169.html#a1f3773deae9ac723547700419690b043">my_early_size</a>, cp = <a class="code" href="a00169.html#aa358b781e8b59f324feba96f76f05757">internal_capacity</a>();</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;        <span class="keywordflow">return</span> cp &lt; sz ? cp : sz;</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;    }</div><div class="ttc" id="a00168_html_ada098ff121699bfed7ae37e759eff93d"><div class="ttname"><a href="a00168.html#ada098ff121699bfed7ae37e759eff93d">tbb::concurrent_vector::size_type</a></div><div class="ttdeci">internal::concurrent_vector_base_v3::size_type size_type</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00567">concurrent_vector.h:567</a></div></div>
<div class="ttc" id="a00169_html_aa358b781e8b59f324feba96f76f05757"><div class="ttname"><a href="a00169.html#aa358b781e8b59f324feba96f76f05757">tbb::internal::concurrent_vector_base_v3::internal_capacity</a></div><div class="ttdeci">size_type __TBB_EXPORTED_METHOD internal_capacity() const </div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00333">concurrent_vector.cpp:333</a></div></div>
<div class="ttc" id="a00169_html_a1f3773deae9ac723547700419690b043"><div class="ttname"><a href="a00169.html#a1f3773deae9ac723547700419690b043">tbb::internal::concurrent_vector_base_v3::my_early_size</a></div><div class="ttdeci">atomic&lt; size_type &gt; my_early_size</div><div class="ttdoc">Requested size of vector. </div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00185">concurrent_vector.h:185</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="a00168_a803268c16e3688ff4681251947d257c7_icgraph.svg" width="100%" height="515"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8603bd57324fb6b60ba006884c95279d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01016.html#a3935b8702cc0ea3c8cc263b5095d0dc0">void</a> <a class="el" href="a00168.html">tbb::concurrent_vector</a>&lt; T, A &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00168.html">concurrent_vector</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap two instances </p>

<p>Definition at line <a class="el" href="a00986_source.html#l01001">1001</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

<p>Referenced by <a class="el" href="a01113.html#a4cd91084f08db8c2d23c6a0362e0c441">tbb::swap()</a>.</p>
<div class="fragment"><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;                                         {</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;        <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00111.html">tbb::internal::allocator_traits&lt;A&gt;::propagate_on_container_swap</a> pocs_t;</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;        <span class="keywordflow">if</span>( <span class="keyword">this</span> != &amp;vector &amp;&amp; (this-&gt;<a class="code" href="a00052.html#a72f9ed5aac2cf597dc1e6c8e614173b3">my_allocator</a> == vector.my_allocator || <a class="code" href="a01016.html#a2507091f87afae57e117a984a7c4dd61">pocs_t::value</a>) ) {</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;            <a class="code" href="a00169.html#a5913c17dffae92a75f8c1c3caaa7ecf6">concurrent_vector_base_v3::internal_swap</a>(static_cast&lt;concurrent_vector_base_v3&amp;&gt;(vector));</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;            <a class="code" href="a01133.html#a214c362fa3d93966ef63b2ddddc9115e">tbb::internal::allocator_swap</a>(this-&gt;<a class="code" href="a00052.html#a72f9ed5aac2cf597dc1e6c8e614173b3">my_allocator</a>, vector.my_allocator, pocs_t());</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;        }</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;    }</div><div class="ttc" id="a00169_html_a5913c17dffae92a75f8c1c3caaa7ecf6"><div class="ttname"><a href="a00169.html#a5913c17dffae92a75f8c1c3caaa7ecf6">tbb::internal::concurrent_vector_base_v3::internal_swap</a></div><div class="ttdeci">void __TBB_EXPORTED_METHOD internal_swap(concurrent_vector_base_v3 &amp;v)</div><div class="ttdef"><b>Definition:</b> <a href="a00985_source.html#l00586">concurrent_vector.cpp:586</a></div></div>
<div class="ttc" id="a00111_html"><div class="ttname"><a href="a00111.html">tbb::internal::bool_constant</a></div><div class="ttdef"><b>Definition:</b> <a href="a01098_source.html#l00469">tbb_stddef.h:469</a></div></div>
<div class="ttc" id="a00052_html_a72f9ed5aac2cf597dc1e6c8e614173b3"><div class="ttname"><a href="a00052.html#a72f9ed5aac2cf597dc1e6c8e614173b3">tbb::internal::allocator_base::my_allocator</a></div><div class="ttdeci">allocator_type my_allocator</div><div class="ttdef"><b>Definition:</b> <a href="a00986_source.html#l00473">concurrent_vector.h:473</a></div></div>
<div class="ttc" id="a01016_html_a2507091f87afae57e117a984a7c4dd61"><div class="ttname"><a href="a01016.html#a2507091f87afae57e117a984a7c4dd61">value</a></div><div class="ttdeci">void const char const char int ITT_FORMAT __itt_group_sync x void const char ITT_FORMAT __itt_group_sync s void ITT_FORMAT __itt_group_sync p void ITT_FORMAT p void ITT_FORMAT p no args __itt_suppress_mode_t unsigned int void size_t ITT_FORMAT d void ITT_FORMAT p void ITT_FORMAT p __itt_model_site __itt_model_site_instance ITT_FORMAT p __itt_model_task __itt_model_task_instance ITT_FORMAT p void ITT_FORMAT p void ITT_FORMAT p void size_t ITT_FORMAT d void ITT_FORMAT p const wchar_t ITT_FORMAT s const char ITT_FORMAT s const char ITT_FORMAT s const char ITT_FORMAT s no args void ITT_FORMAT p size_t ITT_FORMAT d no args const wchar_t const wchar_t ITT_FORMAT s __itt_heap_function void size_t int ITT_FORMAT d __itt_heap_function void ITT_FORMAT p __itt_heap_function void void size_t int ITT_FORMAT d no args no args unsigned int ITT_FORMAT u const __itt_domain __itt_id ITT_FORMAT lu const __itt_domain __itt_id __itt_id __itt_string_handle ITT_FORMAT p const __itt_domain __itt_id ITT_FORMAT p const __itt_domain __itt_id __itt_timestamp __itt_timestamp ITT_FORMAT lu const __itt_domain __itt_id __itt_id __itt_string_handle ITT_FORMAT p const __itt_domain ITT_FORMAT p const __itt_domain __itt_string_handle unsigned long long value</div><div class="ttdef"><b>Definition:</b> <a href="a01016_source.html#l00181">ittnotify_static.h:181</a></div></div>
<div class="ttc" id="a01133_html_a214c362fa3d93966ef63b2ddddc9115e"><div class="ttname"><a href="a01133.html#a214c362fa3d93966ef63b2ddddc9115e">tbb::internal::allocator_swap</a></div><div class="ttdeci">void allocator_swap(MyAlloc &amp;my_allocator, OtherAlloc &amp;other_allocator, traits_true_type)</div><div class="ttdef"><b>Definition:</b> <a href="a00937_source.html#l00064">_allocator_traits.h:64</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00168_a8603bd57324fb6b60ba006884c95279d_icgraph.svg" width="290" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a134b00c8dd9200b9e45fe81919c66b11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
<div class="memtemplate">
template&lt;typename C , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::vector_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="a00986_source.html#l00561">561</a> of file <a class="el" href="a00986_source.html">concurrent_vector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00986_source.html">concurrent_vector.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr>
<p></p>
Copyright &copy; 2005-2019 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
